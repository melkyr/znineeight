# C89 Code Generation Infrastructure

This document describes the infrastructure used by the RetroZig compiler to generate C89-compliant source code.

## 1. CBackend Class

The `CBackend` is the orchestration layer for code generation. It manages the creation of multiple C source and header files, one for each Zig module.

### Responsibilities:
- **Module Iteration**: Iterates over all compiled modules in a `CompilationUnit`.
- **File Management**: Creates `.c` and `.h` files for each module.
- **Orchestration**: Uses `C89Emitter` to write code to these files.
- **Interface Generation**: Generates public header files (`.h`) containing declarations for symbols marked as `pub` in Zig.
- **Implementation Generation**: Generates C source files (`.c`) containing all definitions, with non-`pub` symbols marked as `static`.

## 2. C89Emitter Class

The `C89Emitter` is the primary interface for writing C89 code to a file. It is designed for efficiency and adherence to the project's technical constraints.

### Key Features:
- **Buffered Output**: Uses a 4KB stack-based buffer to batch writes to the filesystem, minimizing system call overhead without requiring heap allocations in the hot path.
- **Indentation Management**: Maintains a simple indentation level counter and provides a `writeIndent()` helper to ensure consistent code formatting (fixed at 4 spaces).
- **C89-Compliant Comments**: Provides an `emitComment()` helper that ensures all comments use the `/* ... */` style, as `//` comments are not supported in standard C89.
- **Platform Abstraction**: Relies on the `platform.hpp` file I/O primitives, ensuring compatibility with both Win32 (using `kernel32.dll` directly) and POSIX environments.

### Usage in Pipeline:
The `C89Emitter` is typically owned by the `CompilationUnit` and instantiated during the code generation phase.

```cpp
C89Emitter emitter(arena, "output.c");
emitter.emitComment("Generated by RetroZig");
emitter.writeString("int main() {\n");
emitter.indent();
emitter.writeIndent();
emitter.writeString("return 0;\n");
emitter.dedent();
emitter.writeString("}\n");
```

## 3. CVariableAllocator Class

The `CVariableAllocator` manages the allocation and uniquification of C variable names within a function scope. It ensures that all generated identifiers are valid in C89 and compatible with legacy compilers like MSVC 6.0.

### Responsibilities:
- **Keyword Avoidance**: Automatically detects conflicts with the 32 standard C89 keywords (e.g., `int`, `return`, `static`) and prefixes conflicting identifiers with `z_`.
- **Length Enforcement**: Enforces a strict 31-character limit for all identifiers to comply with MSVC 6.0 constraints.
- **Uniquification**: Resolves name collisions within a function by appending numeric suffixes (e.g., `my_var`, `my_var_1`).
- **Sanitization**: Replaces invalid characters in Zig identifiers with underscores to produce valid C identifiers.
- **Temporary Name Generation**: Provides a `generate(base)` method for creating unique names for compiler-generated temporary variables.

### Implementation Details:
- **State Management**: The allocator is designed to be reset via `reset()` at the start of each function body to ensure that names are unique only within their relevant scope.
- **Storage**: Allocated names are interned or copied into the `ArenaAllocator` to avoid manual memory management.

### Example:
Zig name `long_variable_name_exceeding_31_chars` might become `long_variable_name_exceeding_3`.
Zig name `int` becomes `z_int`.
Multiple uses of `tmp` result in `tmp`, `tmp_1`, `tmp_2`, etc.

## 4. Emission Strategies

### 4.1 Multi-Module Generation
The compiler generates a pair of files for each Zig module (e.g., `foo.zig`):
1. **`foo.c`**: Contains the full implementation. Includes `zig_runtime.h`. Private symbols are `static`.
2. **`foo.h`**: Contains the public interface. Only includes declarations for `pub` symbols. Uses standard header guards.

### 4.2 Two-Pass Block Emission
C89 requires all local variable declarations to appear at the beginning of a block, before any executable statements. To support Zig's flexible declaration placement, the `C89Emitter::emitBlock` method employs a two-pass strategy:
1. **Pass 1 (Declarations)**: Scans the block for all `NODE_VAR_DECL` nodes and emits their C declarations (e.g., `int x;`). Initializers are NOT emitted in this pass.
2. **Pass 2 (Statements)**: Emits all nodes in order. Variable declarations with initializers are converted into assignment statements (e.g., `x = 42;`).

### 4.3 Control Flow Mapping
- **If Statements**: Mapped to C `if (cond) { ... } else { ... }`. The condition is always parenthesized.
- **While Loops**:
  - **Unlabeled**: Mapped to C `while (cond) { ... }`.
  - **Labeled**: Mapped to a `goto`-based pattern to support multi-level jumps:
    ```c
    __zig_label_L_0_start: ;
    if (!(cond)) goto __zig_label_L_0_end;
    { /* body */ }
    goto __zig_label_L_0_start;
    __zig_label_L_0_end: ;
    ```
- **For Loops**: Translated to an equivalent `while` loop wrapped in a new block to handle capture variables and unique loop state.
  - **Discarding Captures**: If a capture is named `_`, the emitter does not generate a C variable declaration or assignment for it.
  - **Arrays/Slices**:
    ```c
    {
        size_t __for_idx_1 = 0;
        size_t __for_len_1 = /* len */;
        while (__for_idx_1 < __for_len_1) {
            T item = iterable[__for_idx_1];
            /* body */
            __for_idx_1++;
        }
    }
    ```
  - **Ranges**:
    ```c
    {
        size_t __for_idx_1 = start;
        size_t __for_len_1 = end;
        while (__for_idx_1 < __for_len_1) {
            size_t item = __for_idx_1;
            /* body */
            __for_idx_1++;
        }
    }
    ```
- **Break/Continue**:
  - **Unlabeled**: Mapped directly to C `break;` and `continue;`.
  - **Labeled**: Mapped to `goto __zig_label_L_N_end;` and `goto __zig_label_L_N_start;` respectively.
- **Return Statements**: Mapped to `return expr;` or `return;`. If `defer` statements are active in the function, they are emitted before the return. If the function returns a value, a temporary variable is used to hold the value while defers run.
- **Defer Statements**: Implemented using a compile-time stack of deferred actions.
  - When entering a block, a new scope is pushed onto the stack.
  - `defer` statements are added to the current scope on the stack.
  - At the natural end of a block, all defers in that scope are emitted in reverse order.
  - For `return`, `break`, and `continue`, the emitter identifies all scopes being exited and emits their deferred actions in order (from innermost outward) before emitting the jump or return.

### 4.4 Slice Support
Slices (`[]T`) are emitted as C structs containing a pointer and a length.

#### Type Definition
For each unique slice type encountered, the compiler generates a `typedef` and a static inline helper function for construction.
- **Naming**: Slice structs are named using a mangling scheme: `Slice_` + mangled element type (e.g., `Slice_i32`, `Slice_Ptr_i32`).
- **Visibility**: If a slice is used in a `pub` declaration, its `typedef` and helper are placed in the module's header (`.h`). Otherwise, they are in the implementation file (`.c`).
- **Const Qualifiers**: `const` is dropped in the emitted C code, so `[]const T` and `[]T` use the same C struct.

#### Operations
- **Indexing**: `s[i]` is emitted as `s.ptr[i]`.
- **Length**: `s.len` is emitted as `s.len`.
- **Slicing**: `base[start..end]` is emitted as a call to the generated helper: `__make_slice_T(computed_ptr, computed_len)`.
- **Implicit Coercion**: Array-to-slice coercion is automatically handled by the `TypeChecker` by inserting a synthetic slicing node, which the emitter then translates into a helper call.

#### Helper Functions
For each unique slice type, a construction helper is generated:
- **Signature**: `static RETR_UNUSED_FUNC Slice_T __make_slice_T(T* ptr, usize len)`
- **Implementation**: Returns a `Slice_T` struct initialized with the provided pointer and length.
- **Usage**: Invoked for all slicing expressions (`base[start..end]`) and implicit array-to-slice coercions.

### 4.5 Array and Struct Initializers
Standard C89 does not allow array or struct assignment after declaration (e.g., `arr = {1, 2, 3};` is invalid). To support Zig's flexible variable initialization, the `C89Emitter` employs the following strategy for local variables:
1. **Positional Initialization**: If a variable is initialized with `{ ... }`, the emitter generates a series of individual assignments for each field or array element.
   - Zig `var arr = [3]i32{1, 2, 3};` becomes:
     ```c
     int arr[3];
     arr[0] = 1;
     arr[1] = 2;
     arr[2] = 3;
     ```
   - This approach ensures compatibility with C89 and works correctly even if the initializer elements are non-constant expressions.
2. **Global Constant Initializers**: Global variables (using `pub const` or `pub var`) are emitted using C-style constant initializers: `static int arr[3] = {1, 2, 3};`.

### 4.5 Built-in Intrinsics
- **@ptrCast(T, expr)**: Emitted as a standard C-style cast: `(T)expr`.
- **@intCast / @floatCast**: Handled by the TypeChecker for constants (constant folding). For runtime values, they are intended to emit calls to checked conversion helpers (e.g., `__bootstrap_i32_from_u32(x)`).

### 4.6 Many-item Pointers ([*]T)
Many-item pointers (e.g., `[*]u8`, `[*]const i32`) are supported in the bootstrap compiler. They represent pointers to zero or more items of type `T`, mapping directly to C's raw pointers (`T*`).

#### Semantics
- **Indexing**: `[*]T` supports indexing `ptr[i]`, returning a value of type `T`.
- **Dereferencing**: `[*]T` supports the dereference operator `.*`, yielding the first element (equivalent to `ptr[0]`). Mapped to C `*ptr`.
- **Arithmetic**: `[*]T` supports pointer arithmetic (`ptr + i`, `i + ptr`, `ptr - i`) and pointer subtraction (`ptr1 - ptr2`).
  - Arithmetic requires **unsigned** integer offsets (`usize`, `u32`).
  - Pointer subtraction yields `isize`.
- **Nullability**: In the bootstrap compiler, `[*]T` can be assigned the `null` literal (mapped to `((void*)0)`).

#### Pointer Arithmetic Summary
| Operation | Many-item ([*]T) | Single-item (*T) | Result Type |
|-----------|------------------|------------------|-------------|
| `ptr + unsigned` | ✓ Allowed | ✗ REJECTED | `[*]T` |
| `ptr - unsigned` | ✓ Allowed | ✗ REJECTED | `[*]T` |
| `ptr1 - ptr2` | ✓ Allowed | ✗ REJECTED | `isize` |
| `ptr[i]` | ✓ Allowed | ✗ REJECTED | `T` |
| `ptr.*` | ✓ Allowed | ✓ Allowed | `T` |

#### Multi-level Pointers
Arithmetic on multi-level pointers is supported only if the outer level is a many-item pointer.
- Zig `var pp: [*]*i32` -> C `int** pp`.
- `pp + 1` advances by `sizeof(int*)`.

### 4.7 Operator Precedence & Parentheses
The emitter maintains correct C precedence by automatically parenthesizing the base expressions of postfix operators (`.`, `->`, `[]`, `()`) when the base expression involves lower-precedence operators like unary `*` or `&`. For example, Zig `ptr.*.field` becomes C `(*ptr).field`.

### 4.8 Multi-level Pointers (**T)
Multi-level pointers (e.g., `**i32`, `***f64`) are fully supported in the bootstrap compiler and map directly to C's multi-level pointers (e.g., `int**`, `double***`).

### 4.9 Function Pointers
Function pointers (e.g., `fn(i32) i32`) are supported and map to C's function pointer syntax.

#### Recursive Declarators
C's "inside-out" declarator syntax is handled by a recursive emission strategy (`emitTypePrefix` and `emitTypeSuffix`). This ensures that complex nested types like "array of pointers to functions returning pointers to functions" are emitted correctly.

Examples:
- Zig `var fp: fn(i32) void` -> C `void (*fp)(int)`
- Zig `var fp2: fn(i32, i32) i32` -> C `int (*fp2)(int, int)`
- Zig `var fps: [10]fn() void` -> C `void (*fps[10])(void)`
- Zig `fn foo() fn() void` -> C `void (*foo(void))(void)`
- Zig `fn get_handler(id: i32) fn(i32) i32` -> C `int (*get_handler(int))(int)`

#### Indirect Calls
Indirect calls through function pointer variables or complex expressions (e.g., `fps[0]()`) are emitted directly as standard C function calls: `callee(args)`. C89 allows implicit dereferencing of function pointers.

#### Limitations
- **Parameter Limit**: Arbitrary parameter limits (previously 4) have been removed; function pointers now support an unlimited number of parameters via dynamic allocation.
- **Implicit Coercion**: Function declarations (names) implicitly coerce to their corresponding function pointer type when assigned or passed as arguments, provided signatures match exactly.
- **Calling Convention**: Defaults to `__cdecl`. Custom calling conventions are not supported.
- **Nullability**: Function pointers can be assigned `null` (temporary bootstrap extension).

#### Const Qualifiers
To simplify code generation and avoid complex C declaration syntax (e.g., `int* const*`), the RetroZig bootstrap compiler **drops all `const` qualifiers** in the generated C code for pointers and variables.
- Zig `*const i32` -> C `int*`
- Zig `*const *i32` -> C `int**`
- Zig `const x: i32 = 42` -> C `int x = 42`

This is safe because the Zig compiler frontend already enforces const-correctness during semantic analysis. The generated C code serves only as an intermediate representation where these qualifiers are not required for correctness.

## 5. Master STU File & Build System

To simplify compilation and linking, the `CBackend` generates a master entry point when a `pub fn main` is detected.

### 5.1 Master Entry Point (`main.c` / `master.c`)
If any module contains a `pub fn main`, the backend generates a master Single Translation Unit (STU) file.
- **Filename**: Usually `main.c`. If a module is already named `main`, the master file is named `master.c` to avoid conflict, and the module file is named `main_module.c`.
- **Content**: A series of `#include` directives for every generated `.c` module implementation.
- **Advantage**: Allows the entire program to be compiled with a single compiler command, eliminating the need for a complex linker stage.

### 5.2 Build Automation
The backend automatically generates basic build scripts in the output directory:
- **`build.bat`**: A Windows batch script that invokes the MSVC compiler (`cl`) to produce `app.exe`.
- **`Makefile`**: A standard Makefile for Unix-like environments that uses `gcc` to produce the `app` binary.
