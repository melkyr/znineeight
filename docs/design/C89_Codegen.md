# C89 Code Generation Infrastructure

This document describes the infrastructure used by the RetroZig compiler to generate C89-compliant source code.

## 1. C89Emitter Class

The `C89Emitter` is the primary interface for writing C89 code to a file. It is designed for efficiency and adherence to the project's technical constraints.

### Key Features:
- **Buffered Output**: Uses a 4KB stack-based buffer to batch writes to the filesystem, minimizing system call overhead without requiring heap allocations in the hot path.
- **Indentation Management**: Maintains a simple indentation level counter and provides a `writeIndent()` helper to ensure consistent code formatting (fixed at 4 spaces).
- **C89-Compliant Comments**: Provides an `emitComment()` helper that ensures all comments use the `/* ... */` style, as `//` comments are not supported in standard C89.
- **Platform Abstraction**: Relies on the `platform.hpp` file I/O primitives, ensuring compatibility with both Win32 (using `kernel32.dll` directly) and POSIX environments.

### Usage in Pipeline:
The `C89Emitter` is typically owned by the `CompilationUnit` and instantiated during the code generation phase.

```cpp
C89Emitter emitter(arena, "output.c");
emitter.emitComment("Generated by RetroZig");
emitter.writeString("int main() {\n");
emitter.indent();
emitter.writeIndent();
emitter.writeString("return 0;\n");
emitter.dedent();
emitter.writeString("}\n");
```

## 2. CVariableAllocator Class

The `CVariableAllocator` manages the allocation and uniquification of C variable names within a function scope. It ensures that all generated identifiers are valid in C89 and compatible with legacy compilers like MSVC 6.0.

### Responsibilities:
- **Keyword Avoidance**: Automatically detects conflicts with the 32 standard C89 keywords (e.g., `int`, `return`, `static`) and prefixes conflicting identifiers with `z_`.
- **Length Enforcement**: Enforces a strict 31-character limit for all identifiers to comply with MSVC 6.0 constraints.
- **Uniquification**: Resolves name collisions within a function by appending numeric suffixes (e.g., `my_var`, `my_var_1`).
- **Sanitization**: Replaces invalid characters in Zig identifiers with underscores to produce valid C identifiers.
- **Temporary Name Generation**: Provides a `generate(base)` method for creating unique names for compiler-generated temporary variables.

### Implementation Details:
- **State Management**: The allocator is designed to be reset via `reset()` at the start of each function body to ensure that names are unique only within their relevant scope.
- **Storage**: Allocated names are interned or copied into the `ArenaAllocator` to avoid manual memory management.

### Example:
Zig name `long_variable_name_exceeding_31_chars` might become `long_variable_name_exceeding_3`.
Zig name `int` becomes `z_int`.
Multiple uses of `tmp` result in `tmp`, `tmp_1`, `tmp_2`, etc.

## 3. Emission Strategies

### 3.1 Two-Pass Block Emission
C89 requires all local variable declarations to appear at the beginning of a block, before any executable statements. To support Zig's flexible declaration placement, the `C89Emitter::emitBlock` method employs a two-pass strategy:
1. **Pass 1 (Declarations)**: Scans the block for all `NODE_VAR_DECL` nodes and emits their C declarations (e.g., `int x;`). Initializers are NOT emitted in this pass.
2. **Pass 2 (Statements)**: Emits all nodes in order. Variable declarations with initializers are converted into assignment statements (e.g., `x = 42;`).

### 3.2 Control Flow Mapping
- **If Statements**: Mapped to C `if (cond) { ... } else { ... }`. The condition is always parenthesized.
- **While Loops**: Mapped to C `while (cond) { ... }`. Supports `break` and `continue`.
- **Return Statements**: Mapped to `return expr;` or `return;`.

### 3.3 Built-in Intrinsics
- **@ptrCast(T, expr)**: Emitted as a standard C-style cast: `(T)expr`.
- **@intCast / @floatCast**: Handled by the TypeChecker for constants (constant folding). For runtime values, they are intended to emit calls to checked conversion helpers (e.g., `__bootstrap_i32_from_u32(x)`).

### 3.4 Operator Precedence & Parentheses
The emitter maintains correct C precedence by automatically parenthesizing the base expressions of postfix operators (`.`, `->`, `[]`, `()`) when the base expression involves lower-precedence operators like unary `*` or `&`. For example, Zig `ptr.*.field` becomes C `(*ptr).field`.
