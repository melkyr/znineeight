# C89 Code Generation Infrastructure

This document describes the infrastructure used by the RetroZig compiler to generate C89-compliant source code.

## 1. CBackend Class

The `CBackend` is the orchestration layer for code generation. It manages the creation of multiple C source and header files, one for each Zig module.

### Responsibilities:
- **Module Iteration**: Iterates over all compiled modules in a `CompilationUnit`.
- **File Management**: Creates `.c` and `.h` files for each module.
- **Orchestration**: Uses `C89Emitter` to write code to these files.
- **Interface Generation**: Generates public header files (`.h`) containing declarations for symbols marked as `pub` in Zig.
- **Implementation Generation**: Generates C source files (`.c`) containing all definitions, with non-`pub` symbols marked as `static`.

## 2. C89Emitter Class

The `C89Emitter` is the primary interface for writing C89 code to a file. It is designed for efficiency and adherence to the project's technical constraints.

### Key Features:
- **Buffered Output**: Uses a 4KB stack-based buffer to batch writes to the filesystem, minimizing system call overhead without requiring heap allocations in the hot path.
- **Indentation Management**: Maintains a simple indentation level counter and provides a `writeIndent()` helper to ensure consistent code formatting (fixed at 4 spaces).
- **C89-Compliant Comments**: Provides an `emitComment()` helper that ensures all comments use the `/* ... */` style, as `//` comments are not supported in standard C89.
- **Platform Abstraction**: Relies on the `platform.hpp` file I/O primitives, ensuring compatibility with both Win32 (using `kernel32.dll` directly) and POSIX environments.

### Usage in Pipeline:
The `C89Emitter` is typically owned by the `CompilationUnit` and instantiated during the code generation phase.

```cpp
C89Emitter emitter(arena, "output.c");
emitter.emitComment("Generated by RetroZig");
emitter.writeString("int main() {\n");
emitter.indent();
emitter.writeIndent();
emitter.writeString("return 0;\n");
emitter.dedent();
emitter.writeString("}\n");
```

## 3. CVariableAllocator Class

The `CVariableAllocator` manages the allocation and uniquification of C variable names within a function scope. It ensures that all generated identifiers are valid in C89 and compatible with legacy compilers like MSVC 6.0.

### Responsibilities:
- **Keyword Avoidance**: Automatically detects conflicts with the 32 standard C89 keywords (e.g., `int`, `return`, `static`) and prefixes conflicting identifiers with `z_`.
- **Length Enforcement**: Enforces a strict 31-character limit for all identifiers to comply with MSVC 6.0 constraints.
- **Uniquification**: Resolves name collisions within a function by appending numeric suffixes (e.g., `my_var`, `my_var_1`).
- **Sanitization**: Replaces invalid characters in Zig identifiers with underscores to produce valid C identifiers.
- **Temporary Name Generation**: Provides a `generate(base)` method for creating unique names for compiler-generated temporary variables.

### Implementation Details:
- **State Management**: The allocator is designed to be reset via `reset()` at the start of each function body to ensure that names are unique only within their relevant scope.
- **Storage**: Allocated names are interned or copied into the `ArenaAllocator` to avoid manual memory management.

### Example:
Zig name `long_variable_name_exceeding_31_chars` might become `long_variable_name_exceeding_3`.
Zig name `int` becomes `z_int`.
Multiple uses of `tmp` result in `tmp`, `tmp_1`, `tmp_2`, etc.

## 4. Emission Strategies

### 4.1 Multi-Module Generation
The compiler generates a pair of files for each Zig module (e.g., `foo.zig`):
1. **`foo.c`**: Contains the full implementation. Includes `zig_runtime.h`. Private symbols are `static`.
2. **`foo.h`**: Contains the public interface. Only includes declarations for `pub` symbols. Uses standard header guards.

### 4.2 Two-Pass Block Emission
C89 requires all local variable declarations to appear at the beginning of a block, before any executable statements. To support Zig's flexible declaration placement, the `C89Emitter::emitBlock` method employs a two-pass strategy:
1. **Pass 1 (Declarations)**: Scans the block for all `NODE_VAR_DECL` nodes and emits their C declarations (e.g., `int x;`). Initializers are NOT emitted in this pass.
2. **Pass 2 (Statements)**: Emits all nodes in order. Variable declarations with initializers are converted into assignment statements (e.g., `x = 42;`).

### 4.3 Control Flow Mapping
- **If Statements**: Mapped to C `if (cond) { ... } else { ... }`. The condition is always parenthesized.
- **While Loops**: Mapped to C `while (cond) { ... }`. Supports `break` and `continue`.
- **Return Statements**: Mapped to `return expr;` or `return;`.

### 4.4 Built-in Intrinsics
- **@ptrCast(T, expr)**: Emitted as a standard C-style cast: `(T)expr`.
- **@intCast / @floatCast**: Handled by the TypeChecker for constants (constant folding). For runtime values, they are intended to emit calls to checked conversion helpers (e.g., `__bootstrap_i32_from_u32(x)`).

### 4.5 Pointer Types Limitation
**Many-item pointers ([*]T) are not supported** in the bootstrap compiler. Use single-item pointers (*T) and explicit casts via @ptrCast when necessary. This restriction maintains the simplicity of the rejection framework and ensures compatibility with the C89 subset.

### 4.6 Operator Precedence & Parentheses
The emitter maintains correct C precedence by automatically parenthesizing the base expressions of postfix operators (`.`, `->`, `[]`, `()`) when the base expression involves lower-precedence operators like unary `*` or `&`. For example, Zig `ptr.*.field` becomes C `(*ptr).field`.

## 5. Master STU File & Build System

To simplify compilation and linking, the `CBackend` generates a master entry point when a `pub fn main` is detected.

### 5.1 Master Entry Point (`main.c` / `master.c`)
If any module contains a `pub fn main`, the backend generates a master Single Translation Unit (STU) file.
- **Filename**: Usually `main.c`. If a module is already named `main`, the master file is named `master.c` to avoid conflict, and the module file is named `main_module.c`.
- **Content**: A series of `#include` directives for every generated `.c` module implementation.
- **Advantage**: Allows the entire program to be compiled with a single compiler command, eliminating the need for a complex linker stage.

### 5.2 Build Automation
The backend automatically generates basic build scripts in the output directory:
- **`build.bat`**: A Windows batch script that invokes the MSVC compiler (`cl`) to produce `app.exe`.
- **`Makefile`**: A standard Makefile for Unix-like environments that uses `gcc` to produce the `app` binary.
