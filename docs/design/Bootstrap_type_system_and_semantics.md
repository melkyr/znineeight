# Bootstrap Type System & Semantic Analysis

This document provides a detailed specification for the initial type system of the RetroZig bootstrap compiler. Its primary goal is to support a subset of Zig's type system that is directly translatable to C89, adhering to the project's strict technical and historical constraints.

## 1. Core Philosophy

The bootstrap type system is intentionally minimal. It is not designed to handle the full complexity of Zig's advanced type features (e.g., comptime types, error unions, slices). Instead, it focuses on a core set of primitive and pointer types that have direct equivalents in C89. This ensures that the code generated by the bootstrap compiler is simple, predictable, and compatible with legacy C compilers.

Semantic analysis at this stage will be limited to what is necessary to support this C89-compatible subset, including:
-   **Type checking:** Verifying that operations are performed on compatible types.
-   **Symbol resolution:** Looking up variables and functions in the symbol table.
-   **Scope management:** Handling global and function-level scopes.

## 2. Type Representation

The fundamental building block of the type system is the `Type` struct. It is designed to be a lightweight descriptor for any type recognized by the bootstrap compiler.

### `TypeKind` Enum

This enum defines all the primitive and composite types supported in the bootstrap phase. Each `TypeKind` corresponds to a C89-compatible data type.

```cpp
/**
 * @enum TypeKind
 * @brief Defines the kind of each type in the bootstrap type system.
 */
enum TypeKind {
    TYPE_VOID,
    TYPE_BOOL,
    // Integer Types
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    // Platform-dependent Integer Types
    TYPE_ISIZE, // Maps to i32 on a 32-bit target
    TYPE_USIZE, // Maps to u32 on a 32-bit target
    // Floating-Point Types
    TYPE_F32,
    TYPE_F64,
    // Complex Types
    TYPE_POINTER,
    TYPE_ARRAY,
    TYPE_FUNCTION,
    TYPE_ENUM,
    TYPE_STRUCT,
    TYPE_ERROR_UNION,
    TYPE_ERROR_SET,
    TYPE_OPTIONAL,
    TYPE_TYPE,
    TYPE_ANYTYPE
};
```

### `Type` Struct

The `Type` struct contains the `TypeKind` discriminator, information about the type's size and alignment, and a `union` to hold data for composite types (like pointers).

```cpp
// Forward-declare Type for the pointer union member
struct Type;

/**
 * @struct Type
 * @brief Represents a type within the bootstrap compiler's type system.
 */
struct Type {
    TypeKind kind;
    size_t size;
    size_t alignment;

    union {
        /**
         * @struct PointerDetails
         * @brief Details specific to pointer types.
         */
        struct PointerDetails {
            Type* base; // The type that the pointer points to.
            bool is_const;
        } pointer;

        /**
         * @struct FunctionDetails
         * @brief Details specific to function types.
         */
        struct FunctionDetails {
            DynamicArray<Type*>* params;
            Type* return_type;
        } function;

        /**
         * @struct ArrayDetails
         * @brief Details specific to array types.
         */
        struct ArrayDetails {
            Type* element_type; // The type of the elements in the array.
            u64 size;           // The number of elements in the array.
        } array;

        /**
         * @struct EnumDetails
         * @brief Details specific to enum types.
         */
        struct EnumDetails {
            Type* backing_type;
            DynamicArray<EnumMember>* members;
        } enum_details;

        struct StructDetails {
            DynamicArray<StructField>* fields;
        } struct_details;

        struct ErrorUnionDetails {
            Type* payload;
            Type* error_set; // NULL for inferred
            bool is_inferred;
        } error_union;

        struct ErrorSetDetails {
            const char* name; // NULL for anonymous
            DynamicArray<const char*>* tags;
            bool is_anonymous;
        } error_set;
    } as;
};
```

**Memory Management:** Like AST nodes, all `Type` structs are allocated from the `ArenaAllocator` to ensure fast allocation and simple, collective deallocation.

## 3. Assignment Compatibility (C89 Rules)

To ensure the bootstrap compiler generates valid and predictable C89 code, the type checker enforces a strict set of rules for assignment, compound assignment, and variable initialization. These rules are generally stricter than the simple type compatibility used for function arguments. The core logic is encapsulated in the `IsTypeAssignableTo` method.

### The Default Rule: Strict Type Equality

For most operations, C89 requires that the types of the left-hand side (l-value) and right-hand side (r-value) be **identical**. The type checker enforces this as the default rule.

-   **Numeric Types:** An assignment is only valid if the source and target types are exactly the same. Implicit widening is **not** allowed in assignment contexts.
    -   `var x: i32 = my_i32;` // ✓ OK
    -   `var x: i64 = my_i32;` // ✗ **Error:** `i32` is not identical to `i64`.

### Exception 1: The Integer Literal Rule

A critical exception to the strict equality rule, inherited from C89, applies to **integer literals**. An integer literal (e.g., `42`, `-100`) can be assigned to a variable of any numeric type (integer or float) as long as the literal's value fits within the valid range of the target type.

-   `var x: i16 = 128;`      // ✓ OK: `128` fits in an `i16`.
-   `var x: u8 = 255;`       // ✓ OK: `255` fits in a `u8`.
-   `var x: i64 = 42;`       // ✓ OK: `42` (inferred as `i32` literal) fits in an `i64`.
-   `var x: u8 = -1;`        // ✗ **Error:** `-1` is out of range for `u8`.
-   `var x: i8 = 128;`       // ✗ **Error:** `128` overflows `i8`.

This logic is primarily handled in the `visitVarDecl` method, which uses the `canLiteralFitInType` helper to perform the value range check.

### Exception 2: Pointer Assignment Rules

Pointer assignments follow a specific set of C89-compatible rules:

1.  **Null Assignment:** The `null` literal can be assigned to a variable of any pointer type.
    -   `var p: *i32 = null;` // ✓ OK

2.  **Implicit Cast to `void*`:** Any typed pointer (`*T`) can be implicitly assigned to a `void` pointer (`*void`).
    -   `var p_void: *void = my_i32_ptr;` // ✓ OK

3.  **Implicit Cast from `void*`:** A `void` pointer can be implicitly assigned to any typed pointer (`*T`), provided that `T` is C89-compatible. This matches C89 behavior for `void*`.
    -   `var p: *i32 = arena_alloc(4u);` // ✓ OK

4.  **Const Correctness:**
    -   A mutable pointer (`*T`) can be assigned to a constant pointer (`*const T`). This is a safe, "const-adding" conversion.
        - `var p_const: *const i32 = my_i32_ptr;` // ✓ OK
    -   A constant pointer (`*const T`) cannot be assigned to a mutable pointer (`*T`). This would unsafely remove the `const` qualification.
        - `var p_mut: *i32 = my_const_i32_ptr;` // ✗ **Error**

### Compound Assignment Rules

Compound assignment operations (`+=`, `-=`, etc.) follow the same modifiable l-value and type compatibility rules as simple assignment, but with additional restrictions based on the operator:

1.  **L-Value Requirement:** The left-hand side must be a modifiable l-value (not `const`).
2.  **Arithmetic Operators (`+=`, `-=`, `*=`, `/=`, `%=`):** Both operands must be numeric types of the **exact same type**.
3.  **Bitwise Operators (`&=`, `|=`, `^=`, `<<=`, `>>=`):** Both operands must be integer types of the **exact same type**.
4.  **Pointer Arithmetic (`+=`, `-=`):** The left-hand side can be a pointer, in which case the right-hand side must be an integer type.

### Summary of Assignment Rules

| From Type (`source`)    | To Type (`target`)     | Assignable? | Notes                                                              |
|-------------------------|------------------------|-------------|--------------------------------------------------------------------|
| `numeric`               | `numeric`              | ✗ (if different) | Must be identical types.                                           |
| `integer_literal`       | `any_numeric`          | ✓ (if value fits) | C89 exception for literals.                                        |
| `null`                  | `*T` (any pointer)     | ✓           | `null` is compatible with all pointers.                            |
| `*T`                    | `*void`                | ✓           | Implicit "up-cast" to void pointer.                                |
| `*void`                 | `*T`                   | ✓           | Implicit "down-cast" if T is C89-compatible.                       |
| `*T`                    | `*const T`             | ✓           | Safe to add `const`.                                               |
| `*const T`              | `*T`                   | ✗           | Unsafe to remove `const`.                                          |
| `*T`                    | `*U` (different types) | ✗           | Incompatible pointer base types.                                   |


## 4. Semantic Analysis

The semantic analyzer will traverse the AST generated by the parser and use the type system to perform the following checks.

### Symbol Table

A `SymbolTable` is a critical component for semantic analysis, responsible for tracking all named entities (variables, functions, types) across different scopes. The bootstrap compiler's symbol table is designed for performance and efficiency, using a hash table for symbol storage within each scope.

#### Implementation Details

-   **Hierarchical Scopes:** The `SymbolTable` class manages a stack of `Scope` objects, allowing it to correctly model nested scopes (e.g., function bodies, block statements). `enterScope()` pushes a new scope onto the stack, and `exitScope()` pops it.
-   **Hash Table:** Each `Scope` object contains a hash table to store its symbols. This provides an average time complexity of O(1) for symbol insertion and lookup operations, a significant improvement over the previous O(n) linear scan approach.
-   **Collision Resolution:** Collisions in the hash table are resolved using separate chaining. Each bucket in the hash table is a linked list of `SymbolEntry` structs.
-   **Hashing Algorithm:** The hash table uses the 32-bit FNV-1a algorithm to hash symbol names, which provides good distribution for identifiers.
-   **Dynamic Resizing:** To maintain O(1) performance, the hash table automatically resizes itself when its load factor exceeds 75% (0.75). When a resize is triggered, the number of buckets is doubled, and all existing symbols are re-hashed into the new, larger table.

#### `Symbol` Struct

Each entry in the symbol table is a `Symbol` struct, which contains all the necessary information about a named entity.

```cpp
// from symbol_table.hpp
struct Symbol {
    const char* name;
    SymbolType kind;
    Type* symbol_type;
    SourceLocation location;
    void* details;
    unsigned int scope_level;
    unsigned int flags;
};

/**
 * @enum SymbolFlag
 * @brief Bitmask flags for symbols.
 */
enum SymbolFlag {
    SYMBOL_FLAG_LOCAL   = (1 << 0),  // Stack-allocated variable/parameter
    SYMBOL_FLAG_STATIC  = (1 << 1),  // Static storage
    SYMBOL_FLAG_PARAM   = (1 << 2),  // Function parameter
    SYMBOL_FLAG_GLOBAL  = (1 << 3)   // Global variable
};
```

#### `SymbolTable` and `Scope` Classes

The `SymbolTable` class orchestrates scope management, while the `Scope` struct handles the actual storage of symbols.

```cpp
// from symbol_table.hpp
class SymbolTable {
    // ...
public:
    void enterScope();
    void exitScope();
    bool insert(const Symbol& symbol);
    Symbol* lookup(const char* name);
    Symbol* lookupInCurrentScope(const char* name);
    // ...
};
```

-   **`lookup(const char* name)`:** Searches for a symbol starting from the current (innermost) scope and proceeding outwards to the global scope. Returns the first match found.
-   **`insert(const Symbol& symbol)`:** Inserts a symbol into the current scope's hash table. It first checks for redefinitions within the current scope and returns `false` if a symbol with the same name already exists.

### Variable Declarations

When visiting a variable declaration (`ASTVarDeclNode`), the `TypeChecker` performs the following validation:
-   It resolves the declared type of the variable.
-   It then checks the initializer. If the initializer is an integer literal, it uses the special C89 literal assignment rule (`canLiteralFitInType`).
-   For all other initializer types, it uses the strict `IsTypeAssignableTo` function to validate the assignment.
-   If the types are not compatible, a detailed `ERR_TYPE_MISMATCH` is reported.
-   Redefinition checks are handled by the `Parser` when it inserts the variable's symbol into the `SymbolTable`.

### Array Type Declarations

When visiting an array type declaration (`ASTArrayTypeNode`), the `TypeChecker` enforces strict C89 compatibility rules:

1.  **Slice Rejection:** Slices (e.g., `[]u8`) are not supported in the bootstrap compiler. The `TypeChecker` identifies a slice by checking if the `size` expression in the `ASTArrayTypeNode` is `NULL`. If it is, a non-C89 feature error is reported: "Slices are not supported in bootstrap compiler. Consider using a pointer and length instead.".

2.  **Constant Size Enforcement:** C89 requires that array sizes be compile-time constants. The bootstrap compiler enforces a strict version of this rule: the size expression must be a single integer literal (e.g., `[8]i32`). If the size expression is any other kind of node (e.g., an identifier, a binary operation), compilation is aborted with a fatal error: "Array size must be a constant integer literal".

If both checks pass, a new `Type` of kind `TYPE_ARRAY` is created. Its `size` field is calculated from the element type's size and the array's length, and its `as.array` details are populated accordingly.

### Struct Type Declarations and Validation

When visiting a struct declaration (`ASTStructDeclNode`), the `TypeChecker` creates a new `TYPE_STRUCT` and performs comprehensive validation and layout calculation:

1.  **Field Uniqueness:** The `TypeChecker` ensures that all field names within a struct are unique. Duplicate field names result in a semantic error.

2.  **Field Type Resolution & C89 Check:** For each field, the `TypeChecker` resolves the field's type and verifies it using `is_c89_compatible()`. Non-C89 compatible types (like slices or multi-level pointers) are rejected.

3.  **Layout Calculation:** The `TypeChecker` calculates the memory layout of the struct according to C89 rules:
    -   Fields are placed in the order they are declared.
    -   Each field's offset is aligned based on its type's alignment requirements.
    -   The total size of the struct is aligned to the maximum alignment requirement of its fields, adding trailing padding if necessary.

4.  **Type Aliasing:** Support for `const S = struct { ... };` is implemented through type inference in variable declarations and symbol table lookups in type names.

### Member Access and Struct Initialization

1.  **Member Access (`s.field`):** The `TypeChecker` validates that the base expression is a struct or a single-level pointer to a struct. It then verifies that the field exists within the struct's definition and resolves to the field's type.

2.  **Struct Initialization (`S { .x = 1, .y = 2 }`):** The `TypeChecker` ensures that:
    -   The type being initialized is a struct.
    -   All fields defined in the struct are initialized exactly once.
    -   No extra fields are provided in the initializer.
    -   Each initializer expression's type is compatible with the corresponding field's type.

### Union Field Validation

For union declarations (`ASTUnionDeclNode`), the `TypeChecker` currently performs basic field name uniqueness validation. Full union type creation and layout are deferred to future milestones.

### Known Limitations (Milestone 4)

- **Recursive Structs:** The bootstrap compiler does not currently support recursive structs (e.g., `const Node = struct { next: *Node };`). This is because the type identifier is only registered in the symbol table after the struct declaration has been fully processed.
- **No Function Pointers**: Functions cannot be stored in variables or passed as arguments. Call sites are strictly resolved to direct function names at compile time.
- **Max 4 Parameters**: Function declarations and calls are limited to 4 parameters/arguments to ensure stability in legacy calling conventions.
- **No Tagged Unions**: Only bare unions are supported. Zig's `union(Enum)` syntax is not supported by the parser.
- **No Methods**: All functions must be top-level or at least not inside struct/union definitions.
- **Single-level Pointers**: Multi-level pointers like `**T` are rejected to simplify memory safety analysis.
- **Braces Required**: All control flow blocks (`if`, `while`, `for`) must use curly braces `{}`.

### Enum Type Declarations

When visiting an enum declaration (`ASTEnumDeclNode`), the `TypeChecker` creates a new `TYPE_ENUM` and enforces several C89-centric validation rules:

1.  **Backing Type Resolution:** It resolves the enum's backing type. If no explicit backing type is provided (e.g., `enum { A, B }`), it defaults to `i32` to ensure compatibility with standard C enums.

2.  **Integer Backing Type:** The backing type must be a C89-compatible integer. Any other type (e.g., `f32`, a pointer, or a struct) will result in a fatal error.

3.  **Constant Initializers:** Any explicit value assigned to an enum member (e.g., `A = 10`, `B = -1`) must be a constant integer literal. The `TypeChecker` correctly handles both positive and negative integer literals by accounting for the `NODE_UNARY_OP` (with `TOKEN_MINUS`) that represents a negative number in the AST. The use of variables or complex expressions as initializers is a fatal error.

4.  **Auto-increment Logic:** The `TypeChecker` correctly implements Zig-style auto-incrementing. If a member has no explicit initializer, its value is automatically assigned as `previous_member_value + 1`. The first member defaults to `0`. This logic correctly follows from both explicit and other auto-incremented values.

5.  **Value Range Validation:** The final value of every enum member (whether explicit or auto-incremented) is rigorously checked to ensure it fits within the valid range of the enum's backing type. For example, a value of `256` in an `enum(u8)` will trigger a fatal overflow error.

This set of rules ensures that every enum processed by the bootstrap compiler is a distinct type that can be safely and correctly represented as a C89 `enum`.

### Function Declarations and Signatures

When visiting a function declaration (`ASTFnDeclNode`), the `TypeChecker` performs a comprehensive validation of the entire function signature:

1.  **Parameter Type Resolution:** It iterates through each parameter in the function's declaration. For each parameter, it visits the corresponding type node (e.g., `ASTTypeNameNode`, `ASTPointerTypeNode`).
    -   If a parameter's type name cannot be resolved to a known type (e.g., `fn my_func(a: NotARealType)`), it reports an `ERR_UNDECLARED_TYPE` error.
    -   This validation prevents further errors that would arise from using an invalid type within the function body.

2.  **Return Type Resolution:** It resolves the function's return type by visiting its type node. If the return type is invalid, it also reports an `ERR_UNDECLARED_TYPE` error.

3.  **Function Type Creation:** If all parameter and return types are valid, it constructs a new `Type` object with the kind `TYPE_FUNCTION`. This `Type` object stores a `DynamicArray` of the parameter types and a pointer to the return type.

4.  **Symbol Update:** The `TypeChecker` then updates the function's `Symbol` in the `SymbolTable` to point to this newly created function type. This makes the full signature available for future use, such as in type-checking function calls.

5.  **Return Statement Validation:** After processing the signature, it proceeds to visit the function's body. When it encounters a `return` statement, it compares the type of the returned expression against the `current_fn_return_type` it recorded while visiting the signature, ensuring that the return value is compatible with the function's declared return type.

### Function Calls

-   The analyzer will verify that the number of arguments in a function call matches the number of parameters in the function's declaration.
-   It will check that the type of each argument is compatible with the type of the corresponding parameter.

#### C89 Compatibility Restrictions

To ensure that the output of the bootstrap compiler is compatible with C89, several restrictions are enforced during semantic analysis. These limitations are designed to prevent the use of modern language features that do not have a direct and simple equivalent in C89.

Function calls are subject to the following strict limitations:

1.  **Maximum Number of Arguments:** A function call cannot have more than four arguments. This is a conservative limit to ensure compatibility with various C89-era calling conventions and stack limitations. Any call with five or more arguments will trigger a fatal compilation error.

2.  **No Function Pointers:** The bootstrap compiler does not support calling functions via pointers. Any attempt to call a variable that holds a function (i.e., a function pointer) will be rejected with a fatal error.

    *Note on testing:* The current parser does not support type inference for variable declarations (e.g., `var func_ptr = my_func;`). As a result, tests for this specific feature currently fail during the parsing phase, preventing the `TypeChecker` from running. The check remains in the `TypeChecker` for correctness and future-proofing.

3.  **No Variadic Functions:** The parser does not support the syntax for declaring or calling variadic functions (e.g., `printf`-style functions with `...`).

### Operators

-   **Arithmetic Operators:** The analyzer will ensure that arithmetic operators (`+`, `-`, `*`, `/`) are only used with numeric types (integers and floats). The unary negation operator (`-`) is also restricted to numeric types; applying it to any other type is a fatal C89 compatibility error.
-   **Logical Operators:** Logical operators (`and`, `or`, `!`) must be used with boolean types. However, to align with C-style contexts, the unary logical NOT (`!`) can be applied to booleans, integers, and pointers, and its result is always `bool`. Applying `!` to any other type is a fatal error.
-   **Bitwise NOT (`~`):** The bitwise NOT operator can only be applied to integer types. Applying it to any other type (e.g., a float or a boolean) is a fatal C89 compatibility error.
-   **Pointer Operations:**
    -   **Address-of (`&`):** This operator can only be applied to l-values. An l-value is a memory location that can be assigned to. In the bootstrap compiler, the following are considered l-values:
        -   Variables (e.g., `&my_var`).
        -   Array accesses (e.g., `&my_array[i]`).
        -   Pointer dereferences (e.g., `&*my_ptr`).
        Applying `&` to an r-value (e.g., a literal `&42`, or the result of an arithmetic operation `&(a + b)`) will result in an `ERR_LVALUE_EXPECTED`. The resulting type of `&x` where `x` has type `T` is `*T`.
    -   **Dereference (`*`):** This operator can only be applied to an expression of a pointer type. Applying `*` to a non-pointer type will result in an `ERR_TYPE_MISMATCH`. The resulting type of `*p` where `p` has type `*T` or `*const T` is `T`.
        -   *Note on `const`*: While the type system correctly resolves the type of a dereferenced `*const T` to `T`, the enforcement of immutability (i.e., preventing assignments like `*p = 10`) is handled during the semantic analysis of assignment expressions (Task 107), not by the dereference operator itself.
    -   **Pointer Arithmetic (Task 184):** To ensure C89 compatibility and Zig-flavored safety, the type checker enforces the following rules for pointer arithmetic:
        -   **Supported Operations:**
            -   `ptr + unsigned_int` -> `ptr`: Offsetting a pointer forward.
            -   `unsigned_int + ptr` -> `ptr`: Commutative addition.
            -   `ptr - unsigned_int` -> `ptr`: Offsetting a pointer backward.
            -   `ptr1 - ptr2` -> `isize`: Calculating the distance between two pointers of compatible types.
        -   **Safety Rules:**
            -   **No Void Pointers:** Arithmetic on `*void` or `*const void` is strictly forbidden.
            -   **Complete Types Only:** The base type of the pointer must be a "complete" type (not `void`, and single-level pointers only). Multi-level pointers (`**T`) are rejected for arithmetic to avoid complexity in the bootstrap phase.
            -   **Unsigned Offsets Only:** Offsets used in `+` or `-` must be of an unsigned integer type (e.g., `u8`, `u32`, `usize`). This matches Zig's requirement for explicit casting and prevents common signed-overflow bugs in C.
            -   **Compatible Pointer Subtraction:** Subtraction is allowed if both pointers point to the same base type, ignoring `const` qualification (e.g., `*i32` - `*const i32` is valid, matching C89 standard behavior).
        -   **Rejected Operations:** Any other operations (e.g., `ptr + ptr`, `ptr * int`, `ptr / int`) are considered type errors and rejected.

### Control Flow Statements

-   **`if` and `while` Statements:** The condition of an `if` or `while` statement is expected to be a type that can be evaluated in a boolean context. To align with C89-style behavior, the `TypeChecker` accepts conditions of the following types:
    -   `bool`
    -   Any integer type (`i8` through `u64`, `isize`, `usize`)
    -   Any pointer type (`*T`)
    If the condition is of any other type (e.g., `void`, `f32`, a struct), a non-fatal `ERR_TYPE_MISMATCH` error is reported.

#### If Statement Rules (Task 175)

To ensure generated code is compatible with C89 and to maintain parser simplicity:
1.  **Braced Blocks Only**: Both `then` and `else` branches MUST be enclosed in braces `{ ... }`, with the exception of `else if` chains.
2.  **Else-If Support**: The parser supports `else if (cond) { ... }` which is internally represented as an `if` statement in the `else` branch.
3.  **Condition Types**: Strictly enforced to be `bool`, `int`, or `pointer`. Floating-point types are rejected as conditions to avoid ambiguity with zero comparisons in legacy environments.

### Function Calls

When visiting a function call (`ASTFunctionCallNode`), the `TypeChecker` performs a series of critical validations to ensure the call is well-formed and adheres to the bootstrap compiler's constraints.

1.  **Callee Type Verification:** The checker first resolves the type of the expression being called. It ensures that the callee is a symbol of kind `FUNCTION` and has a `TYPE_FUNCTION` type. This check is crucial as it prevents attempts to call variables or other non-function entities, which is how calls to function pointers are rejected.

2.  **Argument Count Check:** It verifies that the number of arguments provided in the call exactly matches the number of parameters specified in the function's signature. If the counts mismatch, it reports a fatal error with a message like "wrong number of arguments to function call, expected 2, got 1".

3.  **Argument Type Compatibility:** It iterates through each argument and compares its type to the corresponding parameter's type using the `areTypesCompatible` function. This allows for safe, implicit widening conversions (e.g., passing an `i16` to an `i32` parameter) but rejects incompatible types. A mismatch results in a fatal error detailing the expected and actual types.

4.  **C89 Argument Limit:** To maintain compatibility with legacy C89 compilers and calling conventions, the type checker enforces a hard limit of a maximum of 4 arguments per function call. Any call with five or more arguments will result in a fatal error.

5.  **Call Site Resolution (Task 165):** The `TypeChecker` resolves the call to a specific function or generic instantiation and records it in the `CallSiteLookupTable` with its mangled name.

6.  **Built-in Support (Task 186):** While most Zig built-ins are rejected in the bootstrap phase, a core set of intrinsics is supported to enable low-level operations and metadata access:
    -   **`@sizeOf(T)`**: Returns a `usize` constant representing the size of type `T` in bytes.
    -   **`@alignOf(T)`**: Returns a `usize` constant representing the alignment of type `T` in bytes.
    -   **`@ptrCast(T, val)`**: Reinterprets the pointer `val` as a pointer of type `T`. Mapped to a C-style cast. Both `T` and the type of `val` must be pointer types.
    -   **`@intCast(T, val)`**: Converts an integer `val` to type `T`. Mapped to a C-style cast.
    -   **`@floatCast(T, val)`**: Converts a float `val` to type `T`. Mapped to a C-style cast.
    -   **`@offsetOf(T, "field")`**: Returns a `usize` constant representing the byte offset of `field` within struct or union `T`. Evaluated at compile-time and replaced with a literal. (Note: Error on incomplete types is implemented but untestable in Milestone 4).
    -   **`@import("module")`**: Still strictly REJECTED as the bootstrap compiler is single-file only.

#### Call Resolution Completeness (Task 168)

The bootstrap compiler includes a `CallResolutionValidator` (active in DEBUG builds) that verifies the following after Pass 0 (Type Checking):
- Every function call in the AST has a corresponding entry in either the `CallSiteLookupTable` (resolved) or the `IndirectCallCatalogue` (rejected).
- Direct and recursive calls to known functions are successfully resolved to their mangled names.
- All non-C89 call patterns (indirect, too many arguments, built-ins) are correctly identified and flagged for rejection by the `C89FeatureValidator`.

### Expression Type Checking

When visiting expressions, the `TypeChecker` determines the resulting type of the expression.

-   **Identifiers:** The type of an identifier is determined by looking up its symbol in the `SymbolTable`. If the symbol is not found, an `ERR_UNDEFINED_VARIABLE` error is reported.

-   **Binary Operations:**
    -   **Arithmetic (`+`, `-`, `*`, `/`, `%`):** Both operands must be of the same numeric type. The resulting type is the same as the operand types. Operations between different numeric types (e.g., `i32` and `f64`) are not allowed.
    -   **Comparisons (`==`, `!=`, `<`, `>`, `<=`, `>=`):** Both operands must be of the same numeric type. The resulting type is always `bool`.

#### Binary Operator Implementation Status

To clarify the current capabilities of the type checker and guide future development, the following table outlines the implementation status of all binary operators within the `visitBinaryOp` method.

| Operator | Category      | Implemented? | Notes                                                              |
|----------|---------------|--------------|--------------------------------------------------------------------|
| `+`      | Arithmetic    | **Yes**      | Supports numeric types and pointer/integer addition.               |
| `-`      | Arithmetic    | **Yes**      | Supports numeric types and pointer/integer/pointer subtraction.    |
| `*`      | Arithmetic    | **Yes**      | Supports numeric types only.                                       |
| `/`      | Arithmetic    | **Yes**      | Supports numeric types only.                                       |
| `%`      | Arithmetic    | **Yes**      | Supports numeric types only.                                       |
| `==`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `!=`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `<`      | Comparison    | **Yes**      | Supports numeric types.                                            |
| `<=`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `>`      | Comparison    | **Yes**      | Supports numeric types.                                            |
| `>=`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `&`      | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `|`      | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `^`      | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `<<`     | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `>>`     | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `and`    | Logical       | Yes          | Correctly parsed and handled.                                      |
| `or`     | Logical       | Yes          | Correctly parsed and handled.                                      |

-   **Pointer Operations:**
    -   **Address-of (`&`):** This operator can only be applied to l-values. An l-value is a memory location that can be assigned to. In the bootstrap compiler, the following are considered l-values:
        -   Variables (e.g., `&my_var`).
        -   Array accesses (e.g., `&my_array[i]`).
        -   Pointer dereferences (e.g., `&*my_ptr`).
        Applying `&` to an r-value (e.g., a literal `&42`, or the result of an arithmetic operation `&(a + b)`) will result in an `ERR_TYPE_MISMATCH`. The resulting type of `&x` where `x` has type `T` is `*T`.
    -   **Dereference (`*`):** This operator can only be applied to an expression of a pointer type. Applying `*` to a non-pointer type will result in an `ERR_TYPE_MISMATCH`. The resulting type of `*p` where `p` has type `*T` or `*const T` is `T`.
        -   *Note on `const`*: While the type system correctly resolves the type of a dereferenced `*const T` to `T`, the enforcement of immutability (i.e., preventing assignments like `*p = 10`) is handled during the semantic analysis of assignment expressions (Task 107), not by the dereference operator itself.
    -   **Pointer Arithmetic:** To ensure C89 compatibility, the type checker enforces the following rules for pointer arithmetic:
        -   `pointer + integer` -> `pointer`: The result is a pointer of the same type.
        -   `integer + pointer` -> `pointer`: The result is a pointer of the same type.
        -   `pointer - integer` -> `pointer`: The result is a pointer of the same type.
        -   `pointer - pointer` -> `isize`: The result is a signed integer of type `isize`. This is only valid if both pointers are of the exact same type (e.g., `*i32` and `*i32`, but not `*i32` and `*const i32`).
        -   Any other arithmetic operations involving pointers (e.g., `pointer + pointer`, `pointer * integer`) are considered a type error.

-   **Literals:**
    -   **`true`, `false`:** Inferred as type `bool`.
    -   **Integer Literals:** The type is determined by the literal's value and suffix. Small values default to `i32` or `u32` for C compatibility, while larger values or those with `l`/`LL` suffixes are inferred as `i64`/`u64`.
        -   **Unsigned Literals (e.g., `123u`):**
            -   `0` to `4294967295`: `u32`
            -   Larger values or with `ul` suffix: `u64`
        -   **Signed Literals (e.g., `123`, `-45`):**
            -   `-2147483648` to `2147483647`: `i32`
            -   Larger values or with `l` suffix: `i64`
    -   **Floating-Point Literals:** All floating-point literals (e.g., `3.14`) are inferred as type `f64`.
    -   **Character Literals:** A character literal (e.g., `'a'`) is inferred as type `u8`.
    -   **String Literals:** A string literal (e.g., `"hello"`) is inferred as type `*const u8` (a pointer to constant `u8` characters).
    -   **Memory Overhead:** The validation of literal types is a stateless process within the `TypeChecker`. It is based on the value and syntax of the literal itself and does not require the creation of any new, persistent data structures or heap allocations, thus adhering to the project's strict memory constraints.

### Literal Type Mapping Table (Task 170)

The following table defines the expected C89 representation for Zig literals, as verified by integration tests using the `MockC89Emitter`.

| Zig Literal | Bootstrap Type | C89 Representation | Notes |
|-------------|----------------|--------------------|-------|
| `42`        | `i32`          | `42`               | Default integer |
| `0x1F`      | `i32`          | `31`               | Hex mapped to decimal |
| `123u`      | `u32`          | `123U`             | Unsigned suffix |
| `123l`      | `i64`          | `123LL`            | Long suffix maps to LL |
| `123ul`     | `u64`          | `123ULL`           | Unsigned long suffix |
| `3.14`      | `f64`          | `3.14`             | Default float |
| `2.0e1`     | `f64`          | `20.0`             | Scientific notation |
| `'A'`       | `u8`           | `'A'`              | ASCII only |
| `'\\n'`     | `u8`           | `'\\n'`            | Escape sequence |
| `"hello"`   | `*const u8`    | `"hello"`          | Null-terminated string |
| `true`      | `bool`         | `1`                | Bool as int |
| `null`      | `null`         | `((void*)0)`       | Null literal |

### Control Flow Statements

-   **`if` and `while` Statements:** The condition of an `if` or `while` statement is expected to be a type that can be evaluated in a boolean context. To align with C89-style behavior, the `TypeChecker` accepts conditions of the following types:
    -   `bool`
    -   Any integer type (`i8` through `u64`, `isize`, `usize`)
    -   Any pointer type (`*T`)
    If the condition is of any other type (e.g., `void`, `f32`, a struct), a non-fatal `ERR_TYPE_MISMATCH` error is reported.

### Lifetime Analysis (Dangling Pointers) - Task 125

Following the Type Checking phase, the compiler performs a **Lifetime Analysis** pass to detect potential dangling pointers. This is a read-only analysis that leverages the semantic information and flags populated by the `TypeChecker`.

#### Tracking Variable Provenance
The analysis relies on the `SYMBOL_FLAG_LOCAL`, `SYMBOL_FLAG_PARAM`, and `SYMBOL_FLAG_GLOBAL` flags in the `SymbolTable`.
-   **`SYMBOL_FLAG_LOCAL`**: Applied by `TypeChecker` to variables declared within a function body.
-   **`SYMBOL_FLAG_PARAM`**: Applied by `TypeChecker` to function parameters.
-   **`SYMBOL_FLAG_GLOBAL`**: Applied by `TypeChecker` to top-level declarations.

The `LifetimeAnalyzer` tracks assignments where a pointer variable is assigned the address of a local variable or parameter (e.g., `p = &x;`). It uses a function-local `DynamicArray` to store these mappings during the pass.

#### Violation Rules
A dangling pointer error (`ERR_LIFETIME_VIOLATION`) is reported in the following scenarios:
1.  **Returning Local Address**: `return &x;` where `x` is marked as `SYMBOL_FLAG_LOCAL` (including parameters).
2.  **Returning Local Pointer**: `return p;` if `p` is a local variable that was previously assigned the address of a local variable or parameter.
3.  **Returning Uninitialized Local Pointer**: `return p;` where `p` is a local pointer variable with no recorded safe assignment (conservative safety).

#### Global and Parameter Safety
-   Returning the address of a **Global Variable** is always safe, as globals have static lifetime (marked with `SYMBOL_FLAG_GLOBAL`).
-   Returning a **Parameter Value** directly (e.g., `fn f(p: *i32) -> *i32 { return p; }`) is safe, as the caller is responsible for the lifetime of the object pointed to by `p`.

### Double Free Detection (Task 127)

Following the Type Checking and Lifetime Analysis phases, the compiler performs a **Double Free Detection** pass. This pass is designed to identify potential memory safety issues related to the use of the project's `ArenaAllocator` interface, specifically the `arena_alloc` and `arena_free` functions.

#### 1. Tracking State
The `DoubleFreeAnalyzer` tracks the state of pointers within each function. A pointer is tracked if it is:
-   Initialized with the result of a call to `arena_alloc`.
-   Assigned the result of a call to `arena_alloc`.

The analyzer maintains a function-local list of `TrackedPointer` structures, each storing the variable's name and its current state (`allocated` and `freed` flags).

#### 2. Double Free Detection
When a call to `arena_free(p)` is encountered:
-   The analyzer looks up the variable `p` in its list of tracked pointers.
-   If the pointer is found and its state is `AS_FREED`, an `ERR_DOUBLE_FREE` (2005) is reported.
-   The error message follows the format: `"Double free of pointer '%s'"` (where `%s` is the name of the variable).
-   If the pointer's state is `AS_ALLOCATED`, it is updated to `AS_FREED`.
-   If the pointer's state is `AS_UNINITIALIZED`, an `WARN_FREE_UNALLOCATED` (6006) is reported.

#### 3. State Isolation
To ensure accuracy and prevent false positives, the list of tracked pointers is cleared at the beginning of every function declaration. This ensures that the analysis of one function does not interfere with another.

#### 4. Advanced Scenarios
The `DoubleFreeAnalyzer` correctly handles more complex scenarios:
- **Nested Scopes:** Correctly tracks pointers into and out of nested blocks using a `current_scope_depth_` counter.
- **Leak Detection at Scope Exit:** Detects and warns about `AS_ALLOCATED` pointers that are not freed before their defining scope ends.
- **Immediate Reassignment Leaks:** Detects leaks when an `AS_ALLOCATED` pointer is reassigned to another value (including `null` or a new allocation) before the original memory is freed.
    ```zig
    var p = arena_alloc(100u);
    p = null; // Warning: Memory leak: reassigning allocated pointer 'p'
    ```
- **Return Exemption:** Pointers that are returned from a function are exempt from leak detection within that function.
- **Expression Wrapping:** The analyzer can look through `try`, `catch`, `orelse`, and binary operations to find `arena_alloc` calls.
    ```zig
    var p: *u8 = try arena_alloc(10u); // Correctly tracked as AS_ALLOCATED
    ```
- **Defer & Errdefer:** These are modeled using a LIFO queue. Actions are queued when discovered and executed in reverse order at block exits or `return` statements.
    ```zig
    {
        var p = arena_alloc(10u);
        defer arena_free(p);
    } // state of p is updated to AS_FREED here, no leak warning.
    ```

#### 5. Integration with other passes
The analyzer runs as Pass 4 in the semantic pipeline, following Type Checking, Lifetime Analysis, and Null Pointer Analysis. This ensures it has access to accurate symbol information.

### `void` Type Validation

To ensure C89 compatibility, the `TypeChecker` enforces several strict rules regarding the use of the `void` type:

-   **Variable Declarations:** Variables cannot be declared with the type `void`. An attempt to do so (e.g., `var x: void;`) will result in an `ERR_VARIABLE_CANNOT_BE_VOID` error.

-   **Function Returns:**
    -   A function declared with a `void` return type can have an empty `return;` statement or no `return` statement at all (an implicit return).
    -   Attempting to return a value from a `void` function (e.g., `return 123;`) will result in an `ERR_INVALID_RETURN_VALUE_IN_VOID_FUNCTION` error.
    -   A non-`void` function must have a `return` statement with a value of a compatible type. A `return;` statement without a value, or an implicit return by falling off the end of the function, will result in an `ERR_MISSING_RETURN_VALUE` error.

-   **Pointer Arithmetic:** Pointer arithmetic is not permitted on pointers of type `*void`. Attempting to perform addition or subtraction on a `void*` will result in an `ERR_INVALID_VOID_POINTER_ARITHMETIC` error.

## 5. C89 Compatibility Enforcement

To ensure the bootstrap compiler produces valid C89 code, a multi-layered approach is used to reject non-C89 features.

### AST Pre-Scan for Incompatible Syntax

The first layer of enforcement is the **AST Pre-Scan**. Immediately after parsing is complete, a dedicated visitor class, the `C89FeatureValidator`, traverses the AST. It looks for syntactic constructs that are fundamentally incompatible with C89, such as slices (`[]u8`) and error-handling expressions (`try`, `catch`, `orelse`).

If any of these features are found, the validator immediately aborts compilation with a fatal error. This "fail-fast" approach is detailed in the `C89_rejection_framework.md` document.

### Type System Validation

The second layer of enforcement occurs within the `TypeChecker` and the type system itself. This is handled by a formal system for mapping and validating types, which is defined in the `src/include/c89_type_mapping.hpp` header.

### C89 Primitive Type Mapping Table

A static mapping table, `c89_type_map`, defines the direct correspondence between the RetroZig compiler's primitive `TypeKind`s and their C89 string equivalents. This table is the single source of truth for C89 type compatibility.

| RetroZig TypeKind | C89 Equivalent         | Notes                          |
|-------------------|------------------------|--------------------------------|
| `TYPE_VOID`       | `"void"`               | Size: 0, Align: 0              |
| `TYPE_BOOL`       | `"int"`                | Size: 4, Align: 4. C89 has no native `_Bool`. |
| `TYPE_I8`         | `"signed char"`        | Size: 1, Align: 1              |
| `TYPE_I16`        | `"short"`              | Size: 2, Align: 2              |
| `TYPE_I32`        | `"int"`                | Size: 4, Align: 4              |
| `TYPE_I64`        | `"__int64"`            | Size: 8, Align: 8. For MSVC 6.0 compatibility. |
| `TYPE_U8`         | `"unsigned char"`      | Size: 1, Align: 1              |
| `TYPE_U16`        | `"unsigned short"`     | Size: 2, Align: 2              |
| `TYPE_U32`        | `"unsigned int"`       | Size: 4, Align: 4              |
| `TYPE_U64`        | `"unsigned __int64"`   | Size: 8, Align: 8. For MSVC 6.0 compatibility. |
| `TYPE_F32`        | `"float"`              | Size: 4, Align: 4              |
| `TYPE_F64`        | `"double"`             | Size: 8, Align: 8              |
| `TYPE_ISIZE`      | `"int"`                | Size: 4, Align: 4              |
| `TYPE_USIZE`      | `"unsigned int"`       | Size: 4, Align: 4              |
| `TYPE_ENUM`       | `"typedef T"`          | Dependent on backing type.      |
| `TYPE_ERROR_UNION` | No equivalent         | Internal; rejected by validator |
| `TYPE_ERROR_SET`   | No equivalent         | Internal; rejected by validator |

### Bootstrap Type Compatibility Matrix

The following table defines the allowed and rejected types in the bootstrap compiler, along with their C89 equivalents and bootstrap-specific notes.

| Zig Type | Bootstrap Allowed? | C89 Equivalent | Notes |
|---|---|---|---|
| `i8`-`i32` | ✓ | `signed char`-`int` | Direct mapping. |
| `i64` | ✓ | `__int64` | MSVC 6.0 specific hack for 64-bit integers. |
| `u8`-`u32` | ✓ | `unsigned char`-`unsigned int` | Direct mapping. |
| `u64` | ✓ | `unsigned __int64` | MSVC 6.0 specific hack. |
| `isize`/`usize` | ✓ | `int`/`unsigned int` | Supported for pointer arithmetic and sizes. Mapping to 32-bit `int` in Milestone 4. |
| `f32`/`f64` | ✓ | `float`/`double` | Direct mapping. |
| `bool` | ✓ | `int` (0/1) | C89 has no native `_Bool`. |
| `void` | ✓ | `void` | Used for function returns and `*void`. |
| `*T` | Conditional | `T*` | Allowed only if `T` is an allowed primitive or struct/enum. |
| `**T` | ✗ | - | **Rejected.** Multi-level pointers are not supported in bootstrap. |
| `[]T` | ✗ | - | **Rejected.** Slices require runtime support not available in bootstrap. |
| `!T` | ✗ | - | **Rejected.** Error unions are rejected until Milestone 5 translation. |
| `?T` | ✗ | - | **Rejected.** Optionals are rejected until Milestone 5 translation. |
| `[N]T` | ✓ | `T[N]` | Sized arrays are supported. |
| `struct` | ✓ | `struct` | Supported with C89-compliant layout. |
| `enum` | ✓ | `enum` | Supported, mapping to the backing integer type. |
| `fn` | ✗ | - | Function pointers are rejected as values or variables. |
| `string_literal` | ✓ | `const char*` | Maps to `*const u8` (pointer to constant `u8`). |

### Supported Type Syntax Examples

```zig
// Primitives
var a: i32 = 42;
const b: f64 = 3.14;
var c: bool = true;

// Pointers
var x: i32 = 10;
var p: *i32 = &x;
var val: i32 = p.*;

// Arrays
fn processArray(arr: [5]i32) void {
    var first: i32 = arr[0];
}

// Structs
const Point = struct {
    x: i32,
    y: i32,
};
var pt = Point { .x = 1, .y = 2 };

// Enums
const Color = enum {
    Red,
    Green,
    Blue,
};
var col = Color.Red;
```

### The `is_c89_compatible` Function

A static inline function, `is_c89_compatible(Type* type)`, provides the mechanism for enforcing the C89 type subset. Its behavior is as follows:

-   **Returns `true`** for any primitive type whose `TypeKind` is present in the `c89_type_map` table.
-   **Returns `true`** for a single-level pointer (e.g., `*i32`) whose base type is a C89-compatible primitive.
-   **Returns `true`** for a struct, enum, or union type that has been associated with a name via a `const` declaration.
-   **Returns `true`** for an array type (e.g., `[8]u8`, `[4][4]f32`) if its final base element type is a C89-compatible primitive.
-   **Returns `true`** for a function type, but only if it meets the following strict criteria:
    -   The function must not have more than 4 parameters.
    -   The return type must be C89-compatible.
    -   All parameter types must be C89-compatible.
    -   Neither the return type nor any parameter type can be a function type itself (i.e., no function pointers).
-   **Returns `false`** for `NULL` types.
-   **Returns `false`** for any type not in the mapping table (e.g., `anyerror`).
-   **Returns `false`** for multi-level pointers (e.g., `**i32`, `*const *u8`).
-   **Returns `false`** for anonymous composite types (structs/unions/enums not assigned to a `const`).

This function is a cornerstone of the semantic analysis phase, allowing the `TypeChecker` and `C89FeatureValidator` to reject unsupported Zig features early in the compilation process.

## Rejected Zig Features (Milestone 4)

### Error Handling Types
| Zig Feature | C89 Equivalent | Status | Rejection Point |
|-------------|----------------|--------|-----------------|
| `!T` (error union) | No equivalent | REJECTED | `C89FeatureValidator` |
| `?T` (optional) | No equivalent | REJECTED | `C89FeatureValidator` |
| `error { ... }` | No equivalent | REJECTED | `C89FeatureValidator` |
| `fn() !T` (error return) | No equivalent | REJECTED | `C89FeatureValidator` |
| `try expr` | No equivalent | REJECTED | `C89FeatureValidator` |
| `catch expr` | No equivalent | REJECTED | `C89FeatureValidator` |
| `orelse expr` | No equivalent | REJECTED | `C89FeatureValidator` |
| `errdefer` | No equivalent | REJECTED | `C89FeatureValidator` |
| `comptime` (params) | No equivalent | REJECTED | `C89FeatureValidator` |
| `anytype` | No equivalent | REJECTED | `C89FeatureValidator` |
| `type` (as type) | No equivalent | REJECTED | `C89FeatureValidator` |
| `[]T` (slice) | No equivalent | REJECTED | `C89FeatureValidator` |
| `**T` (multi-ptr) | No equivalent | REJECTED | `C89FeatureValidator` / `TypeChecker` |
| `anyerror` | No equivalent | REJECTED | `C89FeatureValidator` |
| `@import` | No equivalent | REJECTED | `C89FeatureValidator` |

These features are initially resolved by the `TypeChecker` (Pass 0) to allow for accurate cataloguing and type-aware diagnostics (including usage context and nesting for `try`), and are then strictly rejected by the `C89FeatureValidator` (Pass 1).

For detailed validation rules that will be enforced in Milestone 5 (when rejection is replaced by translation), see `error_handling_validation_rules.md`.

To support accurate semantic resolution before rejection, the `TypeChecker` implements Zig-like compatibility rules for error unions, allowing implicit wrapping of a payload `T` into `!T` and implicit (but unsafe) unwrapping of `!T` to `T` during Pass 0.

### Error Type Elimination (Task 150)

Zig error types (`!T`, `error{A,B}`) are not compatible with C89. The bootstrap compiler eliminates them through a deliberate rejection process in the semantic pipeline.

#### Process
1.  **Parse**: Error types are recognized and parsed into internal AST nodes and `Type` objects (`TYPE_ERROR_UNION`, `TYPE_ERROR_SET`).
2.  **Type Check (Pass 0)**: Error types are resolved and their semantics (like implicit wrapping) are validated to enable accurate analysis.
3.  **Catalogue**: Metadata about error handling features is recorded in specialized catalogues (e.g., `ErrorFunctionCatalogue`) for documentation and future mapping.
4.  **Reject (Pass 1)**: The `C89FeatureValidator` traverses the AST and issues fatal errors for all modern error-related constructs.
5.  **Eliminate**: Because rejection occurs early, no error types proceed to the code generation phase. They are conceptually "eliminated" from the final C89 output.

#### Verification
The `CompilationUnit` provides an `areErrorTypesEliminated()` method which returns true if the validation pass has successfully completed and rejected all non-C89 error features. This ensures a clean hand-off to Milestone 5 translation.

## 6. Symbol Table and Memory Usage

The `SymbolTable` is a core component of the semantic analysis phase. It is owned by the `CompilationUnit` and provides hierarchical scope management for all identifiers.

## 9. Type Checker

The `TypeChecker` is a new component responsible for traversing the AST and verifying that the program adheres to the language's type rules. It is the primary consumer of the `Type` and `Symbol` information described in the previous sections.

### Traversal Strategy

The `TypeChecker` uses the visitor pattern to traverse the AST. It has a `visit` method for each `NodeType`, which allows for modular and extensible type-checking logic. The traversal is a recursive process that walks the tree, checking each node and its children.

### Integration in the Pipeline

The `TypeChecker` is integrated into the main compilation pipeline as a distinct stage that runs immediately after the parser. The process is as follows:
1. The `Parser` generates the full `AST`.
2. The `TypeChecker` is initialized with the `CompilationUnit`.
3. The `check` method of the `TypeChecker` is called with the root of the `AST`.
4. The `TypeChecker` traverses the tree, and if it finds any type errors, it reports them using the `ErrorHandler` in the `CompilationUnit`.

### Error Handling

The `TypeChecker` uses the existing `ErrorHandler` to report type-related errors. This ensures that type errors are reported in the same format as parsing errors, providing a consistent user experience.

### Memory Impact of the Refactored Symbol Table

The foundational refactoring of the `SymbolTable` introduced a more robust, scope-aware architecture. A key consequence of this change is an increase in the baseline memory usage for each `CompilationUnit`.

**Cause of Increased Memory Usage:**
The `SymbolTable` constructor now immediately performs allocations to set up its foundational data structures:
1.  It allocates a `DynamicArray` to hold the stack of `Scope` pointers.
2.  Upon construction, it immediately calls `enterScope()` to create the global scope. This involves allocating a `Scope` object and the `DynamicArray` for symbols within that scope.

This upfront memory cost was not present in the previous, simpler implementation.

**Impact on Performance and Unit Tests:**
This increased baseline memory usage, combined with the new symbol allocations during parsing, caused several unit tests with small, hardcoded `ArenaAllocator` sizes (e.g., 1024 or 2048 bytes) to fail with "Out of memory" errors. These tests were not provisioned for the additional memory overhead of a fully active symbol table.

The solution was to perform a comprehensive update of the test suite, increasing the arena sizes in all parser-related tests from 4096 to 8192 bytes. This proactive measure ensures that the test environment is stable and has sufficient capacity for the new functionality, preventing spurious memory-related failures.

**Performance Concerns:**
The increase in baseline memory usage is not considered a significant performance concern for the following reasons:
- **Necessary Trade-off:** The memory is used to provide essential scoping functionality, which is a core requirement for the compiler.
- **Fixed Cost:** The initial allocation is a small, fixed cost per compilation unit. It does not grow with the size of the source file being compiled.
- **Efficient Allocation:** All allocations are still managed by the `ArenaAllocator`, which is extremely fast. The performance impact of the initial allocations is negligible in the context of a full compilation.

In summary, while the new `SymbolTable` has a slightly larger memory footprint, it is a deliberate and necessary architectural improvement. The impact is well-contained and does not compromise the overall performance goals of the compiler.

## 6. Type Resolution

To bridge the gap between the parser, which sees types as identifiers (e.g., `"i32"`), and the semantic analysis phase, which requires structured `Type` objects, a simple type resolution system has been implemented.

### Compile-Time Built-ins (Task 186)

The bootstrap compiler supports several built-in functions (starting with `@`) that are evaluated at compile time. These functions are replaced in the AST with constant values during the Type Checking phase.

#### `@sizeOf(T)`
Returns a `usize` constant representing the size of type `T` in bytes.
- **Target Assumption:** 32-bit (e.g., `@sizeOf(*i32)` is `4`).
- **Supported Types:** All complete types (primitives, pointers, arrays, structs, unions, enums).
- **In-place Replacement:** The `NODE_FUNCTION_CALL` is replaced with a `NODE_INTEGER_LITERAL`.

#### `@alignOf(T)`
Returns a `usize` constant representing the alignment of type `T` in bytes.
- **Target Assumption:** 32-bit (e.g., `@alignOf(i64)` is `8`).
- **In-place Replacement:** The `NODE_FUNCTION_CALL` is replaced with a `NODE_INTEGER_LITERAL`.

#### Numeric Casts (Task 187)
- **`@intCast(T, expr)`**: Checked conversion between integer types.
- **`@floatCast(T, expr)`**: Checked conversion between floating-point types.

**Evaluation Strategy:**
1. **Constant Folding:** If `expr` is a constant literal and fits in `T`, it is replaced with a literal node in-place.
2. **Compile-time Error:** If `expr` is a constant literal but exceeds the range of `T`, a fatal error is reported.
3. **Safe Widening:** If the conversion is a guaranteed safe widening (e.g., `u8` to `i32`), a simple C-style cast is emitted.
4. **Runtime Check:** Otherwise, a call to a runtime helper function `__bootstrap_<target>_from_<source>(expr)` is emitted. These helpers (to be implemented in Milestone 5) perform range checks and panic on overflow.

#### Target Platform Assumptions (32-bit)
To maintain simplicity, the bootstrap compiler assumes a 32-bit little-endian target platform with the following characteristics:

| Type | Size (bytes) | Alignment |
|------|--------------|-----------|
| `usize` / `isize` | 4 | 4 |
| Pointers (`*T`) | 4 | 4 |
| `i8` / `u8` | 1 | 1 |
| `i16` / `u16` | 2 | 2 |
| `i32` / `u32` | 4 | 4 |
| `i64` / `u64` | 8 | 8 |
| `f32` | 4 | 4 |
| `f64` | 8 | 8 |
| `bool` | 4 | 4 (C89 `int`) |

### `resolvePrimitiveTypeName`

A new function, `resolvePrimitiveTypeName(const char* name)`, has been introduced. Its responsibilities are:
-   It takes a string (an interned identifier name) as input.
-   It compares this string against a list of known primitive type names (e.g., "void", "bool", "i8", etc.).
-   If a match is found, it returns a pointer to a pre-defined, static, global `Type` object for that primitive.
-   If the name does not correspond to a known primitive type, it returns `NULL`.

This mechanism allows the parser to easily obtain a valid `Type*` for a symbol by looking up the type name found in the source code.

### `createPointerType`
A helper function, `createPointerType(ArenaAllocator& arena, Type* base_type, bool is_const)`, has been added to facilitate the creation of pointer types. It allocates a new `Type` object from the arena, sets its kind to `TYPE_POINTER`, and links it to the provided base type, respecting the `const` qualifier.

### `createFunctionType`
A new helper function, `createFunctionType(ArenaAllocator& arena, DynamicArray<Type*>* params, Type* return_type)`, has been added to create `TYPE_FUNCTION` objects. It allocates a new `Type` and populates it with the list of parameter types and the return type.

## 7. Parser Integration

To make the symbol table functional, it is integrated directly into the parsing process. This allows the parser to manage scopes and register symbols as it traverses the source code.

### Connection and Scope Management

-   **Constructor Injection:** The `CompilationUnit`, which owns the `SymbolTable`, passes a pointer to it into the `Parser`'s constructor.
-   **Scope Handling:** The parser is responsible for signaling the `SymbolTable` to create and destroy scopes.
    -   `parseFnDecl()` calls `enterScope()` before parsing the function body and `exitScope()` after, creating a dedicated scope for the function's contents.
    -   `parseBlockStatement()` does the same upon encountering `{` and `}` respectively, allowing for correct nested block scoping.

### Expression Statements
The parser now supports "expression statements", which are statements that consist of a single expression followed by a semicolon (e.g., `my_function();` or `"a string";`). This is handled by a new `NODE_EXPRESSION_STMT` in the AST.

### Symbol Registration During Parsing

-   **`parseVarDecl()`:** When a variable declaration is parsed, this method:
    1.  Extracts the type name identifier from the `ASTNode` for the type.
    2.  Calls `resolvePrimitiveTypeName` to get a `Type*` for the variable. If this fails, it's a fatal error.
    3.  Constructs a `Symbol` for the variable using the `SymbolBuilder`.
    4.  Calls `symbol_table_->insert()` to register the symbol in the current scope.

-   **`parseFnDecl()`:** When a function is parsed, this method:
    1.  Constructs a `Symbol` for the function itself.
    2.  Inserts this `Symbol` into the *current* scope (e.g., the global scope for a top-level function). This happens *before* a new scope is entered for the function's body.
    3.  During type checking, parameters are registered in the function's scope immediately as they are resolved. This allows later parameters in the same signature to refer to earlier ones (e.g., `fn f(comptime T: type, x: T)`).

### Error Handling

-   **Duplicate Symbols:** If `symbol_table_->insert()` returns `false`, it indicates that a symbol with the same name already exists in the current scope. The parser treats this as a fatal semantic error and immediately calls its `error()` method to abort compilation. This provides simple and effective duplicate detection for both variables and functions.

## 8. Memory Profile Analysis (Milestone 4)

A memory profiling analysis was conducted to investigate the test suite's memory consumption and verify the soundness of the arena allocation strategy, particularly after the integration of the Symbol Table and other memory-intensive parser features.

### Methodology

The analysis employed a two-pronged approach:

1.  **Internal Instrumentation:** A temporary test case was added to run a representative piece of source code through the compilation pipeline. Using the `ArenaAllocator`'s existing `getOffset()` method, the test measured and reported the amount of memory consumed by each major stage (Lexer vs. Parser/Symbol Table). This temporary test code was removed after the analysis was complete.
2.  **External Profiling:** The entire test suite was compiled with debug symbols and run under the Valgrind/Massif heap profiling tool. This provided an external, objective view of the `test_runner` executable's complete memory lifecycle, allowing for the detection of any potential leaks or unexpected allocation patterns.

### Findings

The results from both methods were consistent and conclusive:

-   **No Memory Leaks Detected:** The Massif report showed a healthy, cyclical memory usage pattern. The heap size peaked during test execution and returned to a stable baseline after each test, confirming that the `ArenaAllocator`'s memory is being correctly allocated and subsequently released. There was no evidence of unbounded memory growth across the test suite.
-   **Memory Growth is Feature-Driven:** The internal instrumentation revealed the following breakdown for the sample code:
    -   **Lexer (Tokens & Interned Strings):** ~1.7 KB
    -   **Parser (AST Nodes & Symbols):** ~1.7 KB
    -   **Total Arena Usage:** ~3.5 KB
    This demonstrates that the addition of complex components like the AST and Symbol Table are responsible for the increased memory usage. The need to increase arena sizes in tests is a direct and expected consequence of this added complexity, not a bug.
-   **Low Overall Footprint:** The external profile showed a peak heap usage of approximately 86 KB. The majority of this (~74 KB) was attributable to C++ standard library runtime overhead (e.g., for I/O buffers). The memory directly allocated by the compiler's `ArenaAllocator` was consistently in the 4 KB range, aligning with the sizes specified in the tests.

### Conclusion

The memory allocation strategy is sound. The compiler components have a minimal and controlled memory footprint, and the an arena-based approach is effectively preventing memory leaks. The observed increases in memory usage are a natural result of the project's evolution and do not indicate an underlying issue.

## 10. Error-Free Type Conversion (Task 151)

### Overview
Zig error types (`!T`) and optional types (`?T`) require conversion to C89-compatible types. This document outlines the conversion strategy for Milestone 5. In the bootstrap compiler (Milestone 4), these features are strictly **rejected**, but the type system preserves the necessary information to enable this future conversion.

### Error Union Conversion (!T → T)

#### Basic Conversion Pattern
```c
// Zig: var x: i32 = try maybeError();
// C89 Conversion:
ErrorableInt32 result = maybeError();
if (result.is_error) {
    // Handle error (return/propagate)
}
int32_t x = result.data.value;
```

#### Type Representation
```c
// Zig type: !i32
// C89 representation:
typedef struct {
    union {
        int32_t value;
        int error_code;
    } data;
    int is_error;  // 0 = success, 1 = error
} ErrorableInt32;
```

#### Conversion Rules
1.  **Direct access**: Only allowed after error check.
2.  **Type safety**: Cannot access payload without checking `is_error`.
3.  **Memory layout**: Must match Zig's ABI for compatibility.

### Optional Type Conversion (?T → T)

#### Basic Conversion Pattern
```c
// Zig: var x: i32 = maybeNull orelse 0;
// C89 Conversion:
OptionalInt32 opt = maybeNull;
int32_t x = opt.has_value ? opt.value : 0;
```

#### Type Representation
```c
// Zig type: ?i32
// C89 representation:
typedef struct {
    int32_t value;
    int has_value;  // 0 = null, 1 = present
} OptionalInt32;
```

### The .? Operator

#### Zig Semantics
The `.?` operator asserts that an error union or optional is non-error/non-null:
```zig
var x: i32 = errorUnion.?;  // Crashes if error
var y: i32 = optional.?;    // Crashes if null
```

#### C89 Equivalent
```c
// Zig: value = expr.?;
// C89:
ResultType result = expr;
if (result.is_error) {
    abort();  // Or call panic handler
}
value = result.data.value;
```

### Type Safety Considerations

#### Loss of Type Information
Error unions and optionals carry runtime safety information that is lost when converting to base types:

| Zig Type     | C89 Type | Information Lost        |
| ------------ | -------- | ----------------------- |
| `!i32`       | `i32`    | Error state, error code |
| `?i32`       | `i32`    | Null state              |
| `error{A,B}` | `int`    | Type safety             |

#### Safety Violation Prevention
To prevent safety violations in generated C89 code:
1.  **Runtime checks**: Insert `assert()` for `.?` operator.
2.  **Default values**: Use safe defaults for `orelse` conversions.
3.  **Error propagation**: Convert `try` to explicit error checking.

### MSVC 6.0 Constraints

#### Alignment Constraints
```c
// MSVC 6.0 maximum alignment is 4 bytes
#pragma pack(push, 4)
typedef struct {
    union {
        // Types with alignment > 4 must be handled specially
        double value;    // 8-byte alignment on some platforms
        int error_code;
    } data;
    int is_error;
} ErrorableDouble;
#pragma pack(pop)
```

#### Stack Usage
-   **Small conversions** (< 64 bytes): Use stack-allocated temporaries.
-   **Medium conversions** (64-256 bytes): Use arena allocation.
-   **Large conversions** (> 256 bytes): Use out-parameters.

### Implementation Checklist for Milestone 5
- [ ] Type conversion functions for each primitive type.
- [ ] Runtime safety checks for `.?` operator.
- [ ] Memory layout validation against Zig ABI.
- [ ] MSVC 6.0 alignment workarounds.
- [ ] Stack usage optimization.
- [ ] Error code mapping tables.

## 11. Lifetime Analysis Implementation Review (Task 125)

### Overview
The Lifetime Analysis pass has been implemented as a separate visitor-based pass (`LifetimeAnalyzer`) that runs after the `TypeChecker`. Its primary goal is to detect dangling pointers caused by returning the address of local variables or parameters from functions.

### Architectural Alignment
The implementation follows the requested multi-pass architecture:
1.  **Parser**: Builds the AST.
2.  **TypeChecker**: Performs semantic analysis, populates the `SymbolTable`, and marks symbols with `SYMBOL_FLAG_LOCAL` and `SYMBOL_FLAG_PARAM`.
3.  **LifetimeAnalyzer**: Performs a read-only pass over the AST to track pointer origins and detect violations.

### Feature Completeness

#### 1. Symbol Tagging
- `TypeChecker::visitVarDecl` correctly distinguishes between global and local scopes (based on whether it's inside a function) and sets `SYMBOL_FLAG_LOCAL` or `SYMBOL_FLAG_GLOBAL`.
- `TypeChecker::visitFnDecl` correctly marks parameters with `SYMBOL_FLAG_LOCAL | SYMBOL_FLAG_PARAM`.

#### 2. Detection Logic
- **Direct Address-of Return**: `return &x` where `x` is local is correctly detected.
- **Local Pointer Tracking**: Tracking of assignments to local pointer variables (e.g., `ptr = &local`) is implemented using a `DynamicArray` of `PointerAssignment` structs.
- **Conservative Analysis**: If a local pointer variable is returned and its origin cannot be proven safe (e.g., if it was assigned from another pointer `p = q`), the analyzer conservatively reports a violation.
- **Parameter Safety**: Returning a parameter directly is allowed (as its lifetime is managed by the caller), but returning the address of a parameter (`return &p`) is correctly blocked.

#### 3. Technical Constraints
- **C++98 Compliance**: Uses standard C++98 syntax. No `auto`, `nullptr`, or modern STL.
- **Memory Management**: Uses `ArenaAllocator` for all allocations, including the `DynamicArray` and placement new for the tracking map.
- **Dependencies**: Restricted to project headers and minimal standard C headers (`cstdio`, `string.h`).
- **Performance**: Uses linear search on `DynamicArray` for assignment tracking, which is efficient for typical small bootstrap-era functions.

### Observations & Deviations
- **Global Flag**: The implementation uses `SYMBOL_FLAG_GLOBAL` to mark non-local variables. In the context of the RetroZig bootstrap compiler, these are functionally equivalent to static storage for lifetime purposes.
- **Analysis Depth**: As per the "safe for bootstrap" philosophy, the analysis focuses on the most common dangling pointer cases. It does not currently handle nested pointer-to-pointer tracking or struct field addresses.


## 12. Assignment Compatibility Implementation (Task 107)

### Phase 1: Foundational Type Helpers
The following foundational type helpers are implemented in `type_checker.cpp` and `type_checker.hpp`:
- **`isNumericType(Type* type)`**: Checks if a given type is any of the numeric types or a `TYPE_INTEGER_LITERAL`.
- **`canLiteralFitInType(Type* literal_type, Type* target_type)`**: Determines if a `TYPE_INTEGER_LITERAL` can be safely assigned to a given numeric type without overflow.
- **`checkBinaryOperation(...)`**: Updated to support C89-style integer literal promotion (e.g., `i32 + <literal 10>` is valid and results in `i32`).

### Phase 2: Assignment Compatibility Validation
Stricter C89 type-checking rules require identical types in binary operations (except for literal promotion). Implicit widening in variable declarations (e.g., `const x: i64 = 42;`) is treated as an error unless it's a direct assignment from an integer literal.

### Phase 3: AST Node Integration
The strict C89 assignment validation is integrated into the AST visitors. The `visitAssignment` and `visitCompoundAssignment` functions use the `IsTypeAssignableTo` function, replacing more lenient logic.

### Test Suite Alignment
Existing tests were refactored to align with these stricter rules:
1.  **Integer literal initializers**: Handled as a special case in `visitVarDecl`.
2.  **Floating-point assignments**: `canLiteralFitInType` was enhanced to allow integer literals to be assigned to floating-point types.
3.  **Strict numeric match**: Binary operations like `TypeCheckerBinaryOps_NumericArithmetic` now use consistent types to avoid mismatch errors during setup.


## 13. Error Handling & Milestone 5 Translation Strategy

### 13.1 Global Error Registry
The bootstrap compiler maintains a global registry of all unique error tags encountered during compilation.
- **Success Convention**: The integer value `0` is reserved for "success".
- **Unique Identifiers**: Each unique error tag is assigned a unique 32-bit positive integer starting from `1`.
- **Global Scope**: All error tags across all error sets share this same global integer space to support merging (`E1 || E2`).
- **MSVC 6.0 Compatibility**: Error codes are emitted as `#define` constants to avoid ambiguities.

```c
/* Generated C89 - Global Error Registry */
#define ERROR_SUCCESS           0
#define ERROR_FILE_NOT_FOUND    1
#define ERROR_PERMISSION_DENIED 2
```

### 13.2 Error Union Representation (`!T`)
Error unions are translated into a C89 `struct` containing a `union` for the payload and the error code.

```c
/* Zig: fn read(path: []const u8) !i32 */
typedef struct {
    union {
        int32_t payload;    /* Valid if is_error is false */
        int error_code;     /* Valid if is_error is true */
    } data;
    int is_error;           /* 0 = success, 1 = error */
} ErrorableInt32;
```

#### Alternative: Pointer Parameters
For simpler functions, the compiler may optionally emit functions that use an out-parameter for the error code:
```c
int32_t read(const char* path, int* out_error);
```

### 13.3 Operator Translation

#### `try` Expression
The `try` expression is translated into an `if` check that propagates the error.
```c
/* Zig: var x = try mightFail(); */
ErrorableInt32 result = mightFail();
if (result.is_error) return result;
int32_t x = result.data.payload;
```

#### `catch` Expression
The `catch` expression provides a fallback value.
```c
/* Zig: var x = mightFail() catch 0; */
ErrorableInt32 result = mightFail();
int32_t x = result.is_error ? 0 : result.data.payload;
```

#### `orelse` Expression
Similar to catch, specifically for optional types.
```c
/* Zig: var x = optional_val orelse default_val; */
int32_t x = optional_val.has_value ? optional_val.value : default_val;
```

#### `errdefer` Statement
Zig's `errdefer` is implemented using `goto` and a cleanup label.
```c
ErrorableInt operation(void) {
    Resource* res = acquire_resource();
    ErrorableInt result = do_work(res);
    if (result.is_error) goto cleanup;
    return result;
cleanup:
    release_resource(res);
    return result;
}
```

### 13.4 Validation Rules & Constraints

#### Stack Safety Rules
1.  Error union structs > 256 bytes cannot use stack return pattern.
2.  Alignment > 4 bytes requires arena allocation for MSVC 6.0.
3.  Deep nesting (> 8 levels) reduces stack threshold to 32 bytes.

#### MSVC 6.0 Specific Constraints
1.  **No `stdbool.h`**: Use `int` with 0/1.
2.  **4-byte alignment**: MSVC 6.0 cannot guarantee 8-byte alignment on the stack.
3.  **32-bit Error Codes**: Mapped via `#define`.
4.  **No `alloca()`**: Avoided for stability.

#### Memory Strategy
- **Small Payloads (< 32 bytes)**: Stored directly on stack (`EXTRACTION_STACK`).
- **Medium Payloads (32-1024 bytes)**: Managed via `ArenaAllocator` (`EXTRACTION_ARENA`).
- **Large Payloads (> 1024 bytes)**: Uses out-parameter pattern (`EXTRACTION_OUT_PARAM`).

## 14. Function Signature Analysis (Task 153)

To ensure generated code is compatible with C89 backend constraints, the bootstrap compiler performs a dedicated signature analysis pass (`SignatureAnalyzer`) after type resolution.

### 14.1 Rejected Signature Patterns

The following patterns are strictly rejected in the bootstrap phase to maintain C89 compatibility:

1.  **Parameter Count Limit**: Functions are limited to a maximum of **4 parameters**. This is a conservative limit to ensure compatibility with MSVC 6.0 stack management and various calling conventions.
2.  **Non-C89 Types in Parameters**:
    -   **Slices** (`[]T`): No direct primitive mapping in C89.
    -   **Error Unions** (`!T`): Error handling is handled via alternative designs.
    -   **Error Sets** (`error{...}`): Incompatible with C89 function signatures.
    -   **Optional Types** (`?T`): Nullability handled differently in C89.
3.  **Multi-level Pointers**: Only single-level pointers (e.g., `*i32`) are allowed in parameters. Multi-level pointers (e.g., `**i32`) are rejected to avoid complexity.
4.  **Void Parameters**: Parameters cannot have the `void` type.

### 14.2 Type Alias Resolution

Signature analysis is performed after type resolution (Pass 0), ensuring that type aliases are fully resolved to their underlying types before validation.

### 14.3 Array Parameters

Zig sized arrays (e.g., `[10]i32`) are allowed in function parameters but trigger a warning (`WARN_ARRAY_PARAMETER`), as they are treated as pointers in the generated C89 code, losing their size information in the signature.

## 15. Generic Function Detection (Tasks 154-160)

Zig supports generic functions through `comptime`, `anytype`, and `type` parameters. To maintain C89 compatibility, the bootstrap compiler detects and strictly rejects these features.

### 15.1 Detection Strategy

The parser is equipped to identify generic function definitions by looking for the following patterns in parameter declarations:
1.  **`comptime` parameters**: Parameters prefixed with the `comptime` keyword.
2.  **`anytype` parameters**: Parameters that use the `anytype` keyword instead of an explicit type.
3.  **`type` parameters**: Parameters whose type is the `type` keyword.

To handle inter-parameter dependencies (e.g., `fn f(comptime T: type, x: T)`), the `TypeChecker` registers parameters in the function's local scope *immediately* after their type is resolved during Pass 0.

### 15.2 Cataloguing and Rejection

When a generic function is detected:
1.  It is recorded in the `GenericCatalogue` with its name, location, and the kind of generic parameter that triggered the detection.
2.  The `TypeChecker` identifies both explicit and implicit generic function calls and catalogues each instantiation site (Task 157), capturing the exact resolved types of all arguments passed.
3.  The `C89FeatureValidator` pass (Pass 1) checks the catalogue and issues a fatal error. For implicit generic calls, it provides a detailed diagnostic including the inferred argument types (e.g., `Implicit generic instantiation of 'foo' with argument types: i32, f64`).

For more details on the detected patterns and C89 compatibility considerations, see [Generic Function Detection](../reference/generic_functions_c89.md).

## 16. Function Call Resolution and Validation (Task 174)

The bootstrap compiler performs comprehensive validation of function calls to ensure they are both semantically correct and compatible with C89 backend constraints.

### 16.1 Resolution Algorithm

Function calls are resolved during the Type Checking phase (Pass 0) using the following steps:
1. **Callee Resolution**: The expression being called (typically an identifier) is visited to determine its type.
2. **Function Type Verification**: The callee's type must be a `TYPE_FUNCTION`. This prevents calling non-function entities, effectively rejecting function pointer variables in the bootstrap phase.
3. **Argument Validation**: Each argument expression is visited and its type is compared against the corresponding parameter type from the function's signature.
4. **Call Site Registration**: Once validated, the call is recorded in the `CallSiteLookupTable`. This table stores the mapping between the AST call node and the resolved function's mangled name, which is crucial for code generation.

### 16.2 Argument Type Checking Rules

The `TypeChecker` enforces strict type compatibility for arguments:
- **Exact Match**: The argument type must ideally match the parameter type exactly.
- **Implicit Widening**: Safe integer widening (e.g., `i8` to `i32`) is allowed for arguments.
- **Literal Promotion**: Integer literals are promoted to the parameter's type if the value fits within its range.
- **Pointer Compatibility**: Standard C89 pointer rules apply (e.g., passing `*T` to `*const T` or `*void` parameters).

### 16.3 C89 Compatibility Rejections

The following call patterns are strictly rejected to maintain C89 compatibility:
1. **Parameter Count**: Calls with more than **4 arguments** are rejected.
2. **Indirect Calls**: Calling functions via variables or other non-identifier expressions is rejected with an informational note about C89 compatibility.
3. **Built-ins**: Most Zig built-in functions (starting with `@`) are rejected, except for the supported subset: `@sizeOf`, `@alignOf`, `@ptrCast`, `@intCast`, `@floatCast`, and `@offsetOf`.
4. **Generic Instantiations**: Both explicit and implicit calls to generic functions are detected and rejected with detailed diagnostics.

For verification details, see the integration tests in `tests/integration/function_call_tests.cpp`.

## 18. Compile-Time Built-ins

The bootstrap compiler supports a core set of built-in functions (intrinsics) that are evaluated at compile-time or mapped to specialized C89 constructs. These built-ins enable low-level operations and metadata access that would otherwise be difficult in a restricted subset of Zig.

### Summary of Supported Built-ins
- **`@sizeOf(T)`**: Returns the size of type `T` in bytes.
- **`@alignOf(T)`**: Returns the alignment requirement of type `T` in bytes.
- **`@offsetOf(T, "field")`**: Returns the byte offset of a field within a struct or union.
- **`@ptrCast(T, expr)`**: Performs an explicit pointer-to-pointer cast.
- **`@intCast(T, expr)`**: Performs a range-checked integer conversion.
- **`@floatCast(T, expr)`**: Performs a range-checked floating-point conversion.

For detailed specifications, syntax, and implementation details for each built-in, please see the [Built-ins Reference](../reference/builtins.md).

## 19. Pointer Arithmetic & Casting Rules

### Pointer Arithmetic
To ensure C89 compatibility and maintain Zig's safety guarantees, the following rules apply to pointer arithmetic:
- **`ptr + unsigned` / `unsigned + ptr`**: Result is a pointer of the same type as `ptr`. The offset must be an unsigned integer type (`u8`, `u32`, `usize`).
- **`ptr - unsigned`**: Result is a pointer of the same type.
- **`ptr1 - ptr2`**: Result is an `isize` representing the distance between the two pointers. This is only valid if both pointers point to the same base type (ignoring `const`).
- **Prohibited**: Arithmetic on `*void`, multi-level pointers (`**T`), or incomplete types is strictly rejected.

### Implicit Pointer Conversions
- **`*void` to `*T`**: The bootstrap compiler allows implicit conversion from a `void` pointer to any typed pointer, provided the target base type is C89-compatible. This matches standard C89 behavior and is essential for using `arena_alloc`.
- **Adding `const`**: Conversion from `*T` to `*const T` is implicit and safe.

### Explicit Casting
- **`@ptrCast(*T, ptr)`**: Used to convert between different pointer types (e.g., `*u8` to `*i32`). Both the source and target must be pointer types.

## 20. Milestone 4 Target Platform Assumptions

The Stage 0 bootstrap compiler assumes a **32-bit little-endian** target environment, which informs the constant-folding of `@sizeOf`, `@alignOf`, and `@offsetOf`.

| Type | Size (bytes) | Alignment | C89 Equivalent |
|------|--------------|-----------|----------------|
| `isize` / `usize` | 4 | 4 | `int` / `unsigned int` |
| Pointers (`*T`) | 4 | 4 | `T*` |
| `i8` / `u8` | 1 | 1 | `signed char` / `unsigned char` |
| `i16` / `u16` | 2 | 2 | `short` / `unsigned short` |
| `i32` / `u32` | 4 | 4 | `int` / `unsigned int` |
| `i64` / `u64` | 8 | 8 | `__int64` / `unsigned __int64` |
| `f32` | 4 | 4 | `float` |
| `f64` | 8 | 8 | `double` |
| `bool` | 4 | 4 | `int` (0 or 1) |

## 21. C89 Rejection Framework

The rejection process is a key part of the compiler's design, preventing the use of modern language constructs that have no direct or simple equivalent in C89.

### AST Pre-Scan Validator

The `C89FeatureValidator` is a visitor class that traverses the entire Abstract Syntax Tree immediately after the parsing stage is complete. Its sole responsibility is to detect AST nodes that represent language features not supported in the C89-compatible subset.

When an unsupported feature is found, the validator performs the following actions:
1.  It uses the `ErrorHandler` to report a fatal error, providing a clear message indicating why the feature is not supported.
2.  It sets an internal `error_found_` flag, which causes the `validate()` method to eventually return `false`.

To maintain stability in test environments, child processes explicitly call `abort()` if the error handler reports any errors.

### Feature Compatibility & Rationale

| Feature | Zig Syntax Example | Rationale |
|---------|-------------------|-----------|
| **Slices** | `var s: []u8;` | Slices require a struct (`{ptr, len}`) and runtime support that do not exist in C89. |
| **Error Unions** | `var v: !i32;` | C89 uses error codes or `errno`. |
| **Optionals** | `var v: ?*i32;` | Optionals are implemented as tagged unions or pointers, which is a higher-level concept. |
| **Multi-level Pointers**| `var p: **i32;` | Adds unnecessary complexity to the bootstrap type system. |
| **Function Pointers** | `var f = &func;` | Rejected to simplify the type system and code generation. |
| **Struct Methods** | `s.method()` | C89 structs do not have associated functions. Equivalent is passing a struct pointer to a global function. |
| **Variadic Functions** | `fn f(args: ...)` | Not supported to simplify calling convention and type checking. |
| **Generics** | `comptime T: type`| C89 does not support compile-time type parameters or templates. |

### Milestone 5 Integration & Translation Strategy

| Zig Feature | Milestone 4 Status | Milestone 5 Translation Strategy | C89 Equivalent |
|-------------|--------------------|-----------------------------------|----------------|
| Error Unions | Rejected | Extraction Strategy (Stack/Arena/Out) | Struct + Union |
| Error Sets | Rejected | Global Integer Registry | #define constants |
| `try` | Rejected | Pattern-based Generation | `if (err) return err;` |
| `catch` | Rejected | Fallback Pattern Generation | `if (err) { val = fallback; }` |
| `orelse` | Rejected | Optional Unwrapping Pattern | `if (val) { ... } else { ... }` |
| `errdefer` | Rejected | Goto-based Cleanup | `goto cleanup;` |
| Generics | Rejected | Template Specialization / Mangling | Mangled Functions |
