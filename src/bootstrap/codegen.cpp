#include "codegen.hpp"
#include "platform.hpp"
#include "utils.hpp"
#include <cstdio>

C89Emitter::C89Emitter(ArenaAllocator& arena, ErrorHandler& error_handler)
    : buffer_pos_(0), output_file_(PLAT_INVALID_FILE), indent_level_(0), owns_file_(false),
      var_alloc_(arena), error_handler_(error_handler), arena_(arena), global_names_(arena) {
}

C89Emitter::C89Emitter(ArenaAllocator& arena, ErrorHandler& error_handler, const char* path)
    : buffer_pos_(0), indent_level_(0), owns_file_(true),
      var_alloc_(arena), error_handler_(error_handler), arena_(arena), global_names_(arena) {
    output_file_ = plat_open_file(path, true);
}

C89Emitter::C89Emitter(ArenaAllocator& arena, ErrorHandler& error_handler, PlatFile file)
    : buffer_pos_(0), output_file_(file), indent_level_(0), owns_file_(false),
      var_alloc_(arena), error_handler_(error_handler), arena_(arena), global_names_(arena) {
}

C89Emitter::~C89Emitter() {
    close();
}

void C89Emitter::indent() {
    indent_level_++;
}

void C89Emitter::dedent() {
    if (indent_level_ > 0) {
        indent_level_--;
    }
}

void C89Emitter::writeIndent() {
    for (int i = 0; i < indent_level_; ++i) {
        write("    ", 4);
    }
}

void C89Emitter::emitPrologue() {
    emitComment("Generated by RetroZig bootstrap compiler");
    writeString("#include \"zig_runtime.h\"\n\n");
}

void C89Emitter::beginFunction() {
    var_alloc_.reset();
}

void C89Emitter::emitType(Type* type, const char* name) {
    if (!type) {
        writeString("/* unknown_type */");
        if (name) { writeString(" "); writeString(name); }
        return;
    }

    if (type->kind == TYPE_POINTER) {
        if (type->as.pointer.is_const) {
            writeString("const ");
        }
        emitType(type->as.pointer.base);
        writeString("*");
        if (name) {
            writeString(" ");
            writeString(name);
        }
        return;
    }

    if (type->kind == TYPE_ARRAY) {
        emitType(type->as.array.element_type);
        if (name) {
            writeString(" ");
            writeString(name);
            char buf[32];
            sprintf(buf, "[%lu]", (unsigned long)type->as.array.size);
            writeString(buf);
        } else {
            char buf[32];
            sprintf(buf, "[%lu]", (unsigned long)type->as.array.size);
            writeString(buf);
        }
        return;
    }

    switch (type->kind) {
        case TYPE_VOID: writeString("void"); break;
        case TYPE_BOOL: writeString("int"); break;
        case TYPE_I8: writeString("signed char"); break;
        case TYPE_U8: writeString("unsigned char"); break;
        case TYPE_I16: writeString("short"); break;
        case TYPE_U16: writeString("unsigned short"); break;
        case TYPE_I32: writeString("int"); break;
        case TYPE_U32: writeString("unsigned int"); break;
        case TYPE_I64: writeString("__int64"); break;
        case TYPE_U64: writeString("unsigned __int64"); break;
        case TYPE_F32: writeString("float"); break;
        case TYPE_F64: writeString("double"); break;
        case TYPE_ISIZE: writeString("int"); break;
        case TYPE_USIZE: writeString("unsigned int"); break;
        case TYPE_STRUCT:
            writeString("struct ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_UNION:
            writeString("union ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_ENUM:
            writeString("enum ");
            if (!type->c_name && type->as.enum_details.name) {
                type->c_name = getC89GlobalName(type->as.enum_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        default:
            writeString("/* unsupported type */");
            break;
    }

    if (name) {
        writeString(" ");
        writeString(name);
    }
}

void C89Emitter::emitGlobalVarDecl(const ASTNode* node, bool is_public) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    if (!isConstantInitializer(decl->initializer)) {
        error_handler_.report(ERR_GLOBAL_VAR_NON_CONSTANT_INIT, decl->name_loc,
            "Global variable must have a constant initializer for C89 compatibility",
            "Try using a literal or a constant expression");
        return;
    }

    if (!is_public) {
        writeString("static ");
    }

    if (decl->is_const) {
        writeString("const ");
    }

    const char* c_name = getC89GlobalName(decl->name);
    emitType(node->resolved_type, c_name);

    if (decl->initializer) {
        writeString(" = ");
        emitExpression(decl->initializer);
    }

    writeString(";\n");
}

bool C89Emitter::isConstantInitializer(const ASTNode* node) const {
    if (!node) return true;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
            return true;
        case NODE_PAREN_EXPR:
            return isConstantInitializer(node->as.paren_expr.expr);
        case NODE_UNARY_OP:
            return isConstantInitializer(node->as.unary_op.operand);
        case NODE_BINARY_OP:
            return isConstantInitializer(node->as.binary_op->left) &&
                   isConstantInitializer(node->as.binary_op->right);
        default:
            return false;
    }
}

void C89Emitter::write(const char* data, size_t len) {
    if (output_file_ == PLAT_INVALID_FILE) return;

    if (buffer_pos_ + len > sizeof(buffer_)) {
        flush();
        // If the data is larger than the buffer itself, write it directly
        if (len > sizeof(buffer_)) {
            plat_write_file(output_file_, data, len);
            return;
        }
    }

    plat_memcpy(buffer_ + buffer_pos_, data, len);
    buffer_pos_ += len;
}

void C89Emitter::writeString(const char* str) {
    if (!str) return;
    write(str, plat_strlen(str));
}

void C89Emitter::emitComment(const char* text) {
    if (!text) return;
    writeIndent();
    write("/* ", 3);
    writeString(text);
    write(" */\n", 4);
}

void C89Emitter::flush() {
    if (output_file_ != PLAT_INVALID_FILE && buffer_pos_ > 0) {
        plat_write_file(output_file_, buffer_, buffer_pos_);
        buffer_pos_ = 0;
    }
}

bool C89Emitter::open(const char* path) {
    close();
    output_file_ = plat_open_file(path, true);
    owns_file_ = true;
    return isValid();
}

void C89Emitter::close() {
    flush();
    if (owns_file_ && output_file_ != PLAT_INVALID_FILE) {
        plat_close_file(output_file_);
        output_file_ = PLAT_INVALID_FILE;
    }
}

void C89Emitter::emitExpression(const ASTNode* node) {
    if (!node) return;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
            emitIntegerLiteral(&node->as.integer_literal);
            break;
        case NODE_FLOAT_LITERAL:
            emitFloatLiteral(&node->as.float_literal);
            break;
        case NODE_STRING_LITERAL:
            emitStringLiteral(&node->as.string_literal);
            break;
        case NODE_CHAR_LITERAL:
            emitCharLiteral(&node->as.char_literal);
            break;
        case NODE_PAREN_EXPR:
            writeString("(");
            emitExpression(node->as.paren_expr.expr);
            writeString(")");
            break;
        default:
            writeString("/* [Unimplemented Expression] */");
            break;
    }
}

void C89Emitter::emitIntegerLiteral(const ASTIntegerLiteralNode* node) {
    char buf[32];
    u64_to_decimal(node->value, buf, sizeof(buf));
    writeString(buf);

    if (node->resolved_type) {
        switch (node->resolved_type->kind) {
            case TYPE_U32:
                writeString("U");
                break;
            case TYPE_I64:
                writeString("i64");
                break;
            case TYPE_U64:
                writeString("ui64");
                break;
            default:
                // i32, u8, i8, u16, i16, usize, isize get no suffix
                break;
        }
    }
}

void C89Emitter::emitFloatLiteral(const ASTFloatLiteralNode* node) {
    char buffer[64];
    sprintf(buffer, "%.15g", node->value);

    // Ensure it's treated as a float by C (add .0 if no '.' or 'e')
    bool has_dot = false;
    bool has_exp = false;
    for (char* p = buffer; *p; ++p) {
        if (*p == '.') has_dot = true;
        if (*p == 'e' || *p == 'E') has_exp = true;
    }

    writeString(buffer);
    if (!has_dot && !has_exp) {
        writeString(".0");
    }

    if (node->resolved_type && node->resolved_type->kind == TYPE_F32) {
        writeString("f");
    }
}

void C89Emitter::emitStringLiteral(const ASTStringLiteralNode* node) {
    if (!node || !node->value) return;

    // TODO: Split long strings if needed for MSVC 6.0
    write("\"", 1);
    const char* p = node->value;
    while (*p) {
        emitEscapedByte((unsigned char)*p, false);
        p++;
    }
    write("\"", 1);
}

void C89Emitter::emitCharLiteral(const ASTCharLiteralNode* node) {
    if (!node) return;
    write("'", 1);
    emitEscapedByte((unsigned char)node->value, true);
    write("'", 1);
}

const char* C89Emitter::getC89GlobalName(const char* zig_name) {
    for (size_t i = 0; i < global_names_.length(); ++i) {
        if (strings_equal(global_names_[i].zig_name, zig_name)) {
            return global_names_[i].c89_name;
        }
    }

    char buf[256];
    plat_strncpy(buf, zig_name, 250);
    buf[250] = '\0';
    sanitizeForC89(buf);

    if (plat_strlen(buf) > 31) {
        buf[31] = '\0';
    }

    // Ensure uniqueness by appending a suffix if the mangled name collides
    char final_buf[256];
    plat_strcpy(final_buf, buf);
    int suffix = 0;
    bool unique = false;

    while (!unique) {
        unique = true;
        for (size_t i = 0; i < global_names_.length(); ++i) {
            if (strings_equal(global_names_[i].c89_name, final_buf)) {
                unique = false;
                break;
            }
        }

        if (!unique) {
            suffix++;
            char suffix_str[16];
            sprintf(suffix_str, "%d", suffix);
            size_t suffix_len = plat_strlen(suffix_str);
            size_t base_len = plat_strlen(buf);

            if (base_len + suffix_len > 31) {
                plat_strncpy(final_buf, buf, 31 - suffix_len);
                final_buf[31 - suffix_len] = '\0';
                plat_strcpy(final_buf + (31 - suffix_len), suffix_str);
            } else {
                plat_strcpy(final_buf, buf);
                plat_strcpy(final_buf + base_len, suffix_str);
            }
        }
    }

    size_t len = plat_strlen(final_buf);
    char* owned_name = (char*)arena_.alloc(len + 1);
    plat_memcpy(owned_name, final_buf, len + 1);

    GlobalNameEntry entry;
    entry.zig_name = zig_name;
    entry.c89_name = owned_name;
    global_names_.append(entry);

    return owned_name;
}

void C89Emitter::emitEscapedByte(unsigned char c, bool is_char_literal) {
    switch (c) {
        case '\a': write("\\a", 2); return;
        case '\b': write("\\b", 2); return;
        case '\f': write("\\f", 2); return;
        case '\n': write("\\n", 2); return;
        case '\r': write("\\r", 2); return;
        case '\t': write("\\t", 2); return;
        case '\v': write("\\v", 2); return;
        case '\\': write("\\\\", 2); return;
        case '\'':
            if (is_char_literal) write("\\'", 2);
            else write("'", 1);
            return;
        case '\"':
            if (!is_char_literal) write("\\\"", 2);
            else write("\"", 1);
            return;
        default:
            if (c >= 32 && c <= 126) {
                char ch = (char)c;
                write(&ch, 1);
            } else {
                char buf[8];
                // Use octal escape \ooo (three digits zero-padded)
                sprintf(buf, "\\%03o", c);
                writeString(buf);
            }
    }
}
