#include "codegen.hpp"
#include "compilation_unit.hpp"
#include "ast_utils.hpp"
#include "platform.hpp"
#include "utils.hpp"
#include "symbol_table.hpp"


C89Emitter::C89Emitter(CompilationUnit& unit)
    : buffer_pos_(0), output_file_(PLAT_INVALID_FILE), indent_level_(0), owns_file_(false),
      unit_(unit), var_alloc_(unit.getArena()), error_handler_(unit.getErrorHandler()), arena_(unit.getArena()), global_names_(unit.getArena()),
      emitted_slices_(unit.getArena()), external_cache_(NULL),
      defer_stack_(unit.getArena()), current_fn_ret_type_(NULL),
      type_def_buffer_(NULL), type_def_pos_(0), type_def_cap_(65536), in_type_def_mode_(false),
      module_name_(NULL), last_char_('\0') {
    type_def_buffer_ = (char*)arena_.alloc(type_def_cap_);
}

C89Emitter::C89Emitter(CompilationUnit& unit, const char* path)
    : buffer_pos_(0), indent_level_(0), owns_file_(true),
      unit_(unit), var_alloc_(unit.getArena()), error_handler_(unit.getErrorHandler()), arena_(unit.getArena()), global_names_(unit.getArena()),
      emitted_slices_(unit.getArena()), external_cache_(NULL),
      defer_stack_(unit.getArena()), current_fn_ret_type_(NULL),
      type_def_buffer_(NULL), type_def_pos_(0), type_def_cap_(65536), in_type_def_mode_(false),
      module_name_(NULL), last_char_('\0') {
    output_file_ = plat_open_file(path, true);
    type_def_buffer_ = (char*)arena_.alloc(type_def_cap_);
}


C89Emitter::C89Emitter(CompilationUnit& unit, PlatFile file)
    : buffer_pos_(0), output_file_(file), indent_level_(0), owns_file_(false),
      unit_(unit), var_alloc_(unit.getArena()), error_handler_(unit.getErrorHandler()), arena_(unit.getArena()), global_names_(unit.getArena()),
      emitted_slices_(unit.getArena()), external_cache_(NULL),
      defer_stack_(unit.getArena()), current_fn_ret_type_(NULL),
      type_def_buffer_(NULL), type_def_pos_(0), type_def_cap_(65536), in_type_def_mode_(false),
      module_name_(NULL), last_char_('\0') {
    type_def_buffer_ = (char*)arena_.alloc(type_def_cap_);
}

C89Emitter::~C89Emitter() {
    close();
}

void C89Emitter::indent() {
    indent_level_++;
}

void C89Emitter::dedent() {
    if (indent_level_ > 0) {
        indent_level_--;
    }
}

void C89Emitter::writeIndent() {
    for (int i = 0; i < indent_level_; ++i) {
        write("    ", 4);
    }
}

void C89Emitter::emitPrologue() {
    emitComment("Generated by RetroZig bootstrap compiler");
    writeString("#include \"zig_runtime.h\"\n\n");
}

void C89Emitter::beginFunction() {
    var_alloc_.reset();
    for_loop_counter_ = 0;
}

void C89Emitter::emitType(Type* type, const char* name) {
    emitDeclarator(type, name);
}

void C89Emitter::emitDeclarator(Type* type, const char* name, const ASTFnDeclNode* params_node) {
    emitTypePrefix(type);
    if (name) {
        if (last_char_ != '(' && last_char_ != ' ') {
            writeString(" ");
        }
        writeString(name);
    }

    if (params_node) {
        writeString("(");
        if (!params_node->params || params_node->params->length() == 0) {
            writeString("void");
        } else {
            for (size_t i = 0; i < params_node->params->length(); ++i) {
                ASTParamDeclNode* param = (*params_node->params)[i];
                // For definition (within FnDecl), use mangled local name.
                // For prototype, use original name.
                const char* param_name = param->symbol ? var_alloc_.allocate(param->symbol) : param->name;
                emitDeclarator(param->type->resolved_type, param_name);
                if (i < params_node->params->length() - 1) {
                    writeString(", ");
                }
            }
        }
        writeString(")");
    }

    emitTypeSuffix(type);
}

void C89Emitter::emitTypePrefix(Type* type) {
    if (!type) {
        writeString("void");
        return;
    }

    switch (type->kind) {
        case TYPE_POINTER:
            emitTypePrefix(type->as.pointer.base);
            if (type->as.pointer.base->kind != TYPE_POINTER &&
                (type->as.pointer.base->kind == TYPE_ARRAY ||
                 type->as.pointer.base->kind == TYPE_FUNCTION_POINTER ||
                 type->as.pointer.base->kind == TYPE_FUNCTION)) {
                writeString(" (*");
            } else {
                writeString("*");
            }
            break;
        case TYPE_ARRAY:
            emitTypePrefix(type->as.array.element_type);
            break;
        case TYPE_FUNCTION:
            emitTypePrefix(type->as.function.return_type);
            break;
        case TYPE_FUNCTION_POINTER:
            emitTypePrefix(type->as.function_pointer.return_type);
            writeString(" (*");
            break;
        default:
            emitBaseType(type);
            break;
    }
}

void C89Emitter::emitTypeSuffix(Type* type) {
    if (!type) return;

    switch (type->kind) {
        case TYPE_POINTER:
            if (type->as.pointer.base->kind != TYPE_POINTER &&
                (type->as.pointer.base->kind == TYPE_ARRAY ||
                 type->as.pointer.base->kind == TYPE_FUNCTION_POINTER ||
                 type->as.pointer.base->kind == TYPE_FUNCTION)) {
                writeString(")");
            }
            emitTypeSuffix(type->as.pointer.base);
            break;
        case TYPE_ARRAY: {
            char buf[32];
            writeString("[");
            plat_u64_to_string(type->as.array.size, buf, sizeof(buf));
            writeString(buf);
            writeString("]");
            emitTypeSuffix(type->as.array.element_type);
            break;
        }
        case TYPE_FUNCTION: {
            writeString("(");
            DynamicArray<Type*>* params = type->as.function.params;
            if (!params || params->length() == 0) {
                writeString("void");
            } else {
                for (size_t i = 0; i < params->length(); ++i) {
                    emitDeclarator((*params)[i], NULL);
                    if (i < params->length() - 1) writeString(", ");
                }
            }
            writeString(")");
            emitTypeSuffix(type->as.function.return_type);
            break;
        }
        case TYPE_FUNCTION_POINTER: {
            writeString(")");
            writeString("(");
            DynamicArray<Type*>* params = type->as.function_pointer.param_types;
            if (!params || params->length() == 0) {
                writeString("void");
            } else {
                for (size_t i = 0; i < params->length(); ++i) {
                    emitDeclarator((*params)[i], NULL);
                    if (i < params->length() - 1) writeString(", ");
                }
            }
            writeString(")");
            emitTypeSuffix(type->as.function_pointer.return_type);
            break;
        }
        default:
            break;
    }
}

void C89Emitter::emitBaseType(Type* type) {
    if (!type) {
        writeString("void");
        return;
    }

    switch (type->kind) {
        case TYPE_VOID: writeString("void"); break;
        case TYPE_BOOL: writeString("int"); break;
        case TYPE_I8: writeString("signed char"); break;
        case TYPE_U8: writeString("unsigned char"); break;
        case TYPE_I16: writeString("short"); break;
        case TYPE_U16: writeString("unsigned short"); break;
        case TYPE_I32: writeString("int"); break;
        case TYPE_U32: writeString("unsigned int"); break;
        case TYPE_I64: writeString("__int64"); break;
        case TYPE_U64: writeString("unsigned __int64"); break;
        case TYPE_F32: writeString("float"); break;
        case TYPE_F64: writeString("double"); break;
        case TYPE_ISIZE: writeString("int"); break;
        case TYPE_USIZE: writeString("unsigned int"); break;
        case TYPE_SLICE:
            ensureSliceType(type);
            writeString(getMangledTypeName(type));
            break;
        case TYPE_STRUCT:
            writeString("struct ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_UNION:
            writeString("union ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_ENUM:
            writeString("enum ");
            if (!type->c_name && type->as.enum_details.name) {
                type->c_name = getC89GlobalName(type->as.enum_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        default:
            writeString("/* unsupported type */");
            break;
    }
}

void C89Emitter::emitGlobalVarDecl(const ASTNode* node, bool is_public) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    // Use flags from node, but allow override from is_public for now to avoid breaking tests
    bool external = is_public || decl->is_pub || decl->is_extern || decl->is_export;

    // Skip type and module declarations (e.g. const T = struct { ... } or const std = @import("std"))
    if (decl->initializer && decl->initializer->resolved_type) {
        Type* init_type = decl->initializer->resolved_type;
        if (init_type->kind == TYPE_MODULE ||
            (decl->is_const && (init_type->kind == TYPE_STRUCT || init_type->kind == TYPE_UNION || init_type->kind == TYPE_ENUM))) {
            return;
        }
    }

    if (decl->initializer && !isConstantInitializer(decl->initializer)) {
        error_handler_.report(ERR_GLOBAL_VAR_NON_CONSTANT_INIT, decl->name_loc,
            "Global variable must have a constant initializer for C89 compatibility",
            "Try using a literal or a constant expression");
        return;
    }

    writeIndent();
    if (decl->is_extern) {
        writeString("extern ");
    } else if (!external) {
        writeString("static ");
    }

    Type* type = node->resolved_type;
    const char* c_name = getC89GlobalName(decl->name);

    emitDeclarator(type, c_name);

    if (decl->initializer) {
        writeString(" = ");
        emitExpression(decl->initializer);
    }

    writeString(";\n");
}

void C89Emitter::emitInitializerAssignments(const char* base_name, const ASTNode* init_node) {
    if (!init_node || init_node->type != NODE_STRUCT_INITIALIZER) return;
    const ASTStructInitializerNode* init = init_node->as.struct_initializer;
    Type* type = init_node->resolved_type;

    if (!type) return;

    if (type->kind == TYPE_STRUCT) {
        DynamicArray<StructField>* fields = type->as.struct_details.fields;
        for (size_t i = 0; i < fields->length(); ++i) {
            const char* field_name = (*fields)[i].name;
            // Find in initializer
            ASTNode* val = NULL;
            for (size_t j = 0; j < init->fields->length(); ++j) {
                if (plat_strcmp((*init->fields)[j]->field_name, field_name) == 0) {
                    val = (*init->fields)[j]->value;
                    break;
                }
            }

            if (val) {
                if (val->type == NODE_STRUCT_INITIALIZER) {
                    char nested_name[256];
                    char* cur = nested_name;
                    size_t rem = sizeof(nested_name);
                    safe_append(cur, rem, base_name);
                    safe_append(cur, rem, ".");
                    safe_append(cur, rem, field_name);
                    emitInitializerAssignments(nested_name, val);
                } else {
                    writeIndent();
                    writeString(base_name);
                    writeString(".");
                    writeString(field_name);
                    writeString(" = ");
                    emitExpression(val);
                    writeString(";\n");
                }
            }
        }
    } else if (type->kind == TYPE_ARRAY) {
        for (size_t i = 0; i < init->fields->length(); ++i) {
            ASTNode* val = (*init->fields)[i]->value;
            char idx_str[32];
            plat_i64_to_string(i, idx_str, sizeof(idx_str));

            if (val->type == NODE_STRUCT_INITIALIZER) {
                char nested_name[256];
                char* cur = nested_name;
                size_t rem = sizeof(nested_name);
                safe_append(cur, rem, base_name);
                safe_append(cur, rem, "[");
                safe_append(cur, rem, idx_str);
                safe_append(cur, rem, "]");
                emitInitializerAssignments(nested_name, val);
            } else {
                writeIndent();
                writeString(base_name);
                writeString("[");
                writeString(idx_str);
                writeString("] = ");
                emitExpression(val);
                writeString(";\n");
            }
        }
    }
}

void C89Emitter::emitLocalVarDecl(const ASTNode* node, bool emit_assignment) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    if (!decl->symbol) return;
    const char* c_name = var_alloc_.allocate(decl->symbol);

    if (!emit_assignment) {
        writeIndent();
        emitDeclarator(node->resolved_type, c_name);
        writeString(";\n");
    } else {
        if (decl->initializer) {
            bool is_undefined = (decl->initializer->type == NODE_UNDEFINED_LITERAL);

            if (!is_undefined) {
                if (decl->initializer->type == NODE_STRUCT_INITIALIZER) {
                    emitInitializerAssignments(c_name, decl->initializer);
                } else {
                    writeIndent();
                    writeString(c_name);
                    writeString(" = ");
                    emitExpression(decl->initializer);
                    writeString(";\n");
                }
            }
        }
    }
}

void C89Emitter::emitFnProto(const ASTFnDeclNode* node, bool is_public) {
    if (!node) return;

    writeIndent();

    // Special handling for the main entry point
    if (plat_strcmp(node->name, "main") == 0 && (node->is_pub || is_public)) {
        writeString("int main(int argc, char* argv[]);");
    } else {
        if (node->is_extern) {
            writeString("extern ");
        } else if (!is_public && !node->is_pub && !node->is_export) {
            writeString("static ");
        }

        Type* ret_type = node->return_type ? node->return_type->resolved_type : get_g_type_void();
        const char* mangled_name = getC89GlobalName(node->name);

        // For prototype, we don't necessarily want to allocate parameter names in var_alloc_,
        // so we don't pass 'node' as params_node if we want to avoid side effects.
        // But we want to emit parameter types correctly.
        emitTypePrefix(ret_type);
        writeString(" ");
        writeString(mangled_name);
        writeString("(");
        if (!node->params || node->params->length() == 0) {
            writeString("void");
        } else {
            for (size_t i = 0; i < node->params->length(); ++i) {
                ASTParamDeclNode* param = (*node->params)[i];
                emitDeclarator(param->type->resolved_type, NULL);
                if (i < node->params->length() - 1) {
                    writeString(", ");
                }
            }
        }
        writeString(")");
        emitTypeSuffix(ret_type);
        writeString(";");
    }
}

void C89Emitter::emitFnDecl(const ASTFnDeclNode* node) {
    if (!node) return;
    beginFunction();

    writeIndent();

    Type* ret_type = node->return_type ? node->return_type->resolved_type : get_g_type_void();
    current_fn_ret_type_ = ret_type;
    defer_stack_.clear();

    // Special handling for the main entry point
    if (plat_strcmp(node->name, "main") == 0 && node->is_pub) {
        writeString("int main(int argc, char* argv[])");
    } else {
        if (node->is_extern) {
            writeString("extern ");
        } else if (!node->is_pub && !node->is_export) {
            writeString("static ");
        }

        const char* mangled_name = getC89GlobalName(node->name);

        emitDeclarator(ret_type, mangled_name, node);
    }

    if (node->body) {
        writeString(" ");
        emitBlock(&node->body->as.block_stmt);
        writeString("\n\n");
    } else {
        writeString(";\n\n");
    }
}

void C89Emitter::emitBlock(const ASTBlockStmtNode* node, int label_id) {
    if (!node) return;

    writeString("{\n");
    indent();

    DeferScope* scope = (DeferScope*)arena_.alloc(sizeof(DeferScope));
    new (scope) DeferScope(arena_, label_id);
    defer_stack_.append(scope);

    // Pass 1: Local declarations
    for (size_t i = 0; i < node->statements->length(); ++i) {
        ASTNode* stmt = (*node->statements)[i];
        if (stmt->type == NODE_VAR_DECL) {
            emitLocalVarDecl(stmt, false);
        }
    }

    // Pass 2: Statements
    bool exits = false;
    for (size_t i = 0; i < node->statements->length(); ++i) {
        ASTNode* stmt = (*node->statements)[i];
        if (stmt->type == NODE_VAR_DECL) {
            emitLocalVarDecl(stmt, true);
        } else if (stmt->type == NODE_DEFER_STMT) {
            scope->defers.append(&stmt->as.defer_stmt);
        } else {
            emitStatement(stmt);
            if (allPathsExit(stmt)) {
                exits = true;
                // Once we hit a path that always exits, any subsequent statements in this block are unreachable.
                break;
            }
        }
    }

    // Emit defers for this block in reverse order, only if not already handled by a terminator
    if (!exits) {
        for (int i = (int)scope->defers.length() - 1; i >= 0; --i) {
            emitStatement(scope->defers[i]->statement);
        }
    }

    defer_stack_.pop_back();

    dedent();
    writeIndent();
    writeString("}");
}

void C89Emitter::emitStatement(const ASTNode* node) {
    if (!node) return;

    switch (node->type) {
        case NODE_BLOCK_STMT:
            writeIndent();
            emitBlock(&node->as.block_stmt);
            writeString("\n");
            break;
        case NODE_IF_STMT:
            emitIf(node->as.if_stmt);
            break;
        case NODE_WHILE_STMT:
            emitWhile(node->as.while_stmt);
            break;
        case NODE_FOR_STMT:
            emitFor(node->as.for_stmt);
            break;
        case NODE_BREAK_STMT:
            emitBreak(&node->as.break_stmt);
            break;
        case NODE_CONTINUE_STMT:
            emitContinue(&node->as.continue_stmt);
            break;
        case NODE_RETURN_STMT:
            emitReturn(&node->as.return_stmt);
            break;
        case NODE_DEFER_STMT:
            writeIndent();
            writeString("/* defer */\n");
            break;
        case NODE_EXPRESSION_STMT:
            writeIndent();
            emitExpression(node->as.expression_stmt.expression);
            writeString(";\n");
            break;
        case NODE_ASSIGNMENT:
            writeIndent();
            emitExpression(node);
            writeString(";\n");
            break;
        case NODE_EMPTY_STMT:
            writeIndent();
            writeString(";\n");
            break;
        default:
            writeIndent();
            writeString("/* Unimplemented statement type ");
            char num[16];
            plat_i64_to_string(node->type, num, sizeof(num));
            writeString(num);
            writeString(" */\n");
            break;
    }
}

void C89Emitter::emitIf(const ASTIfStmtNode* node) {
    if (!node) return;

    writeIndent();
    writeString("if (");
    emitExpression(node->condition);
    writeString(") ");

    if (node->then_block->type == NODE_BLOCK_STMT) {
        emitBlock(&node->then_block->as.block_stmt);
    } else {
        emitStatement(node->then_block);
    }

    if (node->else_block) {
        writeString(" else ");
        if (node->else_block->type == NODE_IF_STMT) {
            emitIf(node->else_block->as.if_stmt);
        } else if (node->else_block->type == NODE_BLOCK_STMT) {
            emitBlock(&node->else_block->as.block_stmt);
        } else {
            emitStatement(node->else_block);
        }
    }
    writeString("\n");
}

void C89Emitter::emitFor(const ASTForStmtNode* node) {
    if (!node) return;

    for_loop_counter_++;
    int current_for_id = for_loop_counter_;

    char idx_name[32];
    char len_name[32];
    char iter_name[32];
    char id_buf[16]; plat_i64_to_string(current_for_id, id_buf, sizeof(id_buf));

    char* cur = idx_name; size_t rem = sizeof(idx_name);
    safe_append(cur, rem, "__for_idx_");
    safe_append(cur, rem, id_buf);

    cur = len_name; rem = sizeof(len_name);
    safe_append(cur, rem, "__for_len_");
    safe_append(cur, rem, id_buf);

    cur = iter_name; rem = sizeof(iter_name);
    safe_append(cur, rem, "__for_iter_");
    safe_append(cur, rem, id_buf);

    bool is_range = (node->iterable_expr->type == NODE_RANGE);

    writeIndent();
    writeString("{\n");
    indent();

    // Iterable evaluate once
    if (!is_range) {
        writeIndent();
        Type* iter_type = node->iterable_expr->resolved_type;
        if (iter_type->kind == TYPE_ARRAY) {
             // Emit as pointer
             emitType(createPointerType(arena_, iter_type->as.array.element_type, true), iter_name);
        } else {
             emitType(iter_type, iter_name);
        }
        writeString(" = ");
        emitExpression(node->iterable_expr);
        writeString(";\n");
    }

    // Initializer
    writeIndent();
    writeString("size_t ");
    writeString(idx_name);
    writeString(" = ");
    if (is_range) {
        emitExpression(node->iterable_expr->as.range.start);
    } else {
        writeString("0");
    }
    writeString(";\n");

    writeIndent();
    writeString("size_t ");
    writeString(len_name);
    writeString(" = ");
    if (is_range) {
        emitExpression(node->iterable_expr->as.range.end);
    } else {
        Type* iterable_type = node->iterable_expr->resolved_type;
        if (iterable_type && iterable_type->kind == TYPE_ARRAY) {
            char size_buf[32];
            plat_u64_to_string(iterable_type->as.array.size, size_buf, sizeof(size_buf));
            writeString(size_buf);
        } else if (iterable_type && iterable_type->kind == TYPE_SLICE) {
            writeString(iter_name);
            writeString(".len");
        } else {
            writeString("0 /* Unknown length */");
        }
    }
    writeString(";\n");

    char label_base[256];
    bool has_label = (node->label != NULL);
    if (has_label) {
        char* lcur = label_base;
        size_t lrem = sizeof(label_base);
        safe_append(lcur, lrem, "__zig_label_");
        safe_append(lcur, lrem, node->label);
        safe_append(lcur, lrem, "_");
        char lid_buf[16];
        plat_i64_to_string(node->label_id, lid_buf, sizeof(lid_buf));
        safe_append(lcur, lrem, lid_buf);

        writeIndent();
        writeString(label_base);
        writeString("_start: ;\n");
    }

    writeIndent();
    writeString("while (");
    writeString(idx_name);
    writeString(" < ");
    writeString(len_name);
    writeString(") {\n");

    indent();

    // Item capture
    Type* item_type = NULL;
    if (is_range) {
        item_type = get_g_type_usize();
    } else {
        Type* iterable_type = node->iterable_expr->resolved_type;
        if (iterable_type && iterable_type->kind == TYPE_ARRAY) {
            item_type = iterable_type->as.array.element_type;
        } else if (iterable_type && iterable_type->kind == TYPE_SLICE) {
            item_type = iterable_type->as.slice.element_type;
        }
    }

    if (item_type && node->item_name && plat_strcmp(node->item_name, "_") != 0) {
        const char* actual_item_name;
        if (node->item_sym) {
            actual_item_name = var_alloc_.allocate(node->item_sym);
        } else {
            actual_item_name = var_alloc_.generate(node->item_name);
        }

        writeIndent();
        emitType(item_type, actual_item_name);
        writeString(" = ");
        if (is_range) {
            writeString(idx_name);
        } else {
            writeString(iter_name);
            if (node->iterable_expr->resolved_type && node->iterable_expr->resolved_type->kind == TYPE_SLICE) {
                writeString(".ptr[");
            } else {
                writeString("[");
            }
            writeString(idx_name);
            writeString("]");
        }
        writeString(";\n");
    }

    // Index capture
    if (node->index_name && plat_strcmp(node->index_name, "_") != 0) {
        const char* actual_index_name;
        if (node->index_sym) {
            actual_index_name = var_alloc_.allocate(node->index_sym);
        } else {
            actual_index_name = var_alloc_.generate(node->index_name);
        }

        writeIndent();
        writeString("size_t ");
        writeString(actual_index_name);
        writeString(" = ");
        writeString(idx_name);
        writeString(";\n");
    }

    // Emit the actual body
    if (node->body->type == NODE_BLOCK_STMT) {
        emitBlock(&node->body->as.block_stmt, node->label_id);
    } else {
        emitStatement(node->body);
    }
    writeString("\n");

    // Increment
    writeIndent();
    writeString(idx_name);
    writeString("++;\n");

    if (has_label) {
        writeIndent();
        writeString("goto ");
        writeString(label_base);
        writeString("_start;\n");
    }

    dedent();
    writeIndent();
    writeString("}\n");

    if (has_label) {
        writeIndent();
        writeString(label_base);
        writeString("_end: ;\n");
    }

    dedent();
    writeIndent();
    writeString("}\n");
}

void C89Emitter::emitWhile(const ASTWhileStmtNode* node) {
    if (!node) return;

    if (node->label) {
        char label_base[256];
        char* cur = label_base;
        size_t rem = sizeof(label_base);
        safe_append(cur, rem, "__zig_label_");
        safe_append(cur, rem, node->label);
        safe_append(cur, rem, "_");
        char id_buf[16];
        plat_i64_to_string(node->label_id, id_buf, sizeof(id_buf));
        safe_append(cur, rem, id_buf);

        writeIndent();
        writeString(label_base);
        writeString("_start: ;\n");

        writeIndent();
        writeString("if (!(");
        emitExpression(node->condition);
        writeString(")) goto ");
        writeString(label_base);
        writeString("_end;\n");

        if (node->body->type == NODE_BLOCK_STMT) {
            writeIndent();
            emitBlock(&node->body->as.block_stmt, node->label_id);
        } else {
            emitStatement(node->body);
        }
        writeString("\n");

        writeIndent();
        writeString("goto ");
        writeString(label_base);
        writeString("_start;\n");

        writeIndent();
        writeString(label_base);
        writeString("_end: ;\n");
    } else {
        writeIndent();
        writeString("while (");
        emitExpression(node->condition);
        writeString(") ");

        if (node->body->type == NODE_BLOCK_STMT) {
            emitBlock(&node->body->as.block_stmt, node->label_id);
        } else {
            emitStatement(node->body);
        }
        writeString("\n");
    }
}


bool C89Emitter::isConstantInitializer(const ASTNode* node) const {
    if (!node) return true;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
            return true;
        case NODE_PAREN_EXPR:
            return isConstantInitializer(node->as.paren_expr.expr);
        case NODE_UNARY_OP:
            if (node->as.unary_op.op == TOKEN_AMPERSAND) {
                // Address-of is constant if operand is a global variable or member of one
                ASTNode* operand = node->as.unary_op.operand;
                if (operand->type == NODE_IDENTIFIER) return true; // Assuming identifier is global
                if (operand->type == NODE_MEMBER_ACCESS) return isConstantInitializer(operand->as.member_access->base);
                if (operand->type == NODE_ARRAY_ACCESS) return isConstantInitializer(operand->as.array_access->array);
                return false;
            }
            return isConstantInitializer(node->as.unary_op.operand);
        case NODE_BINARY_OP:
            return isConstantInitializer(node->as.binary_op->left) &&
                   isConstantInitializer(node->as.binary_op->right);
        case NODE_IDENTIFIER:
            // Function names are constant addresses in C89
            if (node->resolved_type && node->resolved_type->kind == TYPE_FUNCTION) {
                return true;
            }
            // Identifiers are generally not constant initializers unless they are enum members or similar.
            // For now, we assume they might be global addresses if they are operands of '&'.
            return false;
        case NODE_PTR_CAST:
        case NODE_INT_CAST:
        case NODE_FLOAT_CAST:
            return isConstantInitializer(node->as.ptr_cast->expr); // All cast nodes have expr at same offset
        case NODE_STRUCT_INITIALIZER: {
            DynamicArray<ASTNamedInitializer*>* fields = node->as.struct_initializer->fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                if (!isConstantInitializer((*fields)[i]->value)) return false;
            }
            return true;
        }
        case NODE_MEMBER_ACCESS: {
            // Enum member access is constant
            if (node->as.member_access->base->resolved_type) {
                Type* t = node->as.member_access->base->resolved_type;
                if (t->kind == TYPE_ENUM) {
                    return true;
                }
            }
            return false;
        }
        default:
            return false;
    }
}

void C89Emitter::write(const char* data, size_t len) {
    if (len == 0) return;

    if (in_type_def_mode_) {
        if (type_def_pos_ + len > type_def_cap_) {
            // Should really reallocate, but 64KB is huge for slice typedefs.
            // For bootstrap simplicity, we'll just truncate or abort if absolutely necessary.
            len = type_def_cap_ - type_def_pos_;
            if (len == 0) return;
        }
        plat_memcpy(type_def_buffer_ + type_def_pos_, data, len);
        type_def_pos_ += len;
        last_char_ = data[len - 1];
        return;
    }

    if (output_file_ == PLAT_INVALID_FILE) return;

    if (buffer_pos_ + len > sizeof(buffer_)) {
        flush();
        // If the data is larger than the buffer itself, write it directly
        if (len > sizeof(buffer_)) {
            plat_write_file(output_file_, data, len);
            last_char_ = data[len - 1];
            return;
        }
    }

    plat_memcpy(buffer_ + buffer_pos_, data, len);
    buffer_pos_ += len;
    last_char_ = data[len - 1];
}

void C89Emitter::writeString(const char* str) {
    if (!str) return;
    write(str, plat_strlen(str));
}

void C89Emitter::emitComment(const char* text) {
    if (!text) return;
    writeIndent();
    write("/* ", 3);
    writeString(text);
    write(" */\n", 4);
}

void C89Emitter::flush() {
    if (output_file_ != PLAT_INVALID_FILE && buffer_pos_ > 0) {
        plat_write_file(output_file_, buffer_, buffer_pos_);
        buffer_pos_ = 0;
    }
}

bool C89Emitter::open(const char* path) {
    close();
    output_file_ = plat_open_file(path, true);
    owns_file_ = true;
    return isValid();
}

void C89Emitter::close() {
    flush();
    if (owns_file_ && output_file_ != PLAT_INVALID_FILE) {
        plat_close_file(output_file_);
        output_file_ = PLAT_INVALID_FILE;
    }
}

void C89Emitter::emitExpression(const ASTNode* node) {
    if (!node) return;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
            emitIntegerLiteral(&node->as.integer_literal);
            break;
        case NODE_FLOAT_LITERAL:
            emitFloatLiteral(&node->as.float_literal);
            break;
        case NODE_STRING_LITERAL:
            emitStringLiteral(&node->as.string_literal);
            break;
        case NODE_CHAR_LITERAL:
            emitCharLiteral(&node->as.char_literal);
            break;
        case NODE_BOOL_LITERAL:
            writeString(node->as.bool_literal.value ? "1" : "0");
            break;
        case NODE_NULL_LITERAL:
            writeString("((void*)0)");
            break;
        case NODE_IDENTIFIER:
            if (node->as.identifier.symbol) {
                Symbol* sym = node->as.identifier.symbol;
                if (sym->flags & SYMBOL_FLAG_LOCAL) {
                    writeString(var_alloc_.allocate(sym));
                } else if (sym->mangled_name) {
                    writeString(sym->mangled_name);
                } else {
                    writeString(getC89GlobalName(sym->name));
                }
            } else {
                writeString(getC89GlobalName(node->as.identifier.name));
            }
            break;
        case NODE_PAREN_EXPR:
            writeString("(");
            emitExpression(node->as.paren_expr.expr);
            writeString(")");
            break;
        case NODE_RANGE:
            // This should only happen if range is used outside for/slicing
            emitExpression(node->as.range.start);
            writeString(" /* .. */ ");
            emitExpression(node->as.range.end);
            break;
        case NODE_UNARY_OP:
            writeString(getTokenSpelling(node->as.unary_op.op));
            emitExpression(node->as.unary_op.operand);
            break;
        case NODE_BINARY_OP:
            emitExpression(node->as.binary_op->left);
            writeString(" ");
            writeString(getTokenSpelling(node->as.binary_op->op));
            writeString(" ");
            emitExpression(node->as.binary_op->right);
            break;
        case NODE_MEMBER_ACCESS: {
            const ASTNode* base = node->as.member_access->base;
            if (base->resolved_type) {
                Type* actual_type = base->resolved_type;

                if (actual_type->kind == TYPE_ENUM) {
                    // Enum member access: EnumName_MemberName
                    if (actual_type->c_name) {
                        writeString(actual_type->c_name);
                    } else if (actual_type->as.enum_details.name) {
                        writeString(getC89GlobalName(actual_type->as.enum_details.name));
                    } else {
                        writeString("/* anonymous enum */");
                    }
                    writeString("_");
                    writeString(node->as.member_access->field_name);
                    break;
                }

                if (actual_type->kind == TYPE_MODULE || actual_type->kind == TYPE_ANYTYPE) {
                    // Module member access
                    if (node->as.member_access->symbol && node->as.member_access->symbol->mangled_name) {
                        writeString(node->as.member_access->symbol->mangled_name);
                    } else {
                        const char* mod_name = (actual_type->kind == TYPE_MODULE) ?
                                              actual_type->as.module.name :
                                              (base->type == NODE_IDENTIFIER ? base->as.identifier.name : NULL);
                        if (mod_name) {
                            writeString("z_");
                            writeString(mod_name);
                            writeString("_");
                            writeString(node->as.member_access->field_name);
                        } else {
                            writeString(node->as.member_access->field_name);
                        }
                    }
                    break;
                }
            }

            bool need_parens = requiresParentheses(base);
            if (need_parens) writeString("(");
            emitExpression(base);
            if (need_parens) writeString(")");

            // Auto-dereference for pointer to struct:
            // if base is a pointer, use ->, else use .
            if (base->resolved_type && base->resolved_type->kind == TYPE_POINTER) {
                writeString("->");
            } else {
                writeString(".");
            }
            writeString(node->as.member_access->field_name);
            break;
        }
        case NODE_ARRAY_SLICE:
            emitArraySlice(node);
            break;
        case NODE_ARRAY_ACCESS: {
            const ASTNode* array_node = node->as.array_access->array;
            Type* array_type = array_node->resolved_type;
            bool is_ptr_to_array = (array_type && array_type->kind == TYPE_POINTER &&
                                    array_type->as.pointer.base->kind == TYPE_ARRAY);

            if (is_ptr_to_array) {
                writeString("(*");
            }

            bool need_parens = requiresParentheses(array_node);
            if (need_parens) writeString("(");
            emitExpression(array_node);
            if (need_parens) writeString(")");

            if (is_ptr_to_array) {
                writeString(")");
            }

            writeString("[");
            emitExpression(node->as.array_access->index);
            writeString("]");
            break;
        }
        case NODE_PTR_CAST:
            writeString("(");
            emitType(node->as.ptr_cast->target_type->resolved_type);
            writeString(")");
            emitExpression(node->as.ptr_cast->expr);
            break;
        case NODE_INT_CAST:
            emitIntCast(node->as.numeric_cast);
            break;
        case NODE_IMPORT_STMT:
            writeString("/* import \"");
            writeString(node->as.import_stmt->module_name);
            writeString("\" */");
            break;
        case NODE_FLOAT_CAST:
            emitFloatCast(node->as.numeric_cast);
            break;
        case NODE_FUNCTION_CALL: {
            const ASTFunctionCallNode* call = node->as.function_call;
            bool need_parens = requiresParentheses(call->callee);
            if (need_parens) writeString("(");
            emitExpression(call->callee);
            if (need_parens) writeString(")");

            writeString("(");
            if (call->args) {
                for (size_t i = 0; i < call->args->length(); ++i) {
                    emitExpression((*call->args)[i]);
                    if (i < call->args->length() - 1) {
                        writeString(", ");
                    }
                }
            }
            writeString(")");
            break;
        }
        case NODE_ASSIGNMENT:
            if (node->as.assignment->lvalue->type == NODE_IDENTIFIER &&
                plat_strcmp(node->as.assignment->lvalue->as.identifier.name, "_") == 0) {
                writeString("(void)(");
                emitExpression(node->as.assignment->rvalue);
                writeString(")");
            } else {
                emitExpression(node->as.assignment->lvalue);
                writeString(" = ");
                emitExpression(node->as.assignment->rvalue);
            }
            break;
        case NODE_COMPOUND_ASSIGNMENT:
            emitExpression(node->as.compound_assignment->lvalue);
            writeString(" ");
            writeString(getTokenSpelling(node->as.compound_assignment->op));
            writeString(" ");
            emitExpression(node->as.compound_assignment->rvalue);
            break;
        case NODE_STRUCT_INITIALIZER: {
            writeString("{");
            Type* struct_type = node->resolved_type;
            if (struct_type && struct_type->kind == TYPE_STRUCT) {
                DynamicArray<StructField>* type_fields = struct_type->as.struct_details.fields;
                DynamicArray<ASTNamedInitializer*>* init_fields = node->as.struct_initializer->fields;

                for (size_t i = 0; i < type_fields->length(); ++i) {
                    const char* field_name = (*type_fields)[i].name;
                    // Find this field in the initializer
                    bool found = false;
                    for (size_t j = 0; j < init_fields->length(); ++j) {
                        if (plat_strcmp((*init_fields)[j]->field_name, field_name) == 0) {
                            emitExpression((*init_fields)[j]->value);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        writeString("0"); // Fallback for missing fields if allowed
                    }
                    if (i < type_fields->length() - 1) {
                        writeString(", ");
                    }
                }
            } else {
                // Fallback if type info is missing
                DynamicArray<ASTNamedInitializer*>* fields = node->as.struct_initializer->fields;
                for (size_t i = 0; i < fields->length(); ++i) {
                    emitExpression((*fields)[i]->value);
                    if (i < fields->length() - 1) {
                        writeString(", ");
                    }
                }
            }
            writeString("}");
            break;
        }
        default:
            writeString("/* [Unimplemented Expression Type ");
            char num[16];
            plat_i64_to_string(node->type, num, sizeof(num));
            writeString(num);
            writeString("] */");
            break;
    }
}

void C89Emitter::emitArraySlice(const ASTNode* node) {
    if (!node || node->type != NODE_ARRAY_SLICE) return;
    const ASTArraySliceNode* slice = node->as.array_slice;
    if (!slice || !slice->base_ptr || !slice->len) return;

    Type* result_type = node->resolved_type;
    if (!result_type || result_type->kind != TYPE_SLICE) return;

    Type* elem_type = result_type->as.slice.element_type;

    ensureSliceType(result_type);

    writeString("__make_slice_");
    writeString(getMangledTypeName(elem_type));
    writeString("(");
    emitExpression(slice->base_ptr);
    writeString(", ");
    emitExpression(slice->len);
    writeString(")");
}

void C89Emitter::ensureSliceType(Type* type) {
    if (!type || type->kind != TYPE_SLICE) return;

    const char* mangled_name = getMangledTypeName(type);

    // Check internal cache
    for (size_t i = 0; i < emitted_slices_.length(); ++i) {
        if (plat_strcmp(emitted_slices_[i], mangled_name) == 0) return;
    }

    // Check external cache (if any)
    if (external_cache_) {
        for (size_t j = 0; j < external_cache_->length(); ++j) {
            if (plat_strcmp((*external_cache_)[j], mangled_name) == 0) return;
        }
    }

    // Not emitted, so emit it now
    emitted_slices_.append(mangled_name);
    if (external_cache_) {
        external_cache_->append(mangled_name);
    }

    bool was_in_type_def = in_type_def_mode_;
    in_type_def_mode_ = true;

    Type* elem_type = type->as.slice.element_type;
    const char* slice_struct_name = mangled_name;

    writeIndent();
    writeString("typedef struct { ");
    emitType(elem_type);
    writeString("* ptr; usize len; } ");
    writeString(slice_struct_name);
    writeString(";\n");

    // Emit helper: static inline Slice_T __make_slice_T(T* ptr, usize len)
    writeIndent();
    writeString("static RETR_UNUSED_FUNC ");
    writeString(slice_struct_name);
    writeString(" __make_slice_");
    writeString(getMangledTypeName(elem_type));
    writeString("(");
    emitType(elem_type);
    writeString("* ptr, usize len) {\n");
    indent();
    writeIndent();
    writeString(slice_struct_name);
    writeString(" s;\n");
    writeIndent();
    writeString("s.ptr = ptr;\n");
    writeIndent();
    writeString("s.len = len;\n");
    writeIndent();
    writeString("return s;\n");
    dedent();
    writeIndent();
    writeString("}\n\n");

    in_type_def_mode_ = was_in_type_def;
}

void C89Emitter::emitBufferedSliceDefinitions() {
    if (type_def_pos_ > 0) {
        write(type_def_buffer_, type_def_pos_);
        type_def_pos_ = 0;
    }
}

void C89Emitter::emitTypeDefinition(const ASTNode* node) {
    if (!node) return;

    if (node->type == NODE_VAR_DECL) {
        // plat_print_debug("emitTypeDefinition: var_decl\n");
        const ASTVarDeclNode* decl = node->as.var_decl;
        if (!decl || !decl->initializer) return;

        Type* type = decl->initializer->resolved_type;
        if (!type) return;

        // Only emit definition if this is a type declaration (e.g. const T = struct { ... })
        // In our current TypeChecker, these might not have TYPE_TYPE yet, but the initializer
        // will have the actual composite type.
        if (!decl->is_const || (type->kind != TYPE_STRUCT && type->kind != TYPE_UNION && type->kind != TYPE_ENUM)) {
            return;
        }
        if (type->kind == TYPE_STRUCT) {
            if (!type->c_name) {
                type->c_name = getC89GlobalName(decl->name);
            }
            writeIndent();
            writeString("struct ");
            writeString(type->c_name);
            writeString(" {\n");
            indent();
            DynamicArray<StructField>* fields = type->as.struct_details.fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                writeIndent();
                emitType((*fields)[i].type, (*fields)[i].name);
                writeString(";\n");
            }
            dedent();
            writeIndent();
            writeString("};\n\n");
        } else if (type->kind == TYPE_UNION) {
            if (!type->c_name) {
                type->c_name = getC89GlobalName(decl->name);
            }
            writeIndent();
            writeString("union ");
            writeString(type->c_name);
            writeString(" {\n");
            indent();
            DynamicArray<StructField>* fields = type->as.struct_details.fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                writeIndent();
                emitType((*fields)[i].type, (*fields)[i].name);
                writeString(";\n");
            }
            dedent();
            writeIndent();
            writeString("};\n\n");
        } else if (type->kind == TYPE_ENUM) {
            // C89 doesn't support specific backing types for enums, they are always int.
            // But we can emit a typedef if needed.
            if (!type->c_name) {
                type->c_name = getC89GlobalName(decl->name);
            }
            writeIndent();
            writeString("enum ");
            const char* enum_name = type->c_name;
            writeString(enum_name);
            writeString(" {\n");
            indent();
            DynamicArray<EnumMember>* members = type->as.enum_details.members;
            for (size_t i = 0; i < members->length(); ++i) {
                writeIndent();
                writeString(enum_name);
                writeString("_");
                writeString((*members)[i].name);
                writeString(" = ");
                char buf[32];
                plat_i64_to_string((*members)[i].value, buf, sizeof(buf));
                writeString(buf);
                if (i < members->length() - 1) {
                    writeString(",");
                }
                writeString("\n");
            }
            dedent();
            writeIndent();
            writeString("};\n");
            writeIndent();
            writeString("typedef enum ");
            writeString(enum_name);
            writeString(" ");
            writeString(enum_name);
            writeString(";\n\n");
        }
    }
}

void C89Emitter::emitIntCast(const ASTNumericCastNode* node) {
    if (!node || !node->expr || !node->target_type) return;

    Type* src_type = node->expr->resolved_type;
    Type* dest_type = node->target_type->resolved_type;

    if (!src_type || !dest_type) {
        plat_print_debug("Error: Missing type info in @intCast\n");
        plat_abort();
    }

    if (isSafeWidening(src_type, dest_type)) {
        writeString("(");
        emitType(dest_type);
        writeString(")");
        emitExpression(node->expr);
    } else {
        writeString("__bootstrap_");
        writeString(getZigTypeName(dest_type));
        writeString("_from_");
        writeString(getZigTypeName(src_type));
        writeString("(");
        emitExpression(node->expr);
        writeString(")");
    }
}

void C89Emitter::emitFloatCast(const ASTNumericCastNode* node) {
    if (!node || !node->expr || !node->target_type) return;

    Type* src_type = node->expr->resolved_type;
    Type* dest_type = node->target_type->resolved_type;

    if (!src_type || !dest_type) {
        plat_print_debug("Error: Missing type info in @floatCast\n");
        plat_abort();
    }

    if (isSafeWidening(src_type, dest_type)) {
        writeString("(");
        emitType(dest_type);
        writeString(")");
        emitExpression(node->expr);
    } else {
        writeString("__bootstrap_");
        writeString(getZigTypeName(dest_type));
        writeString("_from_");
        writeString(getZigTypeName(src_type));
        writeString("(");
        emitExpression(node->expr);
        writeString(")");
    }
}

void C89Emitter::emitIntegerLiteral(const ASTIntegerLiteralNode* node) {
    if (node->original_name && node->resolved_type && node->resolved_type->kind == TYPE_ENUM) {
        if (node->resolved_type->c_name) {
            writeString(node->resolved_type->c_name);
        } else if (node->resolved_type->as.enum_details.name) {
            writeString(getC89GlobalName(node->resolved_type->as.enum_details.name));
        } else {
            writeString("/* anonymous enum */");
        }
        writeString("_");
        writeString(node->original_name);
        return;
    }

    char buf[32];
    plat_u64_to_string(node->value, buf, sizeof(buf));
    writeString(buf);

    if (node->resolved_type) {
        switch (node->resolved_type->kind) {
            case TYPE_U32:
                writeString("U");
                break;
            case TYPE_I64:
                writeString("i64");
                break;
            case TYPE_U64:
                writeString("ui64");
                break;
            default:
                // i32, u8, i8, u16, i16, usize, isize get no suffix
                break;
        }
    }
}

void C89Emitter::emitFloatLiteral(const ASTFloatLiteralNode* node) {
    char buffer[64];
    plat_float_to_string(node->value, buffer, sizeof(buffer));

    // Ensure it's treated as a float by C (add .0 if no '.' or 'e')
    bool has_dot = false;
    bool has_exp = false;
    for (char* p = buffer; *p; ++p) {
        if (*p == '.') has_dot = true;
        if (*p == 'e' || *p == 'E') has_exp = true;
    }

    writeString(buffer);
    if (!has_dot && !has_exp) {
        writeString(".0");
    }

    if (node->resolved_type && node->resolved_type->kind == TYPE_F32) {
        writeString("f");
    }
}

void C89Emitter::emitStringLiteral(const ASTStringLiteralNode* node) {
    if (!node || !node->value) return;

    // TODO: Split long strings if needed for MSVC 6.0
    write("\"", 1);
    const char* p = node->value;
    while (*p) {
        emitEscapedByte((unsigned char)*p, false);
        p++;
    }
    write("\"", 1);
}

void C89Emitter::emitCharLiteral(const ASTCharLiteralNode* node) {
    if (!node) return;
    write("'", 1);
    emitEscapedByte((unsigned char)node->value, true);
    write("'", 1);
}

const char* C89Emitter::getC89GlobalName(const char* zig_name) {
    if (!zig_name) return "z_anonymous";

    // Check cache first
    for (size_t i = 0; i < global_names_.length(); ++i) {
        if (plat_strcmp(global_names_[i].zig_name, zig_name) == 0) {
            return global_names_[i].c89_name;
        }
    }

    char buf[256];
    char* cur = buf;
    size_t rem = sizeof(buf);

    if (module_name_ && plat_strcmp(module_name_, "main") != 0 &&
        plat_strcmp(module_name_, "test") != 0 && plat_strcmp(zig_name, "main") != 0) {
        safe_append(cur, rem, "z_");
        safe_append(cur, rem, module_name_);
        safe_append(cur, rem, "_");
    } else if (isCKeyword(zig_name)) {
        safe_append(cur, rem, "z_");
    }
    safe_append(cur, rem, zig_name);

    // Sanitize (handles remaining invalid characters and starting digits)
    sanitizeForC89(buf);

    // Truncate to 31 characters for C89/MSVC 6.0
    if (plat_strlen(buf) > 31) {
        buf[31] = '\0';
    }

    // Ensure uniqueness within this translation unit
    char final_buf[256];
    plat_strcpy(final_buf, buf);
    int suffix = 0;
    bool unique = false;

    while (!unique) {
        unique = true;
        for (size_t i = 0; i < global_names_.length(); ++i) {
            if (plat_strcmp(global_names_[i].c89_name, final_buf) == 0) {
                unique = false;
                break;
            }
        }

        if (!unique) {
            suffix++;
            char suffix_str[16];
            plat_i64_to_string(suffix, suffix_str, sizeof(suffix_str));
            size_t suffix_len = plat_strlen(suffix_str);
            size_t base_len = plat_strlen(buf);

            if (base_len + suffix_len > 31) {
                size_t truncate_at = 31 - suffix_len;
                plat_strncpy(final_buf, buf, truncate_at);
                final_buf[truncate_at] = '\0';
                plat_strcat(final_buf, suffix_str);
            } else {
                plat_strcpy(final_buf, buf);
                plat_strcat(final_buf, suffix_str);
            }
        }
    }

    size_t len = plat_strlen(final_buf);
    char* owned_name = (char*)arena_.alloc(len + 1);
    plat_memcpy(owned_name, final_buf, len + 1);

    GlobalNameEntry entry;
    entry.zig_name = zig_name;
    entry.c89_name = owned_name;
    global_names_.append(entry);

    return owned_name;
}

bool C89Emitter::requiresParentheses(const ASTNode* node) const {
    if (!node) return false;
    switch (node->type) {
        // Postfix and primary expressions (Level 1 in C)
        case NODE_IDENTIFIER:
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
        case NODE_PAREN_EXPR:
        case NODE_FUNCTION_CALL:
        case NODE_ARRAY_ACCESS:
        case NODE_MEMBER_ACCESS:
            return false;

        // Everything else has lower precedence than postfix operators
        default:
            return true;
    }
}

bool C89Emitter::isSafeWidening(Type* src, Type* dest) const {
    if (!src || !dest) return false;

    // Integer widening
    bool src_is_int = (src->kind >= TYPE_I8 && src->kind <= TYPE_U64) || src->kind == TYPE_ISIZE || src->kind == TYPE_USIZE;
    bool dest_is_int = (dest->kind >= TYPE_I8 && dest->kind <= TYPE_U64) || dest->kind == TYPE_ISIZE || dest->kind == TYPE_USIZE;

    if (src_is_int && dest_is_int) {
        // Signedness must match
        bool src_signed = (src->kind == TYPE_I8 || src->kind == TYPE_I16 || src->kind == TYPE_I32 || src->kind == TYPE_I64 || src->kind == TYPE_ISIZE);
        bool dest_signed = (dest->kind == TYPE_I8 || dest->kind == TYPE_I16 || dest->kind == TYPE_I32 || dest->kind == TYPE_I64 || dest->kind == TYPE_ISIZE);

        if (src_signed != dest_signed) return false;

        // Size must be non-decreasing
        return dest->size >= src->size;
    }

    // Float widening
    if (src->kind == TYPE_F32 || src->kind == TYPE_F64) {
        if (dest->kind == TYPE_F32 || dest->kind == TYPE_F64) {
            return dest->size >= src->size;
        }
    }

    return false;
}

const char* C89Emitter::getZigTypeName(Type* type) const {
    if (!type) return "unknown";
    switch (type->kind) {
        case TYPE_VOID: return "void";
        case TYPE_BOOL: return "bool";
        case TYPE_I8:   return "i8";
        case TYPE_U8:   return "u8";
        case TYPE_I16:  return "i16";
        case TYPE_U16:  return "u16";
        case TYPE_I32:  return "i32";
        case TYPE_U32:  return "u32";
        case TYPE_I64:  return "i64";
        case TYPE_U64:  return "u64";
        case TYPE_F32:  return "f32";
        case TYPE_F64:  return "f64";
        case TYPE_ISIZE: return "isize";
        case TYPE_USIZE: return "usize";
        default: return "unknown";
    }
}

const char* C89Emitter::getMangledTypeName(Type* type) {
    if (!type) return "void";

    char buf[1024];
    char* cur = buf;
    size_t rem = sizeof(buf);

    switch (type->kind) {
        case TYPE_VOID: safe_append(cur, rem, "void"); break;
        case TYPE_BOOL: safe_append(cur, rem, "bool"); break;
        case TYPE_I8:   safe_append(cur, rem, "i8"); break;
        case TYPE_U8:   safe_append(cur, rem, "u8"); break;
        case TYPE_I16:  safe_append(cur, rem, "i16"); break;
        case TYPE_U16:  safe_append(cur, rem, "u16"); break;
        case TYPE_I32:  safe_append(cur, rem, "i32"); break;
        case TYPE_U32:  safe_append(cur, rem, "u32"); break;
        case TYPE_I64:  safe_append(cur, rem, "i64"); break;
        case TYPE_U64:  safe_append(cur, rem, "u64"); break;
        case TYPE_F32:  safe_append(cur, rem, "f32"); break;
        case TYPE_F64:  safe_append(cur, rem, "f64"); break;
        case TYPE_ISIZE: safe_append(cur, rem, "isize"); break;
        case TYPE_USIZE: safe_append(cur, rem, "usize"); break;
        case TYPE_POINTER:
            safe_append(cur, rem, "Ptr_");
            safe_append(cur, rem, getMangledTypeName(type->as.pointer.base));
            break;
        case TYPE_SLICE:
            safe_append(cur, rem, "Slice_");
            safe_append(cur, rem, getMangledTypeName(type->as.slice.element_type));
            break;
        case TYPE_ARRAY: {
            safe_append(cur, rem, "Arr_");
            char size_buf[32];
            plat_u64_to_string(type->as.array.size, size_buf, sizeof(size_buf));
            safe_append(cur, rem, size_buf);
            safe_append(cur, rem, "_");
            safe_append(cur, rem, getMangledTypeName(type->as.array.element_type));
            break;
        }
        case TYPE_FUNCTION:
        case TYPE_FUNCTION_POINTER: {
            safe_append(cur, rem, "Fn_");
            Type* ret = (type->kind == TYPE_FUNCTION) ? type->as.function.return_type : type->as.function_pointer.return_type;
            safe_append(cur, rem, getMangledTypeName(ret));
            DynamicArray<Type*>* params = (type->kind == TYPE_FUNCTION) ? type->as.function.params : type->as.function_pointer.param_types;
            if (params) {
                for (size_t i = 0; i < params->length(); ++i) {
                    safe_append(cur, rem, "_");
                    safe_append(cur, rem, getMangledTypeName((*params)[i]));
                }
            }
            break;
        }
        case TYPE_STRUCT:
        case TYPE_UNION:
        case TYPE_ENUM: {
            const char* name = NULL;
            if (type->kind == TYPE_ENUM) name = type->as.enum_details.name;
            else name = type->as.struct_details.name;

            if (type->c_name) {
                safe_append(cur, rem, type->c_name);
            } else if (name) {
                safe_append(cur, rem, getC89GlobalName(name));
            } else {
                safe_append(cur, rem, "anon");
            }
            break;
        }
        default:
            safe_append(cur, rem, "unknown");
            break;
    }

    return unit_.getStringInterner().intern(buf);
}

void C89Emitter::emitEscapedByte(unsigned char c, bool is_char_literal) {
    switch (c) {
        case '\a': write("\\a", 2); return;
        case '\b': write("\\b", 2); return;
        case '\f': write("\\f", 2); return;
        case '\n': write("\\n", 2); return;
        case '\r': write("\\r", 2); return;
        case '\t': write("\\t", 2); return;
        case '\v': write("\\v", 2); return;
        case '\\': write("\\\\", 2); return;
        case '\'':
            if (is_char_literal) write("\\'", 2);
            else write("'", 1);
            return;
        case '\"':
            if (!is_char_literal) write("\\\"", 2);
            else write("\"", 1);
            return;
        default:
            if (c >= 32 && c <= 126) {
                char ch = (char)c;
                write(&ch, 1);
            } else {
                char buf[8];
                // Use octal escape \ooo (three digits zero-padded)
                buf[0] = '\\';
                buf[1] = (char)((c >> 6) & 7) + '0';
                buf[2] = (char)((c >> 3) & 7) + '0';
                buf[3] = (char)(c & 7) + '0';
                buf[4] = '\0';
                writeString(buf);
            }
    }
}

void C89Emitter::emitDefersForScopeExit(int target_label_id) {
    for (int i = (int)defer_stack_.length() - 1; i >= 0; --i) {
        DeferScope* scope = defer_stack_[i];
        for (int j = (int)scope->defers.length() - 1; j >= 0; --j) {
            emitStatement(scope->defers[j]->statement);
        }
        if (target_label_id != -1 && scope->label_id == target_label_id) {
            break;
        }
    }
}

void C89Emitter::emitBreak(const ASTBreakStmtNode* node) {
    writeIndent();
    if (defer_stack_.length() > 0) {
        writeString("/* defers for break */\n");
        emitDefersForScopeExit(node->target_label_id);
        writeIndent();
    }

    if (node->label) {
        char label_buf[256];
        char* cur = label_buf;
        size_t rem = sizeof(label_buf);
        safe_append(cur, rem, "goto __zig_label_");
        safe_append(cur, rem, node->label);
        safe_append(cur, rem, "_");
        char id_buf[16];
        plat_i64_to_string(node->target_label_id, id_buf, sizeof(id_buf));
        safe_append(cur, rem, id_buf);
        safe_append(cur, rem, "_end;\n");
        writeString(label_buf);
    } else {
        writeString("break;\n");
    }
}

void C89Emitter::emitContinue(const ASTContinueStmtNode* node) {
    writeIndent();
    if (defer_stack_.length() > 0) {
        writeString("/* defers for continue */\n");
        emitDefersForScopeExit(node->target_label_id);
        writeIndent();
    }

    if (node->label) {
        char label_buf[256];
        char* cur = label_buf;
        size_t rem = sizeof(label_buf);
        safe_append(cur, rem, "goto __zig_label_");
        safe_append(cur, rem, node->label);
        safe_append(cur, rem, "_");
        char id_buf[16];
        plat_i64_to_string(node->target_label_id, id_buf, sizeof(id_buf));
        safe_append(cur, rem, id_buf);
        safe_append(cur, rem, "_start;\n");
        writeString(label_buf);
    } else {
        writeString("continue;\n");
    }
}

void C89Emitter::emitReturn(const ASTReturnStmtNode* node) {
    if (!node) return;

    bool has_defers = false;
    for (size_t i = 0; i < defer_stack_.length(); ++i) {
        if (defer_stack_[i]->defers.length() > 0) {
            has_defers = true;
            break;
        }
    }

    if (has_defers) {
        writeIndent();
        writeString("{\n");
        indent();

        if (node->expression && current_fn_ret_type_->kind != TYPE_VOID) {
            writeIndent();
            emitType(current_fn_ret_type_, "__return_val");
            writeString(" = ");
            emitExpression(node->expression);
            writeString(";\n");

            emitDefersForScopeExit(-1);

            writeIndent();
            writeString("return __return_val;\n");
        } else {
            if (node->expression) {
                writeIndent();
                emitExpression(node->expression);
                writeString(";\n");
            }
            emitDefersForScopeExit(-1);
            writeIndent();
            writeString("return;\n");
        }

        dedent();
        writeIndent();
        writeString("}\n");
    } else {
        writeIndent();
        if (node->expression) {
            writeString("return ");
            emitExpression(node->expression);
            writeString(";\n");
        } else {
            writeString("return;\n");
        }
    }
}
