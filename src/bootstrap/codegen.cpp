#include "codegen.hpp"
#include "compilation_unit.hpp"
#include "ast_utils.hpp"
#include <new>
#include "platform.hpp"
#include "utils.hpp"
#include "symbol_table.hpp"

static const size_t TYPE_DEF_BUFFER_SIZE = 131072;

C89Emitter::C89Emitter(CompilationUnit& unit)
    : buffer_pos_(0), output_file_(PLAT_INVALID_FILE), indent_level_(0), owns_file_(false),
      unit_(unit), var_alloc_(unit.getArena()), error_handler_(unit.getErrorHandler()), arena_(unit.getArena()), global_names_(unit.getArena()),
      emitted_slices_(unit.getArena()), emitted_error_unions_(unit.getArena()), emitted_optionals_(unit.getArena()), external_cache_(&unit.getEmittedTypesCache()),
      defer_stack_(unit.getArena()), current_fn_ret_type_(NULL),
      type_def_buffer_(NULL), type_def_pos_(0), type_def_cap_(TYPE_DEF_BUFFER_SIZE), in_type_def_mode_(false),
      module_name_(NULL), last_char_('\0'), for_loop_counter_(0), current_loc_() {
    type_def_buffer_ = (char*)arena_.alloc(type_def_cap_);
}

C89Emitter::C89Emitter(CompilationUnit& unit, const char* path)
    : buffer_pos_(0), indent_level_(0), owns_file_(true),
      unit_(unit), var_alloc_(unit.getArena()), error_handler_(unit.getErrorHandler()), arena_(unit.getArena()), global_names_(unit.getArena()),
      emitted_slices_(unit.getArena()), emitted_error_unions_(unit.getArena()), emitted_optionals_(unit.getArena()), external_cache_(&unit.getEmittedTypesCache()),
      defer_stack_(unit.getArena()), current_fn_ret_type_(NULL),
      type_def_buffer_(NULL), type_def_pos_(0), type_def_cap_(TYPE_DEF_BUFFER_SIZE), in_type_def_mode_(false),
      module_name_(NULL), last_char_('\0'), for_loop_counter_(0), current_loc_() {
    output_file_ = plat_open_file(path, true);
    type_def_buffer_ = (char*)arena_.alloc(type_def_cap_);
}


C89Emitter::C89Emitter(CompilationUnit& unit, PlatFile file)
    : buffer_pos_(0), output_file_(file), indent_level_(0), owns_file_(false),
      unit_(unit), var_alloc_(unit.getArena()), error_handler_(unit.getErrorHandler()), arena_(unit.getArena()), global_names_(unit.getArena()),
      emitted_slices_(unit.getArena()), emitted_error_unions_(unit.getArena()), emitted_optionals_(unit.getArena()), external_cache_(&unit.getEmittedTypesCache()),
      defer_stack_(unit.getArena()), current_fn_ret_type_(NULL),
      type_def_buffer_(NULL), type_def_pos_(0), type_def_cap_(TYPE_DEF_BUFFER_SIZE), in_type_def_mode_(false),
      module_name_(NULL), last_char_('\0'), for_loop_counter_(0), current_loc_() {
    type_def_buffer_ = (char*)arena_.alloc(type_def_cap_);
}

C89Emitter::~C89Emitter() {
    close();
}

void C89Emitter::indent() {
    indent_level_++;
}

void C89Emitter::dedent() {
    if (indent_level_ > 0) {
        indent_level_--;
    }
}

void C89Emitter::writeIndent() {
    for (int i = 0; i < indent_level_; ++i) {
        write("    ", 4);
    }
}

void C89Emitter::emitPrologue() {
    emitComment("Generated by RetroZig bootstrap compiler");
    writeString("#include \"zig_runtime.h\"\n\n");

    // Emit error tag constants
    const DynamicArray<ErrorTag>& tags = unit_.getGlobalErrorRegistry().getTags();
    if (tags.length() > 0) {
        emitComment("Error tags");
        for (size_t i = 0; i < tags.length(); ++i) {
            char buffer[512];
            char* ptr = buffer;
            size_t remaining = sizeof(buffer);
            safe_append(ptr, remaining, "#define ERROR_");
            safe_append(ptr, remaining, tags[i].name);
            safe_append(ptr, remaining, " ");
            char id_buf[16];
            plat_i64_to_string(tags[i].id, id_buf, sizeof(id_buf));
            safe_append(ptr, remaining, id_buf);
            safe_append(ptr, remaining, "\n");
            writeString(buffer);
        }
        writeString("\n");
    }
}

void C89Emitter::beginFunction() {
    var_alloc_.reset();
    for_loop_counter_ = 0;
}

void C89Emitter::emitType(Type* type, const char* name) {
    emitDeclarator(type, name);
}

void C89Emitter::emitDeclarator(Type* type, const char* name, const ASTFnDeclNode* params_node) {
    emitTypePrefix(type);
    if (name) {
        if (last_char_ != '(' && last_char_ != ' ') {
            writeString(" ");
        }
        writeString(name);
    }

    if (params_node) {
        writeString("(");
        if (!params_node->params || params_node->params->length() == 0) {
            writeString("void");
        } else {
            for (size_t i = 0; i < params_node->params->length(); ++i) {
                ASTParamDeclNode* param = (*params_node->params)[i];
                if (param->is_anytype) {
                    writeString("...");
                    break;
                }
                // For definition (within FnDecl), use mangled local name.
                // For prototype, use original name.
                const char* param_name = param->symbol ? var_alloc_.allocate(param->symbol) : param->name;
                emitDeclarator(param->type->resolved_type, param_name);
                if (i < params_node->params->length() - 1) {
                    writeString(", ");
                }
            }
        }
        writeString(")");
    }

    emitTypeSuffix(type);
}

void C89Emitter::emitTypePrefix(Type* type) {
    if (!type) {
        writeString("void");
        return;
    }

    switch (type->kind) {
        case TYPE_POINTER:
            emitTypePrefix(type->as.pointer.base);
            if (type->as.pointer.base->kind != TYPE_POINTER &&
                (type->as.pointer.base->kind == TYPE_ARRAY ||
                 type->as.pointer.base->kind == TYPE_FUNCTION_POINTER ||
                 type->as.pointer.base->kind == TYPE_FUNCTION)) {
                writeString(" (*");
            } else {
                writeString("*");
            }
            break;
        case TYPE_ARRAY:
            emitTypePrefix(type->as.array.element_type);
            break;
        case TYPE_FUNCTION:
            emitTypePrefix(type->as.function.return_type);
            break;
        case TYPE_FUNCTION_POINTER:
            emitTypePrefix(type->as.function_pointer.return_type);
            writeString(" (*");
            break;
        default:
            emitBaseType(type);
            break;
    }
}

void C89Emitter::emitTypeSuffix(Type* type) {
    if (!type) return;

    switch (type->kind) {
        case TYPE_POINTER:
            if (type->as.pointer.base->kind != TYPE_POINTER &&
                (type->as.pointer.base->kind == TYPE_ARRAY ||
                 type->as.pointer.base->kind == TYPE_FUNCTION_POINTER ||
                 type->as.pointer.base->kind == TYPE_FUNCTION)) {
                writeString(")");
            }
            emitTypeSuffix(type->as.pointer.base);
            break;
        case TYPE_ARRAY: {
            char buf[32];
            writeString("[");
            plat_u64_to_string(type->as.array.size, buf, sizeof(buf));
            writeString(buf);
            writeString("]");
            emitTypeSuffix(type->as.array.element_type);
            break;
        }
        case TYPE_FUNCTION: {
            writeString("(");
            DynamicArray<Type*>* params = type->as.function.params;
            if (!params || params->length() == 0) {
                writeString("void");
            } else {
                for (size_t i = 0; i < params->length(); ++i) {
                    if ((*params)[i]->kind == TYPE_ANYTYPE) {
                        writeString("...");
                        break;
                    }
                    emitDeclarator((*params)[i], NULL);
                    if (i < params->length() - 1) writeString(", ");
                }
            }
            writeString(")");
            emitTypeSuffix(type->as.function.return_type);
            break;
        }
        case TYPE_FUNCTION_POINTER: {
            writeString(")");
            writeString("(");
            DynamicArray<Type*>* params = type->as.function_pointer.param_types;
            if (!params || params->length() == 0) {
                writeString("void");
            } else {
                for (size_t i = 0; i < params->length(); ++i) {
                    emitDeclarator((*params)[i], NULL);
                    if (i < params->length() - 1) writeString(", ");
                }
            }
            writeString(")");
            emitTypeSuffix(type->as.function_pointer.return_type);
            break;
        }
        default:
            break;
    }
}

void C89Emitter::emitBaseType(Type* type) {
    if (!type) {
        writeString("void");
        return;
    }

    switch (type->kind) {
        case TYPE_VOID: writeString("void"); break;
        case TYPE_BOOL: writeString("int"); break;
        case TYPE_I8: writeString("signed char"); break;
        case TYPE_U8: writeString("unsigned char"); break;
        case TYPE_I16: writeString("short"); break;
        case TYPE_U16: writeString("unsigned short"); break;
        case TYPE_I32: writeString("int"); break;
        case TYPE_U32: writeString("unsigned int"); break;
        case TYPE_I64: writeString("__int64"); break;
        case TYPE_U64: writeString("unsigned __int64"); break;
        case TYPE_F32: writeString("float"); break;
        case TYPE_F64: writeString("double"); break;
        case TYPE_ISIZE: writeString("int"); break;
        case TYPE_USIZE: writeString("unsigned int"); break;
        case TYPE_SLICE:
            ensureSliceType(type);
            writeString(getMangledTypeName(type));
            break;
        case TYPE_ERROR_UNION:
            ensureErrorUnionType(type);
            writeString(getMangledTypeName(type));
            break;
        case TYPE_OPTIONAL:
            ensureOptionalType(type);
            writeString(getMangledTypeName(type));
            break;
        case TYPE_ERROR_SET:
            writeString("int");
            break;
        case TYPE_STRUCT:
            writeString("struct ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_UNION:
            writeString("union ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_ENUM:
            writeString("enum ");
            if (!type->c_name && type->as.enum_details.name) {
                type->c_name = getC89GlobalName(type->as.enum_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_ANYTYPE:
            writeString("...");
            break;
        default:
            writeString("/* unsupported type */");
            break;
    }
}

void C89Emitter::emitGlobalVarDecl(const ASTNode* node, bool is_public) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    // Use flags from node, but allow override from is_public for now to avoid breaking tests
    bool external = is_public || decl->is_pub || decl->is_extern || decl->is_export;

    // Skip type and module declarations (e.g. const T = struct { ... } or const std = @import("std"))
    if (decl->initializer && decl->initializer->resolved_type) {
        Type* init_type = decl->initializer->resolved_type;
        if (init_type->kind == TYPE_MODULE ||
            (decl->is_const && (init_type->kind == TYPE_STRUCT || init_type->kind == TYPE_UNION || init_type->kind == TYPE_ENUM))) {
            return;
        }
    }

    if (decl->initializer && !isConstantInitializer(decl->initializer)) {
        error_handler_.report(ERR_GLOBAL_VAR_NON_CONSTANT_INIT, decl->name_loc, ErrorHandler::getMessage(ERR_GLOBAL_VAR_NON_CONSTANT_INIT), "Try using a literal or a constant expression");
        return;
    }

    writeIndent();
    if (decl->is_extern) {
        writeString("extern ");
    } else if (!external) {
        writeString("static ");
    }

    Type* type = node->resolved_type;
    const char* c_name = getC89GlobalName(decl->name);

    emitDeclarator(type, c_name);

    if (decl->initializer) {
        writeString(" = ");
        emitExpression(decl->initializer);
    }

    writeString(";\n");
}

void C89Emitter::emitInitializerAssignments(const char* base_name, const ASTNode* init_node) {
    if (!init_node || init_node->type != NODE_STRUCT_INITIALIZER) return;
    const ASTStructInitializerNode* init = init_node->as.struct_initializer;
    Type* type = init_node->resolved_type;

    if (!type) return;

    if (type->kind == TYPE_STRUCT) {
        DynamicArray<StructField>* fields = type->as.struct_details.fields;
        for (size_t i = 0; i < fields->length(); ++i) {
            const char* field_name = (*fields)[i].name;
            // Find in initializer
            ASTNode* val = NULL;
            for (size_t j = 0; j < init->fields->length(); ++j) {
                if (plat_strcmp((*init->fields)[j]->field_name, field_name) == 0) {
                    val = (*init->fields)[j]->value;
                    break;
                }
            }

            if (val) {
                if (val->type == NODE_STRUCT_INITIALIZER) {
                    char nested_name[256];
                    char* cur = nested_name;
                    size_t rem = sizeof(nested_name);
                    safe_append(cur, rem, base_name);
                    safe_append(cur, rem, ".");
                    safe_append(cur, rem, field_name);
                    emitInitializerAssignments(nested_name, val);
                } else {
                    writeIndent();
                    writeString(base_name);
                    writeString(".");
                    writeString(field_name);
                    writeString(" = ");
                    emitExpression(val);
                    writeString(";\n");
                }
            }
        }
    } else if (type->kind == TYPE_ARRAY) {
        for (size_t i = 0; i < init->fields->length(); ++i) {
            ASTNode* val = (*init->fields)[i]->value;
            char idx_str[32];
            plat_i64_to_string(i, idx_str, sizeof(idx_str));

            if (val->type == NODE_STRUCT_INITIALIZER) {
                char nested_name[256];
                char* cur = nested_name;
                size_t rem = sizeof(nested_name);
                safe_append(cur, rem, base_name);
                safe_append(cur, rem, "[");
                safe_append(cur, rem, idx_str);
                safe_append(cur, rem, "]");
                emitInitializerAssignments(nested_name, val);
            } else {
                writeIndent();
                writeString(base_name);
                writeString("[");
                writeString(idx_str);
                writeString("] = ");
                emitExpression(val);
                writeString(";\n");
            }
        }
    }
}

void C89Emitter::emitAssignmentWithLifting(const char* target_var, const ASTNode* lvalue_node, const ASTNode* rvalue, Type* target_type) {
    if (!rvalue) return;

    if (!target_type && lvalue_node) {
        target_type = lvalue_node->resolved_type;
    }

    Type* source_type = rvalue->resolved_type;
    const char* effective_target = target_var;
    bool is_discard = false;

    if (lvalue_node && lvalue_node->type == NODE_IDENTIFIER && plat_strcmp(lvalue_node->as.identifier.name, "_") == 0) {
        is_discard = true;
    } else if (!effective_target && !lvalue_node) {
        is_discard = true;
    }

    if (!effective_target && lvalue_node && lvalue_node->type == NODE_IDENTIFIER && lvalue_node->as.identifier.symbol) {
        effective_target = var_alloc_.allocate(lvalue_node->as.identifier.symbol);
    }

    if (is_discard) {
        switch (rvalue->type) {
            case NODE_TRY_EXPR:    emitTryExpr(rvalue, NULL); break;
            case NODE_CATCH_EXPR:  emitCatchExpr(rvalue, NULL); break;
            case NODE_IF_EXPR:     emitIfExpr(rvalue, NULL); break;
            case NODE_SWITCH_EXPR: emitSwitchExpr(rvalue, NULL); break;
            case NODE_ORELSE_EXPR: emitOrelseExpr(rvalue, NULL); break;
            case NODE_STRUCT_INITIALIZER:
                /* Special case: discarding a struct initializer means evaluating its components for side effects */
                if (rvalue->as.struct_initializer->fields) {
                    DynamicArray<ASTNamedInitializer*>* fields = rvalue->as.struct_initializer->fields;
                    for (size_t i = 0; i < fields->length(); ++i) {
                        emitAssignmentWithLifting(NULL, NULL, (*fields)[i]->value, NULL);
                    }
                }
                break;
            default:
                writeIndent();
                writeString("(void)(");
                emitExpression(rvalue);
                writeString(");\n");
                break;
        }
        return;
    }

    /* Coercions */
    if (target_type && target_type->kind == TYPE_ERROR_UNION && source_type && source_type->kind != TYPE_ERROR_UNION) {
        emitErrorUnionWrapping(effective_target, lvalue_node, target_type, rvalue);
        return;
    }
    if (target_type && target_type->kind == TYPE_OPTIONAL && source_type && source_type->kind != TYPE_OPTIONAL) {
        emitOptionalWrapping(effective_target, lvalue_node, target_type, rvalue);
        return;
    }

    /* Lifting */
    if (rvalue->type == NODE_STRUCT_INITIALIZER) {
        if (effective_target) {
            emitInitializerAssignments(effective_target, rvalue);
        } else {
            writeIndent();
            if (lvalue_node) {
                emitExpression(lvalue_node);
                writeString(" = ");
            }
            emitExpression(rvalue);
            writeString(";\n");
        }
    } else if (rvalue->type == NODE_SWITCH_EXPR || rvalue->type == NODE_IF_EXPR ||
               rvalue->type == NODE_TRY_EXPR || rvalue->type == NODE_CATCH_EXPR ||
               rvalue->type == NODE_ORELSE_EXPR) {

        if (effective_target) {
            switch (rvalue->type) {
                case NODE_SWITCH_EXPR: emitSwitchExpr(rvalue, effective_target, target_type); break;
                case NODE_IF_EXPR:     emitIfExpr(rvalue, effective_target, target_type); break;
                case NODE_TRY_EXPR:    emitTryExpr(rvalue, effective_target, target_type); break;
                case NODE_CATCH_EXPR:  emitCatchExpr(rvalue, effective_target, target_type); break;
                case NODE_ORELSE_EXPR: emitOrelseExpr(rvalue, effective_target, target_type); break;
                default: break;
            }
        } else {
            /* Complex lvalue for lifted expression - currently not supported for assignment
               We'll fall back to normal emission which will report an error */
            writeIndent();
            if (lvalue_node) {
                emitExpression(lvalue_node);
                writeString(" = ");
            }
            emitExpression(rvalue);
            writeString(";\n");
        }
    } else {
        writeIndent();
        if (effective_target) {
            writeString(effective_target);
        } else if (lvalue_node) {
            emitExpression(lvalue_node);
        }
        writeString(" = ");
        emitExpression(rvalue);
        writeString(";\n");
    }
}

void C89Emitter::emitLocalVarDecl(const ASTNode* node, bool emit_assignment) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    if (!decl->symbol) return;
    const char* c_name = var_alloc_.allocate(decl->symbol);

    if (!emit_assignment) {
        writeIndent();
        emitDeclarator(node->resolved_type, c_name);
        writeString(";\n");
    } else {
        if (decl->initializer && decl->initializer->type != NODE_UNDEFINED_LITERAL) {
            emitAssignmentWithLifting(c_name, node, decl->initializer);
        }
    }
}

void C89Emitter::emitFnProto(const ASTFnDeclNode* node, bool is_public) {
    if (!node) return;

    writeIndent();

    // Special handling for the main entry point
    if (plat_strcmp(node->name, "main") == 0 && (node->is_pub || is_public)) {
        writeString("int main(int argc, char* argv[]);");
    } else {
        if (node->is_extern) {
            writeString("extern ");
        } else if (!is_public && !node->is_pub && !node->is_export) {
            writeString("static ");
        }

        Type* ret_type = node->return_type ? node->return_type->resolved_type : get_g_type_void();
        const char* mangled_name = getC89GlobalName(node->name);

        // For prototype, we don't necessarily want to allocate parameter names in var_alloc_,
        // so we don't pass 'node' as params_node if we want to avoid side effects.
        // But we want to emit parameter types correctly.
        emitTypePrefix(ret_type);
        writeString(" ");
        writeString(mangled_name);
        writeString("(");
        if (!node->params || node->params->length() == 0) {
            writeString("void");
        } else {
            for (size_t i = 0; i < node->params->length(); ++i) {
                ASTParamDeclNode* param = (*node->params)[i];
                emitDeclarator(param->type->resolved_type, NULL);
                if (i < node->params->length() - 1) {
                    writeString(", ");
                }
            }
        }
        writeString(")");
        emitTypeSuffix(ret_type);
        writeString(";");
    }
}

void C89Emitter::emitFnDecl(const ASTFnDeclNode* node) {
    if (!node) return;
    beginFunction();

    writeIndent();

    Type* ret_type = node->return_type ? node->return_type->resolved_type : get_g_type_void();
    current_fn_ret_type_ = ret_type;
    defer_stack_.clear();

    // Special handling for the main entry point
    if (plat_strcmp(node->name, "main") == 0 && node->is_pub) {
        writeString("int main(int argc, char* argv[])");
    } else {
        if (node->is_extern) {
            writeString("extern ");
        } else if (!node->is_pub && !node->is_export) {
            writeString("static ");
        }

        const char* mangled_name = getC89GlobalName(node->name);

        emitDeclarator(ret_type, mangled_name, node);
    }

    if (node->body) {
        writeString(" ");
        emitBlock(&node->body->as.block_stmt);
        writeString("\n\n");
    } else {
        writeString(";\n\n");
    }
}

void C89Emitter::emitBlock(const ASTBlockStmtNode* node, int label_id) {
    if (!node) return;

    writeString("{\n");
    {
        IndentScope scope_indent(*this);
        DeferScopeGuard defer_guard(*this, label_id);
        DeferScope* scope = defer_stack_.back();

        /* Pass 1: Local declarations */
        for (size_t i = 0; i < node->statements->length(); ++i) {
            ASTNode* stmt = (*node->statements)[i];
            if (stmt->type == NODE_VAR_DECL) {
                emitLocalVarDecl(stmt, false);
            }
        }

        /* Pass 2: Statements */
        bool exits = false;
        for (size_t i = 0; i < node->statements->length(); ++i) {
            ASTNode* stmt = (*node->statements)[i];
            if (stmt->type == NODE_VAR_DECL) {
                emitLocalVarDecl(stmt, true);
            } else if (stmt->type == NODE_DEFER_STMT) {
                scope->defers.append(&stmt->as.defer_stmt);
            } else {
                emitStatement(stmt);
                if (allPathsExit(stmt)) {
                    exits = true;
                    /* Once we hit a path that always exits, any subsequent statements in this block are unreachable. */
                    break;
                }
            }
        }

        /* Emit defers for this block in reverse order, only if not already handled by a terminator */
        if (!exits) {
            for (int i = (int)scope->defers.length() - 1; i >= 0; --i) {
                emitStatement(scope->defers[i]->statement);
            }
        }
    }
    writeIndent();
    writeString("}");
}

void C89Emitter::emitBlockWithAssignment(const ASTBlockStmtNode* node, const char* target_var, int label_id, Type* target_type) {
    if (!node) return;

    writeString("{\n");
    {
        IndentScope scope_indent(*this);
        DeferScopeGuard defer_guard(*this, label_id);
        DeferScope* scope = defer_stack_.back();

        /* Pass 1: Local declarations */
        for (size_t i = 0; i < node->statements->length(); ++i) {
            ASTNode* stmt = (*node->statements)[i];
            if (stmt->type == NODE_VAR_DECL) {
                emitLocalVarDecl(stmt, false);
            }
        }

        /* Pass 2: Statements */
        bool exits = false;
        for (size_t i = 0; i < node->statements->length(); ++i) {
            ASTNode* stmt = (*node->statements)[i];
            if (stmt->type == NODE_VAR_DECL) {
                emitLocalVarDecl(stmt, true);
            } else if (stmt->type == NODE_DEFER_STMT) {
                scope->defers.append(&stmt->as.defer_stmt);
            } else {
                /* Check if it's the last expression in the block */
                if (i == node->statements->length() - 1 && target_var &&
                    stmt->type != NODE_EXPRESSION_STMT &&
                    stmt->type != NODE_IF_STMT && stmt->type != NODE_WHILE_STMT &&
                    stmt->type != NODE_FOR_STMT && stmt->type != NODE_RETURN_STMT &&
                    stmt->type != NODE_BREAK_STMT && stmt->type != NODE_CONTINUE_STMT &&
                    stmt->type != NODE_UNREACHABLE) {

                    emitAssignmentWithLifting(target_var, NULL, stmt, target_type);
                } else {
                    emitStatement(stmt);
                }

                if (allPathsExit(stmt)) {
                    exits = true;
                    break;
                }
            }
        }

        /* Emit defers for this block in reverse order, only if not already handled by a terminator */
        if (!exits) {
            for (int i = (int)scope->defers.length() - 1; i >= 0; --i) {
                emitStatement(scope->defers[i]->statement);
            }
        }
    }
    writeIndent();
    writeString("}");
}

void C89Emitter::emitStatement(const ASTNode* node) {
    if (!node) return;
    current_loc_ = node->loc;

    switch (node->type) {
        case NODE_IF_EXPR:
            emitIfExpr(node, NULL);
            break;
        case NODE_BLOCK_STMT:
            writeIndent();
            emitBlock(&node->as.block_stmt);
            writeString("\n");
            break;
        case NODE_IF_STMT:
            emitIf(node->as.if_stmt);
            break;
        case NODE_WHILE_STMT:
            emitWhile(node->as.while_stmt);
            break;
        case NODE_FOR_STMT:
            emitFor(node->as.for_stmt);
            break;
        case NODE_BREAK_STMT:
            emitBreak(&node->as.break_stmt);
            break;
        case NODE_CONTINUE_STMT:
            emitContinue(&node->as.continue_stmt);
            break;
        case NODE_RETURN_STMT:
            emitReturn(&node->as.return_stmt);
            break;
        case NODE_UNREACHABLE:
            writeIndent();
            emitExpression(node);
            writeString(";\n");
            break;
        case NODE_DEFER_STMT:
            writeIndent();
            writeString("/* defer */\n");
            break;
        case NODE_EXPRESSION_STMT: {
            ASTNode* expr = node->as.expression_stmt.expression;
            if (expr->type == NODE_SWITCH_EXPR || expr->type == NODE_IF_EXPR ||
                expr->type == NODE_TRY_EXPR || expr->type == NODE_CATCH_EXPR ||
                expr->type == NODE_ORELSE_EXPR) {
                emitAssignmentWithLifting(NULL, NULL, expr);
            } else if (expr->type == NODE_ASSIGNMENT) {
                emitAssignmentWithLifting(NULL, expr->as.assignment->lvalue, expr->as.assignment->rvalue);
            } else if (expr->type == NODE_FUNCTION_CALL) {
                // Check if it's std.debug.print
                bool is_print = false;
                const ASTNode* callee = expr->as.function_call->callee;
                if (callee->type == NODE_MEMBER_ACCESS && plat_strcmp(callee->as.member_access->field_name, "print") == 0) {
                    is_print = true;
                }

                if (is_print) {
                    emitPrintCall(expr->as.function_call);
                } else {
                    writeIndent();
                    emitExpression(expr);
                    writeString(";\n");
                }
            } else if (expr->type == NODE_RETURN_STMT ||
                       expr->type == NODE_BREAK_STMT ||
                       expr->type == NODE_CONTINUE_STMT ||
                       expr->type == NODE_UNREACHABLE) {
                emitStatement(expr);
            } else {
                writeIndent();
                emitExpression(expr);
                writeString(";\n");
            }
            break;
        }
        case NODE_ASSIGNMENT: {
            emitAssignmentWithLifting(NULL, node->as.assignment->lvalue, node->as.assignment->rvalue);
            break;
        }
        case NODE_EMPTY_STMT:
            writeIndent();
            writeString(";\n");
            break;
        default:
            writeIndent();
            writeString("/* Unimplemented statement type ");
            char num[16];
            plat_i64_to_string(node->type, num, sizeof(num));
            writeString(num);
            writeString(" */\n");
            break;
    }
}

void C89Emitter::emitIf(const ASTIfStmtNode* node) {
    if (!node) return;

    Type* cond_type = node->condition->resolved_type;
    bool is_optional = (cond_type && cond_type->kind == TYPE_OPTIONAL);

    if (is_optional) {
        writeIndent();
        writeString("{\n");
        {
            IndentScope scope_indent(*this);
            const char* cond_tmp = var_alloc_.generate("opt_tmp");
        writeIndent();
        emitType(cond_type, cond_tmp);
        writeString(" = ");
        emitExpression(node->condition);
        writeString(";\n");

        writeIndent();
        writeString("if (");
        writeString(cond_tmp);
        writeString(".has_value) {\n");
        {
            IndentScope if_indent(*this);
            if (node->capture_name && node->capture_sym && node->capture_sym->symbol_type->kind != TYPE_VOID) {
            writeIndent();
            const char* c_name = var_alloc_.allocate(node->capture_sym);
            emitType(node->capture_sym->symbol_type, c_name);
            writeString(" = ");
            writeString(cond_tmp);
            writeString(".value;\n");
        }
            if (node->then_block->type == NODE_BLOCK_STMT) {
                emitBlock(&node->then_block->as.block_stmt);
            } else {
                emitStatement(node->then_block);
            }
        }
        writeIndent();
        writeString("}");
        if (node->else_block) {
            writeString(" else {\n");
            {
                IndentScope else_indent(*this);
                if (node->else_block->type == NODE_IF_STMT) {
                emitIf(node->else_block->as.if_stmt);
            } else if (node->else_block->type == NODE_BLOCK_STMT) {
                emitBlock(&node->else_block->as.block_stmt);
                } else {
                    emitStatement(node->else_block);
                }
            }
            writeIndent();
            writeString("}\n");
        } else {
            writeString("\n");
        }
        }
        writeIndent();
        writeString("}\n");
    } else {
        writeIndent();
        writeString("if (");
        emitExpression(node->condition);
        writeString(") ");

        if (node->then_block->type == NODE_BLOCK_STMT) {
            emitBlock(&node->then_block->as.block_stmt);
        } else {
            emitStatement(node->then_block);
        }

        if (node->else_block) {
            writeString(" else ");
            if (node->else_block->type == NODE_IF_STMT) {
                emitIf(node->else_block->as.if_stmt);
            } else if (node->else_block->type == NODE_BLOCK_STMT) {
                emitBlock(&node->else_block->as.block_stmt);
            } else {
                emitStatement(node->else_block);
            }
        }
        writeString("\n");
    }
}

void C89Emitter::emitIfExpr(const ASTNode* node, const char* target_var, Type* target_type) {
    if (!node) return;
    current_loc_ = node->loc;
    if (node->type != NODE_IF_EXPR) return;

    const ASTIfExprNode* if_expr = node->as.if_expr;
    if (!if_expr || !if_expr->condition || !if_expr->then_expr || !if_expr->else_expr) {
        error_handler_.report(ERR_INTERNAL_ERROR, current_loc_, "Internal error: if expression components are NULL");
        return;
    }

    Type* cond_type = if_expr->condition->resolved_type;
    bool is_optional = (cond_type && cond_type->kind == TYPE_OPTIONAL);

    writeIndent();
    writeString("{\n");
    {
        IndentScope scope_indent(*this);

        const char* cond_var = NULL;
    if (is_optional) {
        cond_var = var_alloc_.generate("opt_tmp");
        writeIndent();
        emitType(cond_type, cond_var);
        writeString(" = ");
        emitExpression(if_expr->condition);
        writeString(";\n");
    }

        writeIndent();
        writeString("if (");
        if (is_optional) {
            writeString(cond_var);
            writeString(".has_value");
        } else {
            emitExpression(if_expr->condition);
        }
        writeString(") {\n");
        {
            IndentScope then_indent(*this);

            if (is_optional && if_expr->capture_name && if_expr->capture_sym && if_expr->capture_sym->symbol_type->kind != TYPE_VOID) {
        writeIndent();
        const char* c_name = var_alloc_.allocate(if_expr->capture_sym);
        emitType(if_expr->capture_sym->symbol_type, c_name);
        writeString(" = ");
        writeString(cond_var);
        writeString(".value;\n");
    }

            if (target_var && (!if_expr->then_expr->resolved_type || if_expr->then_expr->resolved_type->kind != TYPE_NORETURN)) {
                if (if_expr->then_expr->type == NODE_BLOCK_STMT) {
                emitBlockWithAssignment(&if_expr->then_expr->as.block_stmt, target_var, -1, target_type);
                    writeString("\n");
                } else {
                    emitAssignmentWithLifting(target_var, NULL, if_expr->then_expr, target_type);
                }
            } else {
                if (if_expr->then_expr->type == NODE_BLOCK_STMT) {
                    emitBlock(&if_expr->then_expr->as.block_stmt);
                    writeString("\n");
                } else {
                    emitAssignmentWithLifting(NULL, NULL, if_expr->then_expr, NULL);
                }
            }
        }
        writeIndent();
        writeString("} else {\n");
        {
            IndentScope else_indent(*this);
            if (target_var && (!if_expr->else_expr->resolved_type || if_expr->else_expr->resolved_type->kind != TYPE_NORETURN)) {
                if (if_expr->else_expr->type == NODE_BLOCK_STMT) {
                emitBlockWithAssignment(&if_expr->else_expr->as.block_stmt, target_var, -1, target_type);
                    writeString("\n");
                } else {
                    emitAssignmentWithLifting(target_var, NULL, if_expr->else_expr, target_type);
                }
            } else {
                if (if_expr->else_expr->type == NODE_BLOCK_STMT) {
                    emitBlock(&if_expr->else_expr->as.block_stmt);
                    writeString("\n");
                } else {
                    emitAssignmentWithLifting(NULL, NULL, if_expr->else_expr, NULL);
                }
            }
        }
        writeIndent();
        writeString("}\n");
    }
    writeIndent();
    writeString("}\n");
}

static bool evaluateSimpleConstant(const ASTNode* node, i64* out_value) {
    if (!node) return false;
    if (node->type == NODE_INTEGER_LITERAL) {
        *out_value = (i64)node->as.integer_literal.value;
        return true;
    }
    if (node->type == NODE_BOOL_LITERAL) {
        *out_value = node->as.bool_literal.value ? 1 : 0;
        return true;
    }
    if (node->type == NODE_UNARY_OP && node->as.unary_op.op == TOKEN_MINUS) {
        i64 val;
        if (evaluateSimpleConstant(node->as.unary_op.operand, &val)) {
            *out_value = -val;
            return true;
        }
    }
    if (node->type == NODE_PAREN_EXPR) {
        return evaluateSimpleConstant(node->as.paren_expr.expr, out_value);
    }
    return false;
}

void C89Emitter::emitPrintCall(const ASTFunctionCallNode* node) {
    if (!node->args || node->args->length() != 2) return;

    ASTNode* fmt_node = (*node->args)[0];
    ASTNode* tuple_node = (*node->args)[1];

    if (fmt_node->type != NODE_STRING_LITERAL) {
        // Fallback: just emit as a normal call if we can't lower it
        writeIndent();
        writeString("/* warning: could not lower std.debug.print (not a string literal) */\n");
        return;
    }

    const char* fmt = fmt_node->as.string_literal.value;
    DynamicArray<ASTNode*>* elements = (tuple_node->type == NODE_TUPLE_LITERAL) ?
                                      tuple_node->as.tuple_literal->elements : NULL;

    size_t element_idx = 0;
    const char* start = fmt;
    const char* p = fmt;

    while (*p) {
        if (*p == '{' && *(p+1) == '}') {
            // Print what we have so far
            if (p > start) {
                writeIndent();
                writeString("__bootstrap_print(\"");
                const char* s = start;
                while (s < p) {
                    emitEscapedByte((unsigned char)*s, false);
                    s++;
                }
                writeString("\");\n");
            }

            // Print the element
            if (elements && element_idx < elements->length()) {
                writeIndent();
                writeString("__bootstrap_print_int(");
                emitExpression((*elements)[element_idx]);
                writeString(");\n");
                element_idx++;
            } else {
                writeIndent();
                writeString("__bootstrap_print(\"{}\");\n");
            }

            p += 2;
            start = p;
        } else {
            p++;
        }
    }

    // Print remaining part
    if (*start) {
        writeIndent();
        writeString("__bootstrap_print(\"");
        const char* s = start;
        while (*s) {
            emitEscapedByte((unsigned char)*s, false);
            s++;
        }
        writeString("\");\n");
    }
}

void C89Emitter::emitTryExpr(const ASTNode* node, const char* target_var, Type* target_type) {
    if (!node) return;
    current_loc_ = node->loc;
    if (node->type != NODE_TRY_EXPR) return;

    const ASTTryExprNode& try_node = node->as.try_expr;

    if (!try_node.expression) {
        error_handler_.report(ERR_INTERNAL_ERROR, current_loc_, "Internal error: try expression is NULL");
        return;
    }

    Type* inner_type = try_node.expression->resolved_type;
    if (!inner_type) {
        error_handler_.report(ERR_INTERNAL_ERROR, current_loc_, "Internal error: try operand type not resolved");
        return;
    }
    const char* mangled_inner = getMangledTypeName(inner_type);

    writeIndent();
    writeString("{\n");
    {
        IndentScope scope_indent(*this);

        writeIndent();
    writeString(mangled_inner);
    writeString(" __try_res = ");
    emitExpression(try_node.expression);
    writeString(";\n");

        writeIndent();
        writeString("if (__try_res.is_error) {\n");
        {
            IndentScope err_indent(*this);

            if (!current_fn_ret_type_) {
        emitDefersForScopeExit(-1);
        writeIndent();
        writeString("return;\n");
    } else if (current_fn_ret_type_->kind == TYPE_ERROR_UNION) {
        const char* mangled_ret = getMangledTypeName(current_fn_ret_type_);
        writeIndent();
        writeString(mangled_ret);
        writeString(" __ret_err;\n");

        emitDefersForScopeExit(-1);

        writeIndent();
        writeString("__ret_err.is_error = 1;\n");
        writeIndent();
        if (current_fn_ret_type_->as.error_union.payload->kind != TYPE_VOID) {
            writeString("__ret_err.data.err = ");
            if (inner_type->as.error_union.payload->kind != TYPE_VOID) {
                writeString("__try_res.data.err");
            } else {
                writeString("__try_res.err");
            }
        } else {
            writeString("__ret_err.err = ");
            if (inner_type->as.error_union.payload->kind != TYPE_VOID) {
                writeString("__try_res.data.err");
            } else {
                writeString("__try_res.err");
            }
        }
        writeString(";\n");
                writeIndent();
                writeString("return __ret_err;\n");
            } else {
                emitDefersForScopeExit(-1);
                writeIndent();
                writeString("return;\n");
            }
        }
        writeIndent();
        writeString("}\n");

        if (target_var) {
            Type* payload_type = inner_type->as.error_union.payload;
            const char* payload_expr = (payload_type->kind != TYPE_VOID) ? "__try_res.data.payload" : "0";

            if (target_type && target_type->kind == TYPE_ERROR_UNION && payload_type->kind != TYPE_ERROR_UNION) {
                emitErrorUnionWrapping(target_var, NULL, target_type, payload_expr, payload_type);
            } else if (target_type && target_type->kind == TYPE_OPTIONAL && payload_type->kind != TYPE_OPTIONAL) {
                emitOptionalWrapping(target_var, NULL, target_type, payload_expr, payload_type);
            } else {
                writeIndent();
                writeString(target_var);
                writeString(" = ");
                writeString(payload_expr);
                writeString(";\n");
            }
        }
    }
    writeIndent();
    writeString("}\n");
}

void C89Emitter::emitCatchExpr(const ASTNode* node, const char* target_var, Type* target_type) {
    if (!node) return;
    current_loc_ = node->loc;
    if (node->type != NODE_CATCH_EXPR) return;

    const ASTCatchExprNode* catch_node = node->as.catch_expr;

    if (!catch_node || !catch_node->payload || !catch_node->else_expr) {
        error_handler_.report(ERR_INTERNAL_ERROR, current_loc_, "Internal error: catch components are NULL");
        return;
    }

    Type* inner_type = catch_node->payload->resolved_type;
    const char* mangled_inner = getMangledTypeName(inner_type);

    writeIndent();
    writeString("{\n");
    {
        IndentScope scope_indent(*this);

        writeIndent();
    writeString(mangled_inner);
    writeString(" __catch_res = ");
    emitExpression(catch_node->payload);
    writeString(";\n");

        writeIndent();
        writeString("if (__catch_res.is_error) {\n");
        {
            IndentScope err_indent(*this);
            if (catch_node->error_name) {
        writeIndent();
        writeString("int ");
        writeString(catch_node->error_name);
        writeString(" = ");
        if (inner_type->as.error_union.payload->kind != TYPE_VOID) {
            writeString("__catch_res.data.err");
        } else {
            writeString("__catch_res.err");
        }
        writeString(";\n");
    }

    if (target_var) {
        if (catch_node->else_expr->type == NODE_BLOCK_STMT) {
            emitBlockWithAssignment(&catch_node->else_expr->as.block_stmt, target_var, -1, target_type);
            writeString("\n");
        } else {
            emitAssignmentWithLifting(target_var, NULL, catch_node->else_expr, target_type);
        }
    } else {
        if (catch_node->else_expr->type == NODE_BLOCK_STMT) {
            emitBlock(&catch_node->else_expr->as.block_stmt);
            writeString("\n");
        } else {
            emitAssignmentWithLifting(NULL, NULL, catch_node->else_expr, NULL);
        }
    }
        }
        writeIndent();
        writeString("} else {\n");
        {
            IndentScope payload_indent(*this);
            if (target_var) {
                Type* payload_type = inner_type->as.error_union.payload;
                const char* payload_expr = (payload_type->kind != TYPE_VOID) ? "__catch_res.data.payload" : "0";

                if (target_type && target_type->kind == TYPE_ERROR_UNION && payload_type->kind != TYPE_ERROR_UNION) {
                    emitErrorUnionWrapping(target_var, NULL, target_type, payload_expr, payload_type);
                } else if (target_type && target_type->kind == TYPE_OPTIONAL && payload_type->kind != TYPE_OPTIONAL) {
                    emitOptionalWrapping(target_var, NULL, target_type, payload_expr, payload_type);
                } else {
                    writeIndent();
                    writeString(target_var);
                    writeString(" = ");
                    writeString(payload_expr);
                    writeString(";\n");
                }
            }
        }
        writeIndent();
        writeString("}\n");
    }
    writeIndent();
    writeString("}\n");
}

void C89Emitter::emitSwitchExpr(const ASTNode* node, const char* target_var, Type* target_type) {
    if (!node) return;
    current_loc_ = node->loc;
    if (node->type != NODE_SWITCH_EXPR) return;

    const ASTSwitchExprNode* switch_node = node->as.switch_expr;
    if (!switch_node || !switch_node->expression || !switch_node->prongs) {
        error_handler_.report(ERR_INTERNAL_ERROR, current_loc_, "Internal error: switch expression components are NULL");
        return;
    }

    Type* cond_type = switch_node->expression->resolved_type;
    bool is_tagged_union = (cond_type && cond_type->kind == TYPE_UNION && cond_type->as.struct_details.is_tagged);
    const char* switch_tmp = NULL;

    if (is_tagged_union) {
        switch_tmp = var_alloc_.generate("switch_tmp");
        writeIndent();
        writeString("{\n");
        {
            IndentScope scope_indent(*this);
            writeIndent();
            emitType(cond_type, switch_tmp);
            writeString(" = ");
            emitExpression(switch_node->expression);
            writeString(";\n");

            writeIndent();
            writeString("switch (");
            writeString(switch_tmp);
            writeString(".tag) {\n");
        }
    } else {
        writeIndent();
        writeString("switch (");
        emitExpression(switch_node->expression);
        writeString(") {\n");
    }

    {
        IndentScope switch_indent(*this);
        for (size_t i = 0; i < switch_node->prongs->length(); ++i) {
            const ASTSwitchProngNode* prong = (*switch_node->prongs)[i];
            if (prong->is_else) {
                writeIndent();
                writeString("default:\n");
            } else {
                for (size_t j = 0; j < prong->items->length(); ++j) {
                    const ASTNode* item = (*prong->items)[j];
                    if (item->type == NODE_RANGE) {
                        i64 start, end;
                        if (evaluateSimpleConstant(item->as.range.start, &start) &&
                            evaluateSimpleConstant(item->as.range.end, &end)) {
                            for (i64 k = start; k <= end; ++k) {
                                writeIndent();
                                writeString("case ");
                                char buf[32];
                                plat_i64_to_string(k, buf, sizeof(buf));
                                writeString(buf);
                                writeString(":\n");
                            }
                        } else {
                            error_handler_.report(ERR_UNSUPPORTED_FEATURE, item->loc, "Non-constant range in switch is not yet supported");
                            return;
                        }
                    } else {
                        writeIndent();
                        writeString("case ");
                        emitExpression(item);
                        writeString(":\n");
                    }
                }
            }
            {
                IndentScope prong_indent(*this);

                if (is_tagged_union && prong->capture_name && prong->capture_sym) {
                    writeIndent();
                    writeString("{\n");
                    {
                        IndentScope capture_indent(*this);
                        writeIndent();
                        emitType(prong->capture_sym->symbol_type, var_alloc_.allocate(prong->capture_sym));
                        writeString(" = ");
                        writeString(switch_tmp);
                        writeString(".data.");
                        // Field name is preserved in original_name of the case item literal
                        ASTNode* item_expr = (*prong->items)[0];
                        writeString(item_expr->as.integer_literal.original_name);
                        writeString(";\n");
                    }
                }

                if (target_var && (!prong->body->resolved_type || prong->body->resolved_type->kind != TYPE_NORETURN)) {
                    if (prong->body->type == NODE_BLOCK_STMT) {
                        writeIndent();
                        emitBlockWithAssignment(&prong->body->as.block_stmt, target_var, -1, target_type);
                        writeString("\n");
                    } else {
                        emitAssignmentWithLifting(target_var, NULL, prong->body, target_type);
                    }
                } else {
                    /* Just emit expression for side effects if no target or if it diverges */
                    if (prong->body->type == NODE_BLOCK_STMT) {
                        writeIndent();
                        emitBlock(&prong->body->as.block_stmt);
                        writeString("\n");
                    } else if (prong->body->type == NODE_RETURN_STMT ||
                        prong->body->type == NODE_BREAK_STMT ||
                        prong->body->type == NODE_CONTINUE_STMT ||
                        prong->body->type == NODE_UNREACHABLE) {
                        emitStatement(prong->body);
                    } else {
                        emitAssignmentWithLifting(NULL, NULL, prong->body, NULL);
                    }
                }

                if (is_tagged_union && prong->capture_name && prong->capture_sym) {
                    writeIndent();
                    writeString("}\n");
                }

                writeIndent();
                writeString("break;\n");
            }
        }
    }
    writeIndent();
    writeString("}\n");

    if (is_tagged_union) {
        writeIndent();
        writeString("}\n");
    }
}

void C89Emitter::emitFor(const ASTForStmtNode* node) {
    if (!node) return;

    for_loop_counter_++;
    int current_for_id = for_loop_counter_;

    char idx_name[32];
    char len_name[32];
    char iter_name[32];
    char id_buf[16]; plat_i64_to_string(current_for_id, id_buf, sizeof(id_buf));

    char* cur = idx_name; size_t rem = sizeof(idx_name);
    safe_append(cur, rem, "__for_idx_");
    safe_append(cur, rem, id_buf);

    cur = len_name; rem = sizeof(len_name);
    safe_append(cur, rem, "__for_len_");
    safe_append(cur, rem, id_buf);

    cur = iter_name; rem = sizeof(iter_name);
    safe_append(cur, rem, "__for_iter_");
    safe_append(cur, rem, id_buf);

    bool is_range = (node->iterable_expr->type == NODE_RANGE);

    writeIndent();
    writeString("{\n");
    {
        IndentScope scope_indent(*this);

        // Iterable evaluate once
    if (!is_range) {
        writeIndent();
        Type* iter_type = node->iterable_expr->resolved_type;
        if (iter_type->kind == TYPE_ARRAY) {
             // Emit as pointer
             emitType(createPointerType(arena_, iter_type->as.array.element_type, true), iter_name);
        } else {
             emitType(iter_type, iter_name);
        }
        writeString(" = ");
        emitExpression(node->iterable_expr);
        writeString(";\n");
    }

    // Initializer
    writeIndent();
    writeString("size_t ");
    writeString(idx_name);
    writeString(" = ");
    if (is_range) {
        emitExpression(node->iterable_expr->as.range.start);
    } else {
        writeString("0");
    }
    writeString(";\n");

    writeIndent();
    writeString("size_t ");
    writeString(len_name);
    writeString(" = ");
    if (is_range) {
        emitExpression(node->iterable_expr->as.range.end);
    } else {
        Type* iterable_type = node->iterable_expr->resolved_type;
        if (iterable_type && iterable_type->kind == TYPE_ARRAY) {
            char size_buf[32];
            plat_u64_to_string(iterable_type->as.array.size, size_buf, sizeof(size_buf));
            writeString(size_buf);
        } else if (iterable_type && iterable_type->kind == TYPE_SLICE) {
            writeString(iter_name);
            writeString(".len");
        } else {
            writeString("0 /* Unknown length */");
        }
    }
    writeString(";\n");

    char label_base[256];
    bool has_label = (node->label != NULL);
    if (has_label) {
        char* lcur = label_base;
        size_t lrem = sizeof(label_base);
        safe_append(lcur, lrem, "__zig_label_");
        safe_append(lcur, lrem, node->label);
        safe_append(lcur, lrem, "_");
        char lid_buf[16];
        plat_i64_to_string(node->label_id, lid_buf, sizeof(lid_buf));
        safe_append(lcur, lrem, lid_buf);

        writeIndent();
        writeString(label_base);
        writeString("_start: ;\n");
    }

        writeIndent();
        writeString("while (");
        writeString(idx_name);
        writeString(" < ");
        writeString(len_name);
        writeString(") {\n");

        {
            IndentScope while_indent(*this);

            // Item capture
    Type* item_type = NULL;
    if (is_range) {
        item_type = get_g_type_usize();
    } else {
        Type* iterable_type = node->iterable_expr->resolved_type;
        if (iterable_type && iterable_type->kind == TYPE_ARRAY) {
            item_type = iterable_type->as.array.element_type;
        } else if (iterable_type && iterable_type->kind == TYPE_SLICE) {
            item_type = iterable_type->as.slice.element_type;
        }
    }

    if (item_type && node->item_name && plat_strcmp(node->item_name, "_") != 0) {
        const char* actual_item_name;
        if (node->item_sym) {
            actual_item_name = var_alloc_.allocate(node->item_sym);
        } else {
            actual_item_name = var_alloc_.generate(node->item_name);
        }

        writeIndent();
        emitType(item_type, actual_item_name);
        writeString(" = ");
        if (is_range) {
            writeString(idx_name);
        } else {
            writeString(iter_name);
            if (node->iterable_expr->resolved_type && node->iterable_expr->resolved_type->kind == TYPE_SLICE) {
                writeString(".ptr[");
            } else {
                writeString("[");
            }
            writeString(idx_name);
            writeString("]");
        }
        writeString(";\n");
    }

    // Index capture
    if (node->index_name && plat_strcmp(node->index_name, "_") != 0) {
        const char* actual_index_name;
        if (node->index_sym) {
            actual_index_name = var_alloc_.allocate(node->index_sym);
        } else {
            actual_index_name = var_alloc_.generate(node->index_name);
        }

        writeIndent();
        writeString("size_t ");
        writeString(actual_index_name);
        writeString(" = ");
        writeString(idx_name);
        writeString(";\n");
    }

    // Emit the actual body
    if (node->body->type == NODE_BLOCK_STMT) {
        emitBlock(&node->body->as.block_stmt, node->label_id);
    } else {
        emitStatement(node->body);
    }
    writeString("\n");

            // Increment
            writeIndent();
            writeString(idx_name);
            writeString("++;\n");

            if (has_label) {
                writeIndent();
                writeString("goto ");
                writeString(label_base);
                writeString("_start;\n");
            }
        }

        writeIndent();
        writeString("}\n");

        if (has_label) {
            writeIndent();
            writeString(label_base);
            writeString("_end: ;\n");
        }
    }

    writeIndent();
    writeString("}\n");
}

void C89Emitter::emitOrelseExpr(const ASTNode* node, const char* target_var, Type* target_type) {
    if (!node || node->type != NODE_ORELSE_EXPR) return;
    const ASTOrelseExprNode* orelse = node->as.orelse_expr;

    Type* inner_type = orelse->payload->resolved_type;
    const char* mangled_inner = getMangledTypeName(inner_type);

    writeIndent();
    writeString("{\n");
    {
        IndentScope scope_indent(*this);

        writeIndent();
        writeString(mangled_inner);
        writeString(" __orelse_res = ");
        emitExpression(orelse->payload);
        writeString(";\n");

        writeIndent();
        writeString("if (__orelse_res.has_value) {\n");
        {
            IndentScope then_indent(*this);
            if (target_var) {
                Type* payload_type = inner_type->as.optional.payload;
                const char* payload_expr = (payload_type->kind != TYPE_VOID) ? "__orelse_res.value" : "0 /* void */";

                if (target_type && target_type->kind == TYPE_ERROR_UNION && payload_type->kind != TYPE_ERROR_UNION) {
                    emitErrorUnionWrapping(target_var, NULL, target_type, payload_expr, payload_type);
                } else if (target_type && target_type->kind == TYPE_OPTIONAL && payload_type->kind != TYPE_OPTIONAL) {
                    emitOptionalWrapping(target_var, NULL, target_type, payload_expr, payload_type);
                } else {
                    writeIndent();
                    writeString(target_var);
                    writeString(" = ");
                    writeString(payload_expr);
                    writeString(";\n");
                }
            }
        }
        writeIndent();
        writeString("} else {\n");
        {
            IndentScope else_indent(*this);
            if (target_var) {
                if (orelse->else_expr->type == NODE_BLOCK_STMT) {
                    emitBlockWithAssignment(&orelse->else_expr->as.block_stmt, target_var, -1, target_type);
                    writeString("\n");
                } else {
                    emitAssignmentWithLifting(target_var, NULL, orelse->else_expr, target_type);
                }
            } else {
                if (orelse->else_expr->type == NODE_BLOCK_STMT) {
                    emitBlock(&orelse->else_expr->as.block_stmt);
                    writeString("\n");
                } else {
                    emitAssignmentWithLifting(NULL, NULL, orelse->else_expr, NULL);
                }
            }
        }
        writeIndent();
        writeString("}\n");
    }

    writeIndent();
    writeString("}\n");
}

void C89Emitter::emitWhile(const ASTWhileStmtNode* node) {
    if (!node) return;

    if (node->label) {
        char label_base[256];
        char* cur = label_base;
        size_t rem = sizeof(label_base);
        safe_append(cur, rem, "__zig_label_");
        safe_append(cur, rem, node->label);
        safe_append(cur, rem, "_");
        char id_buf[16];
        plat_i64_to_string(node->label_id, id_buf, sizeof(id_buf));
        safe_append(cur, rem, id_buf);

        writeIndent();
        writeString(label_base);
        writeString("_start: ;\n");

        writeIndent();
        writeString("if (!(");
        emitExpression(node->condition);
        writeString(")) goto ");
        writeString(label_base);
        writeString("_end;\n");

        if (node->body->type == NODE_BLOCK_STMT) {
            writeIndent();
            emitBlock(&node->body->as.block_stmt, node->label_id);
        } else {
            emitStatement(node->body);
        }
        writeString("\n");

        writeIndent();
        writeString("goto ");
        writeString(label_base);
        writeString("_start;\n");

        writeIndent();
        writeString(label_base);
        writeString("_end: ;\n");
    } else {
        writeIndent();
        writeString("while (");
        emitExpression(node->condition);
        writeString(") ");

        if (node->body->type == NODE_BLOCK_STMT) {
            emitBlock(&node->body->as.block_stmt, node->label_id);
        } else {
            emitStatement(node->body);
        }
        writeString("\n");
    }
}


bool C89Emitter::isConstantInitializer(const ASTNode* node) const {
    if (!node) return true;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
        case NODE_ERROR_LITERAL:
            return true;
        case NODE_PAREN_EXPR:
            return isConstantInitializer(node->as.paren_expr.expr);
        case NODE_UNARY_OP:
            if (node->as.unary_op.op == TOKEN_AMPERSAND) {
                // Address-of is constant if operand is a global variable or member of one
                ASTNode* operand = node->as.unary_op.operand;
                if (operand->type == NODE_IDENTIFIER) return true; // Assuming identifier is global
                if (operand->type == NODE_MEMBER_ACCESS) return isConstantInitializer(operand->as.member_access->base);
                if (operand->type == NODE_ARRAY_ACCESS) return isConstantInitializer(operand->as.array_access->array);
                return false;
            }
            return isConstantInitializer(node->as.unary_op.operand);
        case NODE_BINARY_OP:
            return isConstantInitializer(node->as.binary_op->left) &&
                   isConstantInitializer(node->as.binary_op->right);
        case NODE_IDENTIFIER:
            // Function names are constant addresses in C89
            if (node->resolved_type && node->resolved_type->kind == TYPE_FUNCTION) {
                return true;
            }
            // Identifiers are generally not constant initializers unless they are enum members or similar.
            // For now, we assume they might be global addresses if they are operands of '&'.
            return false;
        case NODE_PTR_CAST:
        case NODE_INT_CAST:
        case NODE_FLOAT_CAST:
            return isConstantInitializer(node->as.ptr_cast->expr); // All cast nodes have expr at same offset
        case NODE_TUPLE_LITERAL: {
            DynamicArray<ASTNode*>* elements = node->as.tuple_literal->elements;
            for (size_t i = 0; i < elements->length(); ++i) {
                if (!isConstantInitializer((*elements)[i])) return false;
            }
            return true;
        }
        case NODE_STRUCT_INITIALIZER: {
            DynamicArray<ASTNamedInitializer*>* fields = node->as.struct_initializer->fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                if (!isConstantInitializer((*fields)[i]->value)) return false;
            }
            return true;
        }
        case NODE_MEMBER_ACCESS: {
            // Enum member access is constant
            if (node->as.member_access->base->resolved_type) {
                Type* t = node->as.member_access->base->resolved_type;
                if (t->kind == TYPE_ENUM) {
                    return true;
                }
            }
            return false;
        }
        default:
            return false;
    }
}

void C89Emitter::write(const char* data, size_t len) {
    if (len == 0) return;

    if (in_type_def_mode_) {
        if (len > type_def_cap_ || type_def_pos_ > type_def_cap_ - len) {
            error_handler_.report(ERR_INTERNAL_ERROR, SourceLocation(), "Type definition buffer overflow");
            plat_abort();
        }
        plat_memcpy(type_def_buffer_ + type_def_pos_, data, len);
        type_def_pos_ += len;
        last_char_ = data[len - 1];
        return;
    }

    if (output_file_ == PLAT_INVALID_FILE) return;

    if (buffer_pos_ + len > sizeof(buffer_)) {
        flush();
        // If the data is larger than the buffer itself, write it directly
        if (len > sizeof(buffer_)) {
            plat_write_file(output_file_, data, len);
            last_char_ = data[len - 1];
            return;
        }
    }

    plat_memcpy(buffer_ + buffer_pos_, data, len);
    buffer_pos_ += len;
    last_char_ = data[len - 1];
}

void C89Emitter::writeString(const char* str) {
    if (!str) return;
    write(str, plat_strlen(str));
}

void C89Emitter::emitComment(const char* text) {
    if (!text) return;
    writeIndent();
    write("/* ", 3);
    writeString(text);
    write(" */\n", 4);
}

void C89Emitter::flush() {
    if (output_file_ != PLAT_INVALID_FILE && buffer_pos_ > 0) {
        plat_write_file(output_file_, buffer_, buffer_pos_);
        buffer_pos_ = 0;
    }
}

bool C89Emitter::open(const char* path) {
    close();
    output_file_ = plat_open_file(path, true);
    owns_file_ = true;
    return isValid();
}

void C89Emitter::close() {
    flush();
    if (owns_file_ && output_file_ != PLAT_INVALID_FILE) {
        plat_close_file(output_file_);
        output_file_ = PLAT_INVALID_FILE;
    }
}

void C89Emitter::emitExpression(const ASTNode* node) {
    if (!node) return;
    current_loc_ = node->loc;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
        case NODE_ERROR_LITERAL:
            emitLiteral(node);
            break;

        case NODE_UNARY_OP:
            emitUnaryOp(node->as.unary_op);
            break;

        case NODE_BINARY_OP:
            emitBinaryOp(*node->as.binary_op);
            break;

        case NODE_PTR_CAST:
        case NODE_INT_CAST:
        case NODE_FLOAT_CAST:
            emitCast(node);
            break;

        case NODE_ARRAY_ACCESS:
        case NODE_MEMBER_ACCESS:
        case NODE_ARRAY_SLICE:
            emitAccess(node);
            break;

        case NODE_SWITCH_EXPR:
        case NODE_IF_EXPR:
        case NODE_TRY_EXPR:
        case NODE_CATCH_EXPR:
        case NODE_ORELSE_EXPR:
            emitControlFlow(node);
            break;

        case NODE_TUPLE_LITERAL: {
            writeString("{");
            DynamicArray<ASTNode*>* elements = node->as.tuple_literal->elements;
            for (size_t i = 0; i < elements->length(); ++i) {
                emitExpression((*elements)[i]);
                if (i < elements->length() - 1) {
                    writeString(", ");
                }
            }
            writeString("}");
            break;
        }
        case NODE_UNREACHABLE:
            writeString("__bootstrap_panic(\"reached unreachable\", __FILE__, __LINE__)");
            break;
        case NODE_IDENTIFIER:
            if (node->as.identifier.symbol) {
                Symbol* sym = node->as.identifier.symbol;
                if (sym->flags & SYMBOL_FLAG_LOCAL) {
                    writeString(var_alloc_.allocate(sym));
                } else if (sym->mangled_name) {
                    writeString(sym->mangled_name);
                } else {
                    writeString(getC89GlobalName(sym->name));
                }
            } else {
                writeString(getC89GlobalName(node->as.identifier.name));
            }
            break;
        case NODE_PAREN_EXPR:
            writeString("(");
            emitExpression(node->as.paren_expr.expr);
            writeString(")");
            break;
        case NODE_RANGE:
            // This should only happen if range is used outside for/slicing
            emitExpression(node->as.range.start);
            writeString(" /* .. */ ");
            emitExpression(node->as.range.end);
            break;
        case NODE_IMPORT_STMT:
            writeString("/* import \"");
            writeString(node->as.import_stmt->module_name);
            writeString("\" */");
            break;
        case NODE_FUNCTION_CALL: {
            const ASTFunctionCallNode* call = node->as.function_call;
            bool need_parens = requiresParentheses(call->callee);
            if (need_parens) writeString("(");
            emitExpression(call->callee);
            if (need_parens) writeString(")");

            writeString("(");
            if (call->args) {
                for (size_t i = 0; i < call->args->length(); ++i) {
                    emitExpression((*call->args)[i]);
                    if (i < call->args->length() - 1) {
                        writeString(", ");
                    }
                }
            }
            writeString(")");
            break;
        }
        case NODE_ASSIGNMENT:
            if (node->as.assignment->lvalue->type == NODE_IDENTIFIER &&
                plat_strcmp(node->as.assignment->lvalue->as.identifier.name, "_") == 0) {
                writeString("(void)(");
                emitExpression(node->as.assignment->rvalue);
                writeString(")");
            } else {
                emitExpression(node->as.assignment->lvalue);
                writeString(" = ");
                emitExpression(node->as.assignment->rvalue);
            }
            break;
        case NODE_COMPOUND_ASSIGNMENT:
            emitExpression(node->as.compound_assignment->lvalue);
            writeString(" ");
            writeString(getTokenSpelling(node->as.compound_assignment->op));
            writeString(" ");
            emitExpression(node->as.compound_assignment->rvalue);
            break;
        case NODE_STRUCT_INITIALIZER: {
            writeString("{");
            Type* struct_type = node->resolved_type;
            if (struct_type && struct_type->kind == TYPE_STRUCT) {
                DynamicArray<StructField>* type_fields = struct_type->as.struct_details.fields;
                DynamicArray<ASTNamedInitializer*>* init_fields = node->as.struct_initializer->fields;

                for (size_t i = 0; i < type_fields->length(); ++i) {
                    const char* field_name = (*type_fields)[i].name;
                    // Find this field in the initializer
                    bool found = false;
                    for (size_t j = 0; j < init_fields->length(); ++j) {
                        if (plat_strcmp((*init_fields)[j]->field_name, field_name) == 0) {
                            emitExpression((*init_fields)[j]->value);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        writeString("0"); // Fallback for missing fields if allowed
                    }
                    if (i < type_fields->length() - 1) {
                        writeString(", ");
                    }
                }
            } else {
                // Fallback if type info is missing
                DynamicArray<ASTNamedInitializer*>* fields = node->as.struct_initializer->fields;
                for (size_t i = 0; i < fields->length(); ++i) {
                    emitExpression((*fields)[i]->value);
                    if (i < fields->length() - 1) {
                        writeString(", ");
                    }
                }
            }
            writeString("}");
            break;
        }
        case NODE_RETURN_STMT:
            emitReturn(&node->as.return_stmt);
            break;
        case NODE_BREAK_STMT:
            emitBreak(&node->as.break_stmt);
            break;
        case NODE_CONTINUE_STMT:
            emitContinue(&node->as.continue_stmt);
            break;
        default:
            error_handler_.report(ERR_UNSUPPORTED_FEATURE, current_loc_, "Unimplemented expression type in code generation");
            break;
    }
}

void C89Emitter::emitLiteral(const ASTNode* node) {
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
            emitIntegerLiteral(&node->as.integer_literal);
            break;
        case NODE_FLOAT_LITERAL:
            emitFloatLiteral(&node->as.float_literal);
            break;
        case NODE_STRING_LITERAL:
            emitStringLiteral(&node->as.string_literal);
            break;
        case NODE_CHAR_LITERAL:
            emitCharLiteral(&node->as.char_literal);
            break;
        case NODE_BOOL_LITERAL:
            writeString(node->as.bool_literal.value ? "1" : "0");
            break;
        case NODE_NULL_LITERAL:
            writeString("((void*)0)");
            break;
        case NODE_ERROR_LITERAL:
            writeString("ERROR_");
            writeString(node->as.error_literal.tag_name);
            break;
        default: break;
    }
}

void C89Emitter::emitUnaryOp(const ASTUnaryOpNode& node) {
    writeString(getTokenSpelling(node.op));
    emitExpression(node.operand);
}

void C89Emitter::emitBinaryOp(const ASTBinaryOpNode& node) {
    emitExpression(node.left);
    writeString(" ");
    writeString(getTokenSpelling(node.op));
    writeString(" ");
    emitExpression(node.right);
}

void C89Emitter::emitCast(const ASTNode* node) {
    switch (node->type) {
        case NODE_PTR_CAST:
            writeString("(");
            emitType(node->as.ptr_cast->target_type->resolved_type);
            writeString(")");
            emitExpression(node->as.ptr_cast->expr);
            break;
        case NODE_INT_CAST:
            emitIntCast(node->as.numeric_cast);
            break;
        case NODE_FLOAT_CAST:
            emitFloatCast(node->as.numeric_cast);
            break;
        default: break;
    }
}

void C89Emitter::emitAccess(const ASTNode* node) {
    switch (node->type) {
        case NODE_ARRAY_ACCESS: {
            const ASTNode* array_node = node->as.array_access->array;
            Type* array_type = array_node->resolved_type;
            bool is_ptr_to_array = (array_type && array_type->kind == TYPE_POINTER &&
                                    array_type->as.pointer.base->kind == TYPE_ARRAY);

            if (is_ptr_to_array) {
                writeString("(*");
            }

            bool need_parens = requiresParentheses(array_node);
            if (need_parens) writeString("(");
            emitExpression(array_node);
            if (need_parens) writeString(")");

            if (is_ptr_to_array) {
                writeString(")");
            }

            writeString("[");
            emitExpression(node->as.array_access->index);
            writeString("]");
            break;
        }
        case NODE_MEMBER_ACCESS: {
            const ASTNode* base = node->as.member_access->base;
            if (base->resolved_type) {
                Type* actual_type = base->resolved_type;

                if (actual_type->kind == TYPE_ERROR_SET) {
                    writeString("ERROR_");
                    writeString(node->as.member_access->field_name);
                    return;
                }

                if (actual_type->kind == TYPE_ENUM) {
                    if (actual_type->c_name) {
                        writeString(actual_type->c_name);
                    } else if (actual_type->as.enum_details.name) {
                        writeString(getC89GlobalName(actual_type->as.enum_details.name));
                    } else {
                        writeString("/* anonymous enum */");
                    }
                    writeString("_");
                    writeString(node->as.member_access->field_name);
                    return;
                }

                if (actual_type->kind == TYPE_MODULE || actual_type->kind == TYPE_ANYTYPE) {
                    if (node->as.member_access->symbol && node->as.member_access->symbol->mangled_name) {
                        writeString(node->as.member_access->symbol->mangled_name);
                    } else {
                        const char* mod_name = (actual_type->kind == TYPE_MODULE) ?
                                              actual_type->as.module.name :
                                              (base->type == NODE_IDENTIFIER ? base->as.identifier.name : NULL);
                        if (mod_name) {
                            writeString("z_");
                            writeString(mod_name);
                            writeString("_");
                            writeString(node->as.member_access->field_name);
                        } else {
                            writeString(node->as.member_access->field_name);
                        }
                    }
                    return;
                }
            }

            bool need_parens = requiresParentheses(base);
            if (need_parens) writeString("(");
            emitExpression(base);
            if (need_parens) writeString(")");

            if (base->resolved_type && base->resolved_type->kind == TYPE_POINTER) {
                writeString("->");
            } else {
                writeString(".");
            }
            writeString(node->as.member_access->field_name);
            break;
        }
        case NODE_ARRAY_SLICE:
            emitArraySlice(node);
            break;
        default: break;
    }
}

void C89Emitter::emitControlFlow(const ASTNode* node) {
    const char* kind = "unknown control flow";
    switch (node->type) {
        case NODE_SWITCH_EXPR: kind = "Switch expression"; break;
        case NODE_IF_EXPR:     kind = "If expression"; break;
        case NODE_TRY_EXPR:    kind = "Try expression"; break;
        case NODE_CATCH_EXPR:  kind = "Catch expression"; break;
        case NODE_ORELSE_EXPR: kind = "Orelse expression"; break;
        default: break;
    }
    error_handler_.report(ERR_UNSUPPORTED_FEATURE, node->loc, ErrorHandler::getMessage(ERR_UNSUPPORTED_FEATURE), kind);
}

void C89Emitter::emitArraySlice(const ASTNode* node) {
    if (!node || node->type != NODE_ARRAY_SLICE) return;
    const ASTArraySliceNode* slice = node->as.array_slice;
    if (!slice || !slice->base_ptr || !slice->len) return;

    Type* result_type = node->resolved_type;
    if (!result_type || result_type->kind != TYPE_SLICE) return;

    Type* elem_type = result_type->as.slice.element_type;

    ensureSliceType(result_type);

    writeString("__make_slice_");
    writeString(getMangledTypeName(elem_type));
    writeString("(");
    emitExpression(slice->base_ptr);
    writeString(", ");
    emitExpression(slice->len);
    writeString(")");
}

void C89Emitter::ensureOptionalType(Type* type) {
    if (!type || type->kind != TYPE_OPTIONAL) return;

    const char* mangled_name = getMangledTypeName(type);

    // Check cache
    for (size_t i = 0; i < emitted_optionals_.length(); ++i) {
        if (plat_strcmp(emitted_optionals_[i], mangled_name) == 0) return;
    }

    // Check external cache (if any)
    if (external_cache_) {
        for (size_t j = 0; j < external_cache_->length(); ++j) {
            if (plat_strcmp((*external_cache_)[j], mangled_name) == 0) return;
        }
    }

    emitted_optionals_.append(mangled_name);
    if (external_cache_) {
        external_cache_->append(mangled_name);
    }

    bool was_in_type_def = in_type_def_mode_;
    in_type_def_mode_ = true;

    Type* payload = type->as.optional.payload;

    writeIndent();
    writeString("typedef struct {\n");
    {
        IndentScope struct_indent(*this);
        if (payload->kind != TYPE_VOID) {
            writeIndent();
            emitType(payload, "value");
            writeString(";\n");
        }
        writeIndent();
        writeString("int has_value;\n");
    }
    writeIndent();
    writeString("} ");
    writeString(mangled_name);
    writeString(";\n\n");

    in_type_def_mode_ = was_in_type_def;
}

void C89Emitter::ensureErrorUnionType(Type* type) {
    if (!type || type->kind != TYPE_ERROR_UNION) return;

    const char* mangled_name = getMangledTypeName(type);

    // Check cache
    for (size_t i = 0; i < emitted_error_unions_.length(); ++i) {
        if (plat_strcmp(emitted_error_unions_[i], mangled_name) == 0) return;
    }

    // Check external cache (if any)
    if (external_cache_) {
        for (size_t j = 0; j < external_cache_->length(); ++j) {
            if (plat_strcmp((*external_cache_)[j], mangled_name) == 0) return;
        }
    }

    emitted_error_unions_.append(mangled_name);
    if (external_cache_) {
        external_cache_->append(mangled_name);
    }

    bool was_in_type_def = in_type_def_mode_;
    in_type_def_mode_ = true;

    Type* payload = type->as.error_union.payload;

    writeIndent();
    writeString("typedef struct {\n");
    {
        IndentScope struct_indent(*this);
        if (payload->kind != TYPE_VOID) {
            writeIndent();
            writeString("union {\n");
            {
                IndentScope union_indent(*this);
                writeIndent();
                emitType(payload, "payload");
                writeString(";\n");
                writeIndent();
                writeString("int err;\n");
            }
            writeIndent();
            writeString("} data;\n");
        } else {
            writeIndent();
            writeString("int err;\n");
        }
        writeIndent();
        writeString("int is_error;\n");
    }
    writeIndent();
    writeString("} ");
    writeString(mangled_name);
    writeString(";\n\n");

    in_type_def_mode_ = was_in_type_def;
}

void C89Emitter::ensureSliceType(Type* type) {
    if (!type || type->kind != TYPE_SLICE) return;

    const char* mangled_name = getMangledTypeName(type);

    // Check internal cache
    for (size_t i = 0; i < emitted_slices_.length(); ++i) {
        if (plat_strcmp(emitted_slices_[i], mangled_name) == 0) return;
    }

    // Check external cache (if any)
    if (external_cache_) {
        for (size_t j = 0; j < external_cache_->length(); ++j) {
            if (plat_strcmp((*external_cache_)[j], mangled_name) == 0) return;
        }
    }

    // Not emitted, so emit it now
    emitted_slices_.append(mangled_name);
    if (external_cache_) {
        external_cache_->append(mangled_name);
    }

    bool was_in_type_def = in_type_def_mode_;
    in_type_def_mode_ = true;

    Type* elem_type = type->as.slice.element_type;
    const char* slice_struct_name = mangled_name;

    writeIndent();
    writeString("typedef struct { ");
    emitType(elem_type);
    writeString("* ptr; usize len; } ");
    writeString(slice_struct_name);
    writeString(";\n");

    // Emit helper: static inline Slice_T __make_slice_T(T* ptr, usize len)
    writeIndent();
    writeString("static RETR_UNUSED_FUNC ");
    writeString(slice_struct_name);
    writeString(" __make_slice_");
    writeString(getMangledTypeName(elem_type));
    writeString("(");
    emitType(elem_type);
    writeString("* ptr, usize len) {\n");
    {
        IndentScope func_indent(*this);
        writeIndent();
        writeString(slice_struct_name);
        writeString(" s;\n");
        writeIndent();
        writeString("s.ptr = ptr;\n");
        writeIndent();
        writeString("s.len = len;\n");
        writeIndent();
        writeString("return s;\n");
    }
    writeIndent();
    writeString("}\n\n");

    in_type_def_mode_ = was_in_type_def;
}

void C89Emitter::emitBufferedTypeDefinitions() {
    if (type_def_pos_ > 0) {
        write(type_def_buffer_, type_def_pos_);
        type_def_pos_ = 0;
    }
}

void C89Emitter::emitTypeDefinition(const ASTNode* node) {
    if (!node) return;

    if (node->type == NODE_VAR_DECL) {
        const ASTVarDeclNode* decl = node->as.var_decl;
        if (!decl || !decl->initializer) return;

        Type* type = decl->initializer->resolved_type;
        if (!type) return;

        // Only emit definition if this is a type declaration (e.g. const T = struct { ... })
        // In our current TypeChecker, these might not have TYPE_TYPE yet, but the initializer
        // will have the actual composite type.
        if (!decl->is_const || (type->kind != TYPE_STRUCT && type->kind != TYPE_UNION && type->kind != TYPE_ENUM)) {
            return;
        }
        if (type->kind == TYPE_STRUCT) {
            if (!type->c_name) {
                type->c_name = getC89GlobalName(decl->name);
            }
            writeIndent();
            writeString("struct ");
            writeString(type->c_name);
            writeString(" {\n");
            {
                IndentScope struct_indent(*this);
                DynamicArray<StructField>* fields = type->as.struct_details.fields;
                for (size_t i = 0; i < fields->length(); ++i) {
                    writeIndent();
                    emitType((*fields)[i].type, (*fields)[i].name);
                    writeString(";\n");
                }
            }
            writeIndent();
            writeString("};\n\n");
        } else if (type->kind == TYPE_UNION) {
            if (!type->c_name) {
                type->c_name = getC89GlobalName(decl->name);
            }
            writeIndent();
            if (type->as.struct_details.is_tagged) {
                // If the tag type is an implicit enum with a name, we should ensure it's defined.
                // For now, assume it's either primitive (int) or was already scanned.
                writeString("struct ");
                writeString(type->c_name);
                writeString(" {\n");
                {
                    IndentScope struct_indent(*this);
                    writeIndent();
                    emitType(type->as.struct_details.tag_type, "tag");
                    writeString(";\n");
                    writeIndent();
                    writeString("union {\n");
                    {
                        IndentScope union_indent(*this);
                        DynamicArray<StructField>* fields = type->as.struct_details.fields;
                        for (size_t i = 0; i < fields->length(); ++i) {
                            writeIndent();
                            emitType((*fields)[i].type, (*fields)[i].name);
                            writeString(";\n");
                        }
                    }
                    writeIndent();
                    writeString("} data;\n");
                }
                writeIndent();
                writeString("};\n\n");
            } else {
                writeString("union ");
                writeString(type->c_name);
                writeString(" {\n");
                {
                    IndentScope union_indent(*this);
                    DynamicArray<StructField>* fields = type->as.struct_details.fields;
                    for (size_t i = 0; i < fields->length(); ++i) {
                        writeIndent();
                        emitType((*fields)[i].type, (*fields)[i].name);
                        writeString(";\n");
                    }
                }
                writeIndent();
                writeString("};\n\n");
            }
        } else if (type->kind == TYPE_ENUM) {
            // C89 doesn't support specific backing types for enums, they are always int.
            // But we can emit a typedef if needed.
            if (!type->c_name) {
                type->c_name = getC89GlobalName(decl->name);
            }
            writeIndent();
            writeString("enum ");
            const char* enum_name = type->c_name;
            writeString(enum_name);
            writeString(" {\n");
            {
                IndentScope enum_indent(*this);
                DynamicArray<EnumMember>* members = type->as.enum_details.members;
                for (size_t i = 0; i < members->length(); ++i) {
                    writeIndent();
                    writeString(enum_name);
                    writeString("_");
                    writeString((*members)[i].name);
                    writeString(" = ");
                    char buf[32];
                    plat_i64_to_string((*members)[i].value, buf, sizeof(buf));
                    writeString(buf);
                    if (i < members->length() - 1) {
                        writeString(",");
                    }
                    writeString("\n");
                }
            }
            writeIndent();
            writeString("};\n");
            writeIndent();
            writeString("typedef enum ");
            writeString(enum_name);
            writeString(" ");
            writeString(enum_name);
            writeString(";\n\n");
        }
    }
}

void C89Emitter::emitIntCast(const ASTNumericCastNode* node) {
    if (!node || !node->expr || !node->target_type) return;

    Type* src_type = node->expr->resolved_type;
    Type* dest_type = node->target_type->resolved_type;

    if (!src_type || !dest_type) {
        plat_print_debug("Error: Missing type info in @intCast\n");
        plat_abort();
    }

    if (isSafeWidening(src_type, dest_type)) {
        writeString("(");
        emitType(dest_type);
        writeString(")");
        emitExpression(node->expr);
    } else {
        writeString("__bootstrap_");
        writeString(getZigTypeName(dest_type));
        writeString("_from_");
        writeString(getZigTypeName(src_type));
        writeString("(");
        emitExpression(node->expr);
        writeString(")");
    }
}

void C89Emitter::emitFloatCast(const ASTNumericCastNode* node) {
    if (!node || !node->expr || !node->target_type) return;

    Type* src_type = node->expr->resolved_type;
    Type* dest_type = node->target_type->resolved_type;

    if (!src_type || !dest_type) {
        plat_print_debug("Error: Missing type info in @floatCast\n");
        plat_abort();
    }

    if (isSafeWidening(src_type, dest_type)) {
        writeString("(");
        emitType(dest_type);
        writeString(")");
        emitExpression(node->expr);
    } else {
        writeString("__bootstrap_");
        writeString(getZigTypeName(dest_type));
        writeString("_from_");
        writeString(getZigTypeName(src_type));
        writeString("(");
        emitExpression(node->expr);
        writeString(")");
    }
}

void C89Emitter::emitIntegerLiteral(const ASTIntegerLiteralNode* node) {
    if (node->original_name && node->resolved_type && node->resolved_type->kind == TYPE_ENUM) {
        if (node->resolved_type->c_name) {
            writeString(node->resolved_type->c_name);
        } else if (node->resolved_type->as.enum_details.name) {
            writeString(getC89GlobalName(node->resolved_type->as.enum_details.name));
        } else {
            writeString("/* anonymous enum */");
        }
        writeString("_");
        writeString(node->original_name);
        return;
    }

    char buf[32];
    plat_u64_to_string(node->value, buf, sizeof(buf));
    writeString(buf);

    if (node->resolved_type) {
        switch (node->resolved_type->kind) {
            case TYPE_U32:
                writeString("U");
                break;
            case TYPE_I64:
                writeString("i64");
                break;
            case TYPE_U64:
                writeString("ui64");
                break;
            default:
                // i32, u8, i8, u16, i16, usize, isize get no suffix
                break;
        }
    }
}

void C89Emitter::emitFloatLiteral(const ASTFloatLiteralNode* node) {
    char buffer[64];
    plat_float_to_string(node->value, buffer, sizeof(buffer));

    // Ensure it's treated as a float by C (add .0 if no '.' or 'e')
    bool has_dot = false;
    bool has_exp = false;
    for (char* p = buffer; *p; ++p) {
        if (*p == '.') has_dot = true;
        if (*p == 'e' || *p == 'E') has_exp = true;
    }

    writeString(buffer);
    if (!has_dot && !has_exp) {
        writeString(".0");
    }

    if (node->resolved_type && node->resolved_type->kind == TYPE_F32) {
        writeString("f");
    }
}

void C89Emitter::emitStringLiteral(const ASTStringLiteralNode* node) {
    if (!node || !node->value) return;

    // TODO: Split long strings if needed for MSVC 6.0
    write("\"", 1);
    const char* p = node->value;
    while (*p) {
        emitEscapedByte((unsigned char)*p, false);
        p++;
    }
    write("\"", 1);
}

void C89Emitter::emitCharLiteral(const ASTCharLiteralNode* node) {
    if (!node) return;
    write("'", 1);
    emitEscapedByte((unsigned char)node->value, true);
    write("'", 1);
}

const char* C89Emitter::getC89GlobalName(const char* zig_name) {
    if (!zig_name) return "z_anonymous";

    // Check cache first
    for (size_t i = 0; i < global_names_.length(); ++i) {
        if (plat_strcmp(global_names_[i].zig_name, zig_name) == 0) {
            return global_names_[i].c89_name;
        }
    }

    char buf[256];
    char* cur = buf;
    size_t rem = sizeof(buf);

    if (module_name_ && plat_strcmp(module_name_, "main") != 0 &&
        plat_strcmp(module_name_, "test") != 0 && plat_strcmp(zig_name, "main") != 0) {
        safe_append(cur, rem, "z_");
        safe_append(cur, rem, module_name_);
        safe_append(cur, rem, "_");
    } else if (isCKeyword(zig_name)) {
        safe_append(cur, rem, "z_");
    }
    safe_append(cur, rem, zig_name);

    // Sanitize (handles remaining invalid characters and starting digits)
    sanitizeForC89(buf);

    // Truncate to 31 characters for C89/MSVC 6.0
    if (plat_strlen(buf) > 31) {
        buf[31] = '\0';
    }

    // Ensure uniqueness within this translation unit
    char final_buf[256];
    plat_strcpy(final_buf, buf);
    int suffix = 0;
    bool unique = false;

    while (!unique) {
        unique = true;
        for (size_t i = 0; i < global_names_.length(); ++i) {
            if (plat_strcmp(global_names_[i].c89_name, final_buf) == 0) {
                unique = false;
                break;
            }
        }

        if (!unique) {
            suffix++;
            char suffix_str[16];
            plat_i64_to_string(suffix, suffix_str, sizeof(suffix_str));
            size_t suffix_len = plat_strlen(suffix_str);
            size_t base_len = plat_strlen(buf);

            if (base_len + suffix_len > 31) {
                size_t truncate_at = 31 - suffix_len;
                plat_strncpy(final_buf, buf, truncate_at);
                final_buf[truncate_at] = '\0';
                plat_strcat(final_buf, suffix_str);
            } else {
                plat_strcpy(final_buf, buf);
                plat_strcat(final_buf, suffix_str);
            }
        }
    }

    size_t len = plat_strlen(final_buf);
    char* owned_name = (char*)arena_.alloc(len + 1);
    plat_memcpy(owned_name, final_buf, len + 1);

    GlobalNameEntry entry;
    entry.zig_name = zig_name;
    entry.c89_name = owned_name;
    global_names_.append(entry);

    return owned_name;
}

bool C89Emitter::requiresParentheses(const ASTNode* node) const {
    if (!node) return false;
    switch (node->type) {
        // Postfix and primary expressions (Level 1 in C)
        case NODE_IDENTIFIER:
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
        case NODE_PAREN_EXPR:
        case NODE_FUNCTION_CALL:
        case NODE_ARRAY_ACCESS:
        case NODE_MEMBER_ACCESS:
            return false;

        // Everything else has lower precedence than postfix operators
        default:
            return true;
    }
}

bool C89Emitter::isSafeWidening(Type* src, Type* dest) const {
    if (!src || !dest) return false;

    // Integer widening
    bool src_is_int = (src->kind >= TYPE_I8 && src->kind <= TYPE_U64) || src->kind == TYPE_ISIZE || src->kind == TYPE_USIZE;
    bool dest_is_int = (dest->kind >= TYPE_I8 && dest->kind <= TYPE_U64) || dest->kind == TYPE_ISIZE || dest->kind == TYPE_USIZE;

    if (src_is_int && dest_is_int) {
        // Signedness must match
        bool src_signed = (src->kind == TYPE_I8 || src->kind == TYPE_I16 || src->kind == TYPE_I32 || src->kind == TYPE_I64 || src->kind == TYPE_ISIZE);
        bool dest_signed = (dest->kind == TYPE_I8 || dest->kind == TYPE_I16 || dest->kind == TYPE_I32 || dest->kind == TYPE_I64 || dest->kind == TYPE_ISIZE);

        if (src_signed != dest_signed) return false;

        // Size must be non-decreasing
        return dest->size >= src->size;
    }

    // Float widening
    if (src->kind == TYPE_F32 || src->kind == TYPE_F64) {
        if (dest->kind == TYPE_F32 || dest->kind == TYPE_F64) {
            return dest->size >= src->size;
        }
    }

    return false;
}

const char* C89Emitter::getZigTypeName(Type* type) const {
    if (!type) return "unknown";
    switch (type->kind) {
        case TYPE_VOID: return "void";
        case TYPE_BOOL: return "bool";
        case TYPE_I8:   return "i8";
        case TYPE_U8:   return "u8";
        case TYPE_I16:  return "i16";
        case TYPE_U16:  return "u16";
        case TYPE_I32:  return "i32";
        case TYPE_U32:  return "u32";
        case TYPE_I64:  return "i64";
        case TYPE_U64:  return "u64";
        case TYPE_F32:  return "f32";
        case TYPE_F64:  return "f64";
        case TYPE_ISIZE: return "isize";
        case TYPE_USIZE: return "usize";
        default: return "unknown";
    }
}

const char* C89Emitter::getMangledTypeName(Type* type) {
    if (!type) return "void";

    char buf[1024];
    char* cur = buf;
    size_t rem = sizeof(buf);

    switch (type->kind) {
        case TYPE_VOID: safe_append(cur, rem, "void"); break;
        case TYPE_BOOL: safe_append(cur, rem, "bool"); break;
        case TYPE_I8:   safe_append(cur, rem, "i8"); break;
        case TYPE_U8:   safe_append(cur, rem, "u8"); break;
        case TYPE_I16:  safe_append(cur, rem, "i16"); break;
        case TYPE_U16:  safe_append(cur, rem, "u16"); break;
        case TYPE_I32:  safe_append(cur, rem, "i32"); break;
        case TYPE_U32:  safe_append(cur, rem, "u32"); break;
        case TYPE_I64:  safe_append(cur, rem, "i64"); break;
        case TYPE_U64:  safe_append(cur, rem, "u64"); break;
        case TYPE_F32:  safe_append(cur, rem, "f32"); break;
        case TYPE_F64:  safe_append(cur, rem, "f64"); break;
        case TYPE_ISIZE: safe_append(cur, rem, "isize"); break;
        case TYPE_USIZE: safe_append(cur, rem, "usize"); break;
        case TYPE_POINTER:
            safe_append(cur, rem, "Ptr_");
            safe_append(cur, rem, getMangledTypeName(type->as.pointer.base));
            break;
        case TYPE_SLICE:
            safe_append(cur, rem, "Slice_");
            safe_append(cur, rem, getMangledTypeName(type->as.slice.element_type));
            break;
        case TYPE_ERROR_UNION:
            safe_append(cur, rem, "ErrorUnion_");
            safe_append(cur, rem, getMangledTypeName(type->as.error_union.payload));
            break;
        case TYPE_OPTIONAL:
            safe_append(cur, rem, "Optional_");
            safe_append(cur, rem, getMangledTypeName(type->as.optional.payload));
            break;
        case TYPE_ERROR_SET:
            safe_append(cur, rem, "ErrorSet");
            break;
        case TYPE_ARRAY: {
            safe_append(cur, rem, "Arr_");
            char size_buf[32];
            plat_u64_to_string(type->as.array.size, size_buf, sizeof(size_buf));
            safe_append(cur, rem, size_buf);
            safe_append(cur, rem, "_");
            safe_append(cur, rem, getMangledTypeName(type->as.array.element_type));
            break;
        }
        case TYPE_FUNCTION:
        case TYPE_FUNCTION_POINTER: {
            safe_append(cur, rem, "Fn_");
            Type* ret = (type->kind == TYPE_FUNCTION) ? type->as.function.return_type : type->as.function_pointer.return_type;
            safe_append(cur, rem, getMangledTypeName(ret));
            DynamicArray<Type*>* params = (type->kind == TYPE_FUNCTION) ? type->as.function.params : type->as.function_pointer.param_types;
            if (params) {
                for (size_t i = 0; i < params->length(); ++i) {
                    safe_append(cur, rem, "_");
                    safe_append(cur, rem, getMangledTypeName((*params)[i]));
                }
            }
            break;
        }
        case TYPE_PLACEHOLDER:
            if (type->c_name) {
                safe_append(cur, rem, type->c_name);
            } else {
                safe_append(cur, rem, type->as.placeholder.name);
            }
            break;
        case TYPE_STRUCT:
        case TYPE_UNION:
        case TYPE_ENUM: {
            const char* name = NULL;
            if (type->kind == TYPE_ENUM) name = type->as.enum_details.name;
            else name = type->as.struct_details.name;

            if (type->c_name) {
                safe_append(cur, rem, type->c_name);
            } else if (name) {
                safe_append(cur, rem, getC89GlobalName(name));
            } else {
                safe_append(cur, rem, "anon");
            }
            break;
        }
        default:
            safe_append(cur, rem, "unknown");
            break;
    }

    return unit_.getStringInterner().intern(buf);
}

void C89Emitter::emitEscapedByte(unsigned char c, bool is_char_literal) {
    switch (c) {
        case '\a': write("\\a", 2); return;
        case '\b': write("\\b", 2); return;
        case '\f': write("\\f", 2); return;
        case '\n': write("\\n", 2); return;
        case '\r': write("\\r", 2); return;
        case '\t': write("\\t", 2); return;
        case '\v': write("\\v", 2); return;
        case '\\': write("\\\\", 2); return;
        case '\'':
            if (is_char_literal) write("\\'", 2);
            else write("'", 1);
            return;
        case '\"':
            if (!is_char_literal) write("\\\"", 2);
            else write("\"", 1);
            return;
        default:
            if (c >= 32 && c <= 126) {
                char ch = (char)c;
                write(&ch, 1);
            } else {
                char buf[8];
                // Use octal escape \ooo (three digits zero-padded)
                buf[0] = '\\';
                buf[1] = (char)((c >> 6) & 7) + '0';
                buf[2] = (char)((c >> 3) & 7) + '0';
                buf[3] = (char)(c & 7) + '0';
                buf[4] = '\0';
                writeString(buf);
            }
    }
}

void C89Emitter::emitOptionalWrapping(const char* target_name, const ASTNode* target_node, Type* target_type, const ASTNode* rvalue) {
    if (!target_type) target_type = target_node ? target_node->resolved_type : NULL;
    Type* source_type = rvalue->resolved_type;

    if (source_type->kind == TYPE_NULL) {
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".has_value = 0;\n");
    } else {
        if (target_type->as.optional.payload->kind != TYPE_VOID) {
            writeIndent();
            if (target_name) writeString(target_name); else emitExpression(target_node);
            writeString(".value = ");
            emitExpression(rvalue);
            writeString(";\n");
        }
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".has_value = 1;\n");
    }
}

void C89Emitter::emitOptionalWrapping(const char* target_name, const ASTNode* target_node, Type* target_type, const char* source_expr, Type* source_type) {
    if (!target_type) target_type = target_node ? target_node->resolved_type : NULL;

    if (source_type->kind == TYPE_NULL) {
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".has_value = 0;\n");
    } else {
        if (target_type->as.optional.payload->kind != TYPE_VOID) {
            writeIndent();
            if (target_name) writeString(target_name); else emitExpression(target_node);
            writeString(".value = ");
            if (source_expr) writeString(source_expr); else writeString("0");
            writeString(";\n");
        }
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".has_value = 1;\n");
    }
}

void C89Emitter::emitErrorUnionWrapping(const char* target_name, const ASTNode* target_node, Type* target_type, const ASTNode* rvalue) {
    if (!target_type) target_type = target_node ? target_node->resolved_type : NULL;
    Type* source_type = rvalue->resolved_type;

    if (source_type->kind == TYPE_ERROR_SET) {
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        if (target_type->as.error_union.payload->kind != TYPE_VOID) {
            writeString(".data.err = ");
        } else {
            writeString(".err = ");
        }
        emitExpression(rvalue);
        writeString(";\n");
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".is_error = 1;\n");
    } else {
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        if (target_type->as.error_union.payload->kind != TYPE_VOID) {
            writeString(".data.payload = ");
            emitExpression(rvalue);
            writeString(";\n");
        }
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".is_error = 0;\n");
    }
}

void C89Emitter::emitErrorUnionWrapping(const char* target_name, const ASTNode* target_node, Type* target_type, const char* source_expr, Type* source_type) {
    if (!target_type) target_type = target_node ? target_node->resolved_type : NULL;

    if (source_type->kind == TYPE_ERROR_SET) {
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        if (target_type->as.error_union.payload->kind != TYPE_VOID) {
            writeString(".data.err = ");
        } else {
            writeString(".err = ");
        }
        if (source_expr) writeString(source_expr); else writeString("0");
        writeString(";\n");
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".is_error = 1;\n");
    } else {
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        if (target_type->as.error_union.payload->kind != TYPE_VOID) {
            writeString(".data.payload = ");
            if (source_expr) writeString(source_expr); else writeString("0");
            writeString(";\n");
        }
        writeIndent();
        if (target_name) writeString(target_name); else emitExpression(target_node);
        writeString(".is_error = 0;\n");
    }
}

void C89Emitter::emitDefersForScopeExit(int target_label_id) {
    for (int i = (int)defer_stack_.length() - 1; i >= 0; --i) {
        DeferScope* scope = defer_stack_[i];
        if (!scope) continue;
        for (int j = (int)scope->defers.length() - 1; j >= 0; --j) {
            if (scope->defers[j] && scope->defers[j]->statement) {
                emitStatement(scope->defers[j]->statement);
            }
        }
        if (target_label_id != -1 && scope->label_id == target_label_id) {
            break;
        }
    }
}

void C89Emitter::emitBreak(const ASTBreakStmtNode* node) {
    writeIndent();
    if (defer_stack_.length() > 0) {
        writeString("/* defers for break */\n");
        emitDefersForScopeExit(node->target_label_id);
        writeIndent();
    }

    if (node->label) {
        char label_buf[256];
        char* cur = label_buf;
        size_t rem = sizeof(label_buf);
        safe_append(cur, rem, "goto __zig_label_");
        safe_append(cur, rem, node->label);
        safe_append(cur, rem, "_");
        char id_buf[16];
        plat_i64_to_string(node->target_label_id, id_buf, sizeof(id_buf));
        safe_append(cur, rem, id_buf);
        safe_append(cur, rem, "_end;\n");
        writeString(label_buf);
    } else {
        writeString("break;\n");
    }
}

void C89Emitter::emitContinue(const ASTContinueStmtNode* node) {
    writeIndent();
    if (defer_stack_.length() > 0) {
        writeString("/* defers for continue */\n");
        emitDefersForScopeExit(node->target_label_id);
        writeIndent();
    }

    if (node->label) {
        char label_buf[256];
        char* cur = label_buf;
        size_t rem = sizeof(label_buf);
        safe_append(cur, rem, "goto __zig_label_");
        safe_append(cur, rem, node->label);
        safe_append(cur, rem, "_");
        char id_buf[16];
        plat_i64_to_string(node->target_label_id, id_buf, sizeof(id_buf));
        safe_append(cur, rem, id_buf);
        safe_append(cur, rem, "_start;\n");
        writeString(label_buf);
    } else {
        writeString("continue;\n");
    }
}

void C89Emitter::emitReturn(const ASTReturnStmtNode* node) {
    if (!node) return;

    bool has_defers = false;
    for (size_t i = 0; i < defer_stack_.length(); ++i) {
        if (defer_stack_[i]->defers.length() > 0) {
            has_defers = true;
            break;
        }
    }

    Type* source_type = (node->expression && node->expression->resolved_type) ? node->expression->resolved_type : get_g_type_void();
    bool needs_wrapping = (current_fn_ret_type_ && current_fn_ret_type_->kind == TYPE_ERROR_UNION &&
                           source_type && source_type->kind != TYPE_ERROR_UNION);
    bool needs_opt_wrapping = (current_fn_ret_type_ && current_fn_ret_type_->kind == TYPE_OPTIONAL &&
                               source_type && source_type->kind != TYPE_OPTIONAL);
    bool is_special = (node->expression && (node->expression->type == NODE_TRY_EXPR ||
                                          node->expression->type == NODE_CATCH_EXPR ||
                                          node->expression->type == NODE_ORELSE_EXPR ||
                                          node->expression->type == NODE_SWITCH_EXPR ||
                                          node->expression->type == NODE_IF_EXPR));

    if (has_defers || needs_wrapping || needs_opt_wrapping || is_special ||
        (node->expression && node->expression->type == NODE_STRUCT_INITIALIZER)) {
        writeIndent();
        writeString("{\n");
        {
            IndentScope scope_indent(*this);

            if (current_fn_ret_type_->kind != TYPE_VOID) {
                writeIndent();
                emitType(current_fn_ret_type_, "__return_val");
                writeString(";\n");

                if (node->expression) {
                    emitAssignmentWithLifting("__return_val", NULL, node->expression, current_fn_ret_type_);
                }

                emitDefersForScopeExit(-1);

                writeIndent();
                writeString("return __return_val;\n");
            } else {
                if (node->expression) {
                    emitAssignmentWithLifting(NULL, NULL, node->expression, NULL);
                }
                emitDefersForScopeExit(-1);
                writeIndent();
                writeString("return;\n");
            }
        }
        writeIndent();
        writeString("}\n");
    } else {
        writeIndent();
        if (node->expression) {
            writeString("return ");
            emitExpression(node->expression);
            writeString(";\n");
        } else {
            writeString("return;\n");
        }
    }
}
