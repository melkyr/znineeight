#include "codegen.hpp"
#include "ast_utils.hpp"
#include "platform.hpp"
#include "utils.hpp"
#include "symbol_table.hpp"
#include <cstdio>


C89Emitter::C89Emitter(ArenaAllocator& arena, ErrorHandler& error_handler)
    : buffer_pos_(0), output_file_(PLAT_INVALID_FILE), indent_level_(0), owns_file_(false),
      var_alloc_(arena), error_handler_(error_handler), arena_(arena), global_names_(arena) {
}

C89Emitter::C89Emitter(ArenaAllocator& arena, ErrorHandler& error_handler, const char* path)
    : buffer_pos_(0), indent_level_(0), owns_file_(true),
      var_alloc_(arena), error_handler_(error_handler), arena_(arena), global_names_(arena) {
    output_file_ = plat_open_file(path, true);
}

C89Emitter::C89Emitter(ArenaAllocator& arena, ErrorHandler& error_handler, PlatFile file)
    : buffer_pos_(0), output_file_(file), indent_level_(0), owns_file_(false),
      var_alloc_(arena), error_handler_(error_handler), arena_(arena), global_names_(arena) {
}

C89Emitter::~C89Emitter() {
    close();
}

void C89Emitter::indent() {
    indent_level_++;
}

void C89Emitter::dedent() {
    if (indent_level_ > 0) {
        indent_level_--;
    }
}

void C89Emitter::writeIndent() {
    for (int i = 0; i < indent_level_; ++i) {
        write("    ", 4);
    }
}

void C89Emitter::emitPrologue() {
    emitComment("Generated by RetroZig bootstrap compiler");
    writeString("#include \"zig_runtime.h\"\n\n");
}

void C89Emitter::beginFunction() {
    var_alloc_.reset();
}

void C89Emitter::emitType(Type* type, const char* name) {
    if (!type) {
        writeString("void");
        if (name) { writeString(" "); writeString(name); }
        return;
    }

    // Handle recursion for pointers and arrays
    if (type->kind == TYPE_POINTER) {
        if (type->as.pointer.base->kind == TYPE_ARRAY) {
            // Pointer to array: Base (*name)[N1][N2]...
            Type* arr_type = type->as.pointer.base;
            Type* base_elem = arr_type;
            while (base_elem->kind == TYPE_ARRAY) base_elem = base_elem->as.array.element_type;

            if (type->as.pointer.is_const) {
                writeString("const ");
            }
            emitType(base_elem);
            writeString(" (*");
            if (name) writeString(name);
            writeString(")");

            // Emit all array dimensions
            Type* curr = arr_type;
            while (curr->kind == TYPE_ARRAY) {
                char buf[32];
                writeString("[");
                plat_u64_to_string(curr->as.array.size, buf, sizeof(buf));
                writeString(buf);
                writeString("]");
                curr = curr->as.array.element_type;
            }
            return;
        }

        if (type->as.pointer.is_const) {
            writeString("const ");
        }
        emitType(type->as.pointer.base);
        writeString("*");
        if (name) {
            writeString(" ");
            writeString(name);
        }
        return;
    }

    if (type->kind == TYPE_ARRAY) {
        Type* base_elem = type;
        while (base_elem->kind == TYPE_ARRAY) base_elem = base_elem->as.array.element_type;

        emitType(base_elem);
        if (name) {
            writeString(" ");
            writeString(name);
        }

        Type* curr = type;
        while (curr->kind == TYPE_ARRAY) {
            char buf[32];
            writeString("[");
            plat_u64_to_string(curr->as.array.size, buf, sizeof(buf));
            writeString(buf);
            writeString("]");
            curr = curr->as.array.element_type;
        }
        return;
    }

    switch (type->kind) {
        case TYPE_VOID: writeString("void"); break;
        case TYPE_BOOL: writeString("int"); break;
        case TYPE_I8: writeString("signed char"); break;
        case TYPE_U8: writeString("unsigned char"); break;
        case TYPE_I16: writeString("short"); break;
        case TYPE_U16: writeString("unsigned short"); break;
        case TYPE_I32: writeString("int"); break;
        case TYPE_U32: writeString("unsigned int"); break;
        case TYPE_I64: writeString("__int64"); break;
        case TYPE_U64: writeString("unsigned __int64"); break;
        case TYPE_F32: writeString("float"); break;
        case TYPE_F64: writeString("double"); break;
        case TYPE_ISIZE: writeString("int"); break;
        case TYPE_USIZE: writeString("unsigned int"); break;
        case TYPE_STRUCT:
            writeString("struct ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_UNION:
            writeString("union ");
            if (!type->c_name && type->as.struct_details.name) {
                type->c_name = getC89GlobalName(type->as.struct_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        case TYPE_ENUM:
            writeString("enum ");
            if (!type->c_name && type->as.enum_details.name) {
                type->c_name = getC89GlobalName(type->as.enum_details.name);
            }
            if (type->c_name) {
                writeString(type->c_name);
            } else {
                writeString("/* anonymous */");
            }
            break;
        default:
            writeString("/* unsupported type */");
            break;
    }

    if (name) {
        writeString(" ");
        writeString(name);
    }
}

void C89Emitter::emitGlobalVarDecl(const ASTNode* node, bool is_public) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    // Use flags from node, but allow override from is_public for now to avoid breaking tests
    bool external = is_public || decl->is_pub || decl->is_extern || decl->is_export;

    // Skip type declarations (e.g. const T = struct { ... })
    if (decl->is_const && decl->initializer) {
        Type* init_type = decl->initializer->resolved_type;
        if (init_type && (init_type->kind == TYPE_STRUCT || init_type->kind == TYPE_UNION || init_type->kind == TYPE_ENUM)) {
            return;
        }
    }

    if (decl->initializer && !isConstantInitializer(decl->initializer)) {
        error_handler_.report(ERR_GLOBAL_VAR_NON_CONSTANT_INIT, decl->name_loc,
            "Global variable must have a constant initializer for C89 compatibility",
            "Try using a literal or a constant expression");
        return;
    }

    writeIndent();
    if (decl->is_extern) {
        writeString("extern ");
    } else if (!external) {
        writeString("static ");
    }

    Type* type = node->resolved_type;
    const char* c_name = getC89GlobalName(decl->name);

    if (type && type->kind == TYPE_POINTER) {
        // For pointers: Type* const Name or const Type* const Name
        emitType(type); // Emits e.g. "int*" or "const int*"
        if (decl->is_const) {
            writeString(" const");
        }
        writeString(" ");
        writeString(c_name);
    } else {
        if (decl->is_const) {
            writeString("const ");
        }
        emitType(type, c_name);
    }

    if (decl->initializer) {
        writeString(" = ");
        emitExpression(decl->initializer);
    }

    writeString(";\n");
}

void C89Emitter::emitLocalVarDecl(const ASTNode* node, bool emit_assignment) {
    if (!node || node->type != NODE_VAR_DECL) return;
    const ASTVarDeclNode* decl = node->as.var_decl;

    if (!decl->symbol) return;
    const char* c_name = var_alloc_.allocate(decl->symbol);

    if (!emit_assignment) {
        writeIndent();
        emitType(node->resolved_type, c_name);
        writeString(";\n");
    } else {
        if (decl->initializer) {
            bool is_undefined = (decl->initializer->type == NODE_UNDEFINED_LITERAL);

            if (!is_undefined) {
                writeIndent();
                writeString(c_name);
                writeString(" = ");
                emitExpression(decl->initializer);
                writeString(";\n");
            }
        }
    }
}

void C89Emitter::emitFnProto(const ASTFnDeclNode* node, bool is_public) {
    if (!node) return;
    // For prototypes, we don't necessarily need to reset var_alloc_,
    // but we should ensure parameter names don't collide with keywords.
    // However, C89 doesn't require parameter names in prototypes.
    // Let's include them for clarity, but use a temporary allocator if needed.
    // For now, we'll just use the regular one but save/restore state if possible.
    // Since this is a bootstrap compiler, we can just use it and reset.

    writeIndent();

    // Special handling for the main entry point
    if (plat_strcmp(node->name, "main") == 0 && (node->is_pub || is_public)) {
        writeString("int main(int argc, char* argv[]);");
    } else {
        if (node->is_extern) {
            writeString("extern ");
        } else if (!is_public && !node->is_pub && !node->is_export) {
            writeString("static ");
        }

        Type* return_type = node->return_type ? node->return_type->resolved_type : NULL;
        const char* mangled_name = getC89GlobalName(node->name);

        emitType(return_type, mangled_name);
        writeString("(");

        if (!node->params || node->params->length() == 0) {
            writeString("void");
        } else {
            for (size_t i = 0; i < node->params->length(); ++i) {
                ASTParamDeclNode* param = (*node->params)[i];
                // Just use the name from Zig, sanitized for keywords if it was a symbol
                // In prototype, we can even omit the name.
                emitType(param->type->resolved_type, param->name);
                if (i < node->params->length() - 1) {
                    writeString(", ");
                }
            }
        }
        writeString(");");
    }
}

void C89Emitter::emitFnDecl(const ASTFnDeclNode* node) {
    if (!node) return;
    beginFunction();

    writeIndent();

    // Special handling for the main entry point
    if (plat_strcmp(node->name, "main") == 0 && node->is_pub) {
        writeString("int main(int argc, char* argv[])");
    } else {
        if (node->is_extern) {
            writeString("extern ");
        } else if (!node->is_pub && !node->is_export) {
            writeString("static ");
        }

        Type* return_type = node->return_type ? node->return_type->resolved_type : NULL;
        const char* mangled_name = getC89GlobalName(node->name);

        emitType(return_type, mangled_name);
        writeString("(");

        if (!node->params || node->params->length() == 0) {
            writeString("void");
        } else {
            for (size_t i = 0; i < node->params->length(); ++i) {
                ASTParamDeclNode* param = (*node->params)[i];
                const char* c_param_name = var_alloc_.allocate(param->symbol);
                emitType(param->type->resolved_type, c_param_name);
                if (i < node->params->length() - 1) {
                    writeString(", ");
                }
            }
        }
        writeString(")");
    }

    if (node->body) {
        writeString(" ");
        emitBlock(&node->body->as.block_stmt);
        writeString("\n\n");
    } else {
        writeString(";\n\n");
    }
}

void C89Emitter::emitBlock(const ASTBlockStmtNode* node) {
    if (!node) return;

    writeString("{\n");
    indent();

    // Pass 1: Local declarations
    for (size_t i = 0; i < node->statements->length(); ++i) {
        ASTNode* stmt = (*node->statements)[i];
        if (stmt->type == NODE_VAR_DECL) {
            emitLocalVarDecl(stmt, false);
        }
    }

    // Pass 2: Statements
    for (size_t i = 0; i < node->statements->length(); ++i) {
        ASTNode* stmt = (*node->statements)[i];
        if (stmt->type == NODE_VAR_DECL) {
            emitLocalVarDecl(stmt, true);
        } else {
            emitStatement(stmt);
        }
    }

    dedent();
    writeIndent();
    writeString("}");
}

void C89Emitter::emitStatement(const ASTNode* node) {
    if (!node) return;

    switch (node->type) {
        case NODE_BLOCK_STMT:
            writeIndent();
            emitBlock(&node->as.block_stmt);
            writeString("\n");
            break;
        case NODE_IF_STMT:
            emitIf(node->as.if_stmt);
            break;
        case NODE_WHILE_STMT:
            emitWhile(&node->as.while_stmt);
            break;
        case NODE_RETURN_STMT:
            emitReturn(&node->as.return_stmt);
            break;
        case NODE_EXPRESSION_STMT:
            writeIndent();
            emitExpression(node->as.expression_stmt.expression);
            writeString(";\n");
            break;
        case NODE_ASSIGNMENT:
            writeIndent();
            emitExpression(node);
            writeString(";\n");
            break;
        case NODE_EMPTY_STMT:
            writeIndent();
            writeString(";\n");
            break;
        default:
            writeIndent();
            writeString("/* Unimplemented statement type ");
            char num[16];
            plat_i64_to_string(node->type, num, sizeof(num));
            writeString(num);
            writeString(" */\n");
            break;
    }
}

void C89Emitter::emitIf(const ASTIfStmtNode* node) {
    if (!node) return;

    writeIndent();
    writeString("if (");
    emitExpression(node->condition);
    writeString(") ");

    if (node->then_block->type == NODE_BLOCK_STMT) {
        emitBlock(&node->then_block->as.block_stmt);
    } else {
        emitStatement(node->then_block);
    }

    if (node->else_block) {
        writeString(" else ");
        if (node->else_block->type == NODE_IF_STMT) {
            emitIf(node->else_block->as.if_stmt);
        } else if (node->else_block->type == NODE_BLOCK_STMT) {
            emitBlock(&node->else_block->as.block_stmt);
        } else {
            emitStatement(node->else_block);
        }
    }
    writeString("\n");
}

void C89Emitter::emitWhile(const ASTWhileStmtNode* node) {
    if (!node) return;

    writeIndent();
    writeString("while (");
    emitExpression(node->condition);
    writeString(") ");

    if (node->body->type == NODE_BLOCK_STMT) {
        emitBlock(&node->body->as.block_stmt);
    } else {
        emitStatement(node->body);
    }
    writeString("\n");
}

void C89Emitter::emitReturn(const ASTReturnStmtNode* node) {
    if (!node) return;

    writeIndent();
    writeString("return");
    if (node->expression) {
        writeString(" ");
        emitExpression(node->expression);
    }
    writeString(";\n");
}

bool C89Emitter::isConstantInitializer(const ASTNode* node) const {
    if (!node) return true;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
            return true;
        case NODE_PAREN_EXPR:
            return isConstantInitializer(node->as.paren_expr.expr);
        case NODE_UNARY_OP:
            if (node->as.unary_op.op == TOKEN_AMPERSAND) {
                // Address-of is constant if operand is a global variable or member of one
                ASTNode* operand = node->as.unary_op.operand;
                if (operand->type == NODE_IDENTIFIER) return true; // Assuming identifier is global
                if (operand->type == NODE_MEMBER_ACCESS) return isConstantInitializer(operand->as.member_access->base);
                if (operand->type == NODE_ARRAY_ACCESS) return isConstantInitializer(operand->as.array_access->array);
                return false;
            }
            return isConstantInitializer(node->as.unary_op.operand);
        case NODE_BINARY_OP:
            return isConstantInitializer(node->as.binary_op->left) &&
                   isConstantInitializer(node->as.binary_op->right);
        case NODE_IDENTIFIER:
            // Identifiers are generally not constant initializers unless they are enum members or similar.
            // For now, we assume they might be global addresses if they are operands of '&'.
            return false;
        case NODE_PTR_CAST:
        case NODE_INT_CAST:
        case NODE_FLOAT_CAST:
            return isConstantInitializer(node->as.ptr_cast->expr); // All cast nodes have expr at same offset
        case NODE_STRUCT_INITIALIZER: {
            DynamicArray<ASTNamedInitializer*>* fields = node->as.struct_initializer->fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                if (!isConstantInitializer((*fields)[i]->value)) return false;
            }
            return true;
        }
        case NODE_MEMBER_ACCESS: {
            // Enum member access is constant
            if (node->as.member_access->base->resolved_type) {
                Type* t = node->as.member_access->base->resolved_type;
                if (t->kind == TYPE_ENUM) {
                    return true;
                }
            }
            return false;
        }
        default:
            return false;
    }
}

void C89Emitter::write(const char* data, size_t len) {
    if (output_file_ == PLAT_INVALID_FILE) return;

    if (buffer_pos_ + len > sizeof(buffer_)) {
        flush();
        // If the data is larger than the buffer itself, write it directly
        if (len > sizeof(buffer_)) {
            plat_write_file(output_file_, data, len);
            return;
        }
    }

    plat_memcpy(buffer_ + buffer_pos_, data, len);
    buffer_pos_ += len;
}

void C89Emitter::writeString(const char* str) {
    if (!str) return;
    write(str, plat_strlen(str));
}

void C89Emitter::emitComment(const char* text) {
    if (!text) return;
    writeIndent();
    write("/* ", 3);
    writeString(text);
    write(" */\n", 4);
}

void C89Emitter::flush() {
    if (output_file_ != PLAT_INVALID_FILE && buffer_pos_ > 0) {
        plat_write_file(output_file_, buffer_, buffer_pos_);
        buffer_pos_ = 0;
    }
}

bool C89Emitter::open(const char* path) {
    close();
    output_file_ = plat_open_file(path, true);
    owns_file_ = true;
    return isValid();
}

void C89Emitter::close() {
    flush();
    if (owns_file_ && output_file_ != PLAT_INVALID_FILE) {
        plat_close_file(output_file_);
        output_file_ = PLAT_INVALID_FILE;
    }
}

void C89Emitter::emitExpression(const ASTNode* node) {
    if (!node) return;
    switch (node->type) {
        case NODE_INTEGER_LITERAL:
            emitIntegerLiteral(&node->as.integer_literal);
            break;
        case NODE_FLOAT_LITERAL:
            emitFloatLiteral(&node->as.float_literal);
            break;
        case NODE_STRING_LITERAL:
            emitStringLiteral(&node->as.string_literal);
            break;
        case NODE_CHAR_LITERAL:
            emitCharLiteral(&node->as.char_literal);
            break;
        case NODE_BOOL_LITERAL:
            writeString(node->as.bool_literal.value ? "1" : "0");
            break;
        case NODE_NULL_LITERAL:
            writeString("((void*)0)");
            break;
        case NODE_IDENTIFIER:
            if (node->as.identifier.symbol) {
                Symbol* sym = node->as.identifier.symbol;
                if (sym->flags & SYMBOL_FLAG_LOCAL) {
                    writeString(var_alloc_.allocate(sym));
                } else {
                    writeString(getC89GlobalName(sym->name));
                }
            } else {
                writeString(getC89GlobalName(node->as.identifier.name));
            }
            break;
        case NODE_PAREN_EXPR:
            writeString("(");
            emitExpression(node->as.paren_expr.expr);
            writeString(")");
            break;
        case NODE_UNARY_OP:
            writeString(getTokenSpelling(node->as.unary_op.op));
            emitExpression(node->as.unary_op.operand);
            break;
        case NODE_BINARY_OP:
            emitExpression(node->as.binary_op->left);
            writeString(" ");
            writeString(getTokenSpelling(node->as.binary_op->op));
            writeString(" ");
            emitExpression(node->as.binary_op->right);
            break;
        case NODE_MEMBER_ACCESS: {
            const ASTNode* base = node->as.member_access->base;
            if (base->resolved_type) {
                Type* actual_type = base->resolved_type;

                if (actual_type->kind == TYPE_ENUM) {
                    // Enum member access: EnumName_MemberName
                    const char* enum_name = actual_type->as.enum_details.name;
                    if (enum_name) {
                        writeString(getC89GlobalName(enum_name));
                    } else {
                        writeString("/* anonymous enum */");
                    }
                    writeString("_");
                    writeString(node->as.member_access->field_name);
                    break;
                }
            }

            bool need_parens = requiresParentheses(base);
            if (need_parens) writeString("(");
            emitExpression(base);
            if (need_parens) writeString(")");

            // Auto-dereference for pointer to struct:
            // if base is a pointer, use ->, else use .
            if (base->resolved_type && base->resolved_type->kind == TYPE_POINTER) {
                writeString("->");
            } else {
                writeString(".");
            }
            writeString(node->as.member_access->field_name);
            break;
        }
        case NODE_ARRAY_ACCESS: {
            const ASTNode* array_node = node->as.array_access->array;
            Type* array_type = array_node->resolved_type;
            bool is_ptr_to_array = (array_type && array_type->kind == TYPE_POINTER &&
                                    array_type->as.pointer.base->kind == TYPE_ARRAY);

            if (is_ptr_to_array) {
                writeString("(*");
            }

            bool need_parens = requiresParentheses(array_node);
            if (need_parens) writeString("(");
            emitExpression(array_node);
            if (need_parens) writeString(")");

            if (is_ptr_to_array) {
                writeString(")");
            }

            writeString("[");
            emitExpression(node->as.array_access->index);
            writeString("]");
            break;
        }
        case NODE_PTR_CAST:
            writeString("(");
            emitType(node->as.ptr_cast->target_type->resolved_type);
            writeString(")");
            emitExpression(node->as.ptr_cast->expr);
            break;
        case NODE_INT_CAST:
            emitIntCast(node->as.numeric_cast);
            break;
        case NODE_FLOAT_CAST:
            emitFloatCast(node->as.numeric_cast);
            break;
        case NODE_FUNCTION_CALL: {
            const ASTFunctionCallNode* call = node->as.function_call;
            bool need_parens = requiresParentheses(call->callee);
            if (need_parens) writeString("(");
            emitExpression(call->callee);
            if (need_parens) writeString(")");

            writeString("(");
            if (call->args) {
                for (size_t i = 0; i < call->args->length(); ++i) {
                    emitExpression((*call->args)[i]);
                    if (i < call->args->length() - 1) {
                        writeString(", ");
                    }
                }
            }
            writeString(")");
            break;
        }
        case NODE_ASSIGNMENT:
            emitExpression(node->as.assignment->lvalue);
            writeString(" = ");
            emitExpression(node->as.assignment->rvalue);
            break;
        case NODE_COMPOUND_ASSIGNMENT:
            emitExpression(node->as.compound_assignment->lvalue);
            writeString(" ");
            writeString(getTokenSpelling(node->as.compound_assignment->op));
            writeString(" ");
            emitExpression(node->as.compound_assignment->rvalue);
            break;
        case NODE_STRUCT_INITIALIZER: {
            writeString("{");
            Type* struct_type = node->resolved_type;
            if (struct_type && struct_type->kind == TYPE_STRUCT) {
                DynamicArray<StructField>* type_fields = struct_type->as.struct_details.fields;
                DynamicArray<ASTNamedInitializer*>* init_fields = node->as.struct_initializer->fields;

                for (size_t i = 0; i < type_fields->length(); ++i) {
                    const char* field_name = (*type_fields)[i].name;
                    // Find this field in the initializer
                    bool found = false;
                    for (size_t j = 0; j < init_fields->length(); ++j) {
                        if (plat_strcmp((*init_fields)[j]->field_name, field_name) == 0) {
                            emitExpression((*init_fields)[j]->value);
                            found = true;
                            break;
                        }
                    }
                    if (!found) {
                        writeString("0"); // Fallback for missing fields if allowed
                    }
                    if (i < type_fields->length() - 1) {
                        writeString(", ");
                    }
                }
            } else {
                // Fallback if type info is missing
                DynamicArray<ASTNamedInitializer*>* fields = node->as.struct_initializer->fields;
                for (size_t i = 0; i < fields->length(); ++i) {
                    emitExpression((*fields)[i]->value);
                    if (i < fields->length() - 1) {
                        writeString(", ");
                    }
                }
            }
            writeString("}");
            break;
        }
        default:
            writeString("/* [Unimplemented Expression Type ");
            char num[16];
            plat_i64_to_string(node->type, num, sizeof(num));
            writeString(num);
            writeString("] */");
            break;
    }
}

void C89Emitter::emitTypeDefinition(const ASTNode* node) {
    if (!node) return;

    if (node->type == NODE_VAR_DECL) {
        // plat_print_debug("emitTypeDefinition: var_decl\n");
        const ASTVarDeclNode* decl = node->as.var_decl;
        if (!decl || !decl->initializer) return;

        Type* type = decl->initializer->resolved_type;
        if (!type) return;

        // Only emit definition if this is a type declaration (e.g. const T = struct { ... })
        // In our current TypeChecker, these might not have TYPE_TYPE yet, but the initializer
        // will have the actual composite type.
        if (!decl->is_const || (type->kind != TYPE_STRUCT && type->kind != TYPE_UNION && type->kind != TYPE_ENUM)) {
            return;
        }
        if (type->kind == TYPE_STRUCT) {
            writeIndent();
            writeString("struct ");
            writeString(getC89GlobalName(decl->name));
            writeString(" {\n");
            indent();
            DynamicArray<StructField>* fields = type->as.struct_details.fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                writeIndent();
                emitType((*fields)[i].type, (*fields)[i].name);
                writeString(";\n");
            }
            dedent();
            writeIndent();
            writeString("};\n\n");
        } else if (type->kind == TYPE_UNION) {
            writeIndent();
            writeString("union ");
            writeString(getC89GlobalName(decl->name));
            writeString(" {\n");
            indent();
            DynamicArray<StructField>* fields = type->as.struct_details.fields;
            for (size_t i = 0; i < fields->length(); ++i) {
                writeIndent();
                emitType((*fields)[i].type, (*fields)[i].name);
                writeString(";\n");
            }
            dedent();
            writeIndent();
            writeString("};\n\n");
        } else if (type->kind == TYPE_ENUM) {
            // C89 doesn't support specific backing types for enums, they are always int.
            // But we can emit a typedef if needed.
            writeIndent();
            writeString("enum ");
            const char* enum_name = getC89GlobalName(decl->name);
            writeString(enum_name);
            writeString(" {\n");
            indent();
            DynamicArray<EnumMember>* members = type->as.enum_details.members;
            for (size_t i = 0; i < members->length(); ++i) {
                writeIndent();
                writeString(enum_name);
                writeString("_");
                writeString((*members)[i].name);
                writeString(" = ");
                char buf[32];
                plat_i64_to_string((*members)[i].value, buf, sizeof(buf));
                writeString(buf);
                if (i < members->length() - 1) {
                    writeString(",");
                }
                writeString("\n");
            }
            dedent();
            writeIndent();
            writeString("};\n");
            writeIndent();
            writeString("typedef enum ");
            writeString(enum_name);
            writeString(" ");
            writeString(enum_name);
            writeString(";\n\n");
        }
    }
}

void C89Emitter::emitIntCast(const ASTNumericCastNode* node) {
    if (!node || !node->expr || !node->target_type) return;

    Type* src_type = node->expr->resolved_type;
    Type* dest_type = node->target_type->resolved_type;

    if (!src_type || !dest_type) {
        plat_print_debug("Error: Missing type info in @intCast\n");
        abort();
    }

    if (isSafeWidening(src_type, dest_type)) {
        writeString("(");
        emitType(dest_type);
        writeString(")");
        emitExpression(node->expr);
    } else {
        writeString("__bootstrap_");
        writeString(getZigTypeName(dest_type));
        writeString("_from_");
        writeString(getZigTypeName(src_type));
        writeString("(");
        emitExpression(node->expr);
        writeString(")");
    }
}

void C89Emitter::emitFloatCast(const ASTNumericCastNode* node) {
    if (!node || !node->expr || !node->target_type) return;

    Type* src_type = node->expr->resolved_type;
    Type* dest_type = node->target_type->resolved_type;

    if (!src_type || !dest_type) {
        plat_print_debug("Error: Missing type info in @floatCast\n");
        abort();
    }

    if (isSafeWidening(src_type, dest_type)) {
        writeString("(");
        emitType(dest_type);
        writeString(")");
        emitExpression(node->expr);
    } else {
        writeString("__bootstrap_");
        writeString(getZigTypeName(dest_type));
        writeString("_from_");
        writeString(getZigTypeName(src_type));
        writeString("(");
        emitExpression(node->expr);
        writeString(")");
    }
}

void C89Emitter::emitIntegerLiteral(const ASTIntegerLiteralNode* node) {
    if (node->original_name && node->resolved_type && node->resolved_type->kind == TYPE_ENUM) {
        const char* enum_name = node->resolved_type->as.enum_details.name;
        if (enum_name) {
            writeString(getC89GlobalName(enum_name));
        } else {
            writeString("/* anonymous enum */");
        }
        writeString("_");
        writeString(node->original_name);
        return;
    }

    char buf[32];
    plat_u64_to_string(node->value, buf, sizeof(buf));
    writeString(buf);

    if (node->resolved_type) {
        switch (node->resolved_type->kind) {
            case TYPE_U32:
                writeString("U");
                break;
            case TYPE_I64:
                writeString("i64");
                break;
            case TYPE_U64:
                writeString("ui64");
                break;
            default:
                // i32, u8, i8, u16, i16, usize, isize get no suffix
                break;
        }
    }
}

void C89Emitter::emitFloatLiteral(const ASTFloatLiteralNode* node) {
    char buffer[64];
    plat_float_to_string(node->value, buffer, sizeof(buffer));

    // Ensure it's treated as a float by C (add .0 if no '.' or 'e')
    bool has_dot = false;
    bool has_exp = false;
    for (char* p = buffer; *p; ++p) {
        if (*p == '.') has_dot = true;
        if (*p == 'e' || *p == 'E') has_exp = true;
    }

    writeString(buffer);
    if (!has_dot && !has_exp) {
        writeString(".0");
    }

    if (node->resolved_type && node->resolved_type->kind == TYPE_F32) {
        writeString("f");
    }
}

void C89Emitter::emitStringLiteral(const ASTStringLiteralNode* node) {
    if (!node || !node->value) return;

    // TODO: Split long strings if needed for MSVC 6.0
    write("\"", 1);
    const char* p = node->value;
    while (*p) {
        emitEscapedByte((unsigned char)*p, false);
        p++;
    }
    write("\"", 1);
}

void C89Emitter::emitCharLiteral(const ASTCharLiteralNode* node) {
    if (!node) return;
    write("'", 1);
    emitEscapedByte((unsigned char)node->value, true);
    write("'", 1);
}

const char* C89Emitter::getC89GlobalName(const char* zig_name) {
    if (!zig_name) return "z_anonymous";

    // Check cache first
    for (size_t i = 0; i < global_names_.length(); ++i) {
        if (plat_strcmp(global_names_[i].zig_name, zig_name) == 0) {
            return global_names_[i].c89_name;
        }
    }

    char buf[256];
    // Prefix C89 keywords
    if (isCKeyword(zig_name)) {
        plat_strcpy(buf, "z_");
        plat_strcat(buf, zig_name);
    } else {
        plat_strcpy(buf, zig_name);
    }

    // Sanitize
    sanitizeForC89(buf);

    // Truncate to 31 characters for C89/MSVC 6.0
    if (plat_strlen(buf) > 31) {
        buf[31] = '\0';
    }

    // Ensure uniqueness within this translation unit
    char final_buf[256];
    plat_strcpy(final_buf, buf);
    int suffix = 0;
    bool unique = false;

    while (!unique) {
        unique = true;
        for (size_t i = 0; i < global_names_.length(); ++i) {
            if (plat_strcmp(global_names_[i].c89_name, final_buf) == 0) {
                unique = false;
                break;
            }
        }

        if (!unique) {
            suffix++;
            char suffix_str[16];
            plat_i64_to_string(suffix, suffix_str, sizeof(suffix_str));
            size_t suffix_len = plat_strlen(suffix_str);
            size_t base_len = plat_strlen(buf);

            if (base_len + suffix_len > 31) {
                size_t truncate_at = 31 - suffix_len;
                plat_strncpy(final_buf, buf, truncate_at);
                final_buf[truncate_at] = '\0';
                plat_strcat(final_buf, suffix_str);
            } else {
                plat_strcpy(final_buf, buf);
                plat_strcat(final_buf, suffix_str);
            }
        }
    }

    size_t len = plat_strlen(final_buf);
    char* owned_name = (char*)arena_.alloc(len + 1);
    plat_memcpy(owned_name, final_buf, len + 1);

    GlobalNameEntry entry;
    entry.zig_name = zig_name;
    entry.c89_name = owned_name;
    global_names_.append(entry);

    return owned_name;
}

bool C89Emitter::requiresParentheses(const ASTNode* node) const {
    if (!node) return false;
    switch (node->type) {
        // Postfix and primary expressions (Level 1 in C)
        case NODE_IDENTIFIER:
        case NODE_INTEGER_LITERAL:
        case NODE_FLOAT_LITERAL:
        case NODE_STRING_LITERAL:
        case NODE_CHAR_LITERAL:
        case NODE_BOOL_LITERAL:
        case NODE_NULL_LITERAL:
        case NODE_PAREN_EXPR:
        case NODE_FUNCTION_CALL:
        case NODE_ARRAY_ACCESS:
        case NODE_MEMBER_ACCESS:
            return false;

        // Everything else has lower precedence than postfix operators
        default:
            return true;
    }
}

bool C89Emitter::isSafeWidening(Type* src, Type* dest) const {
    if (!src || !dest) return false;

    // Integer widening
    bool src_is_int = (src->kind >= TYPE_I8 && src->kind <= TYPE_U64) || src->kind == TYPE_ISIZE || src->kind == TYPE_USIZE;
    bool dest_is_int = (dest->kind >= TYPE_I8 && dest->kind <= TYPE_U64) || dest->kind == TYPE_ISIZE || dest->kind == TYPE_USIZE;

    if (src_is_int && dest_is_int) {
        // Signedness must match
        bool src_signed = (src->kind == TYPE_I8 || src->kind == TYPE_I16 || src->kind == TYPE_I32 || src->kind == TYPE_I64 || src->kind == TYPE_ISIZE);
        bool dest_signed = (dest->kind == TYPE_I8 || dest->kind == TYPE_I16 || dest->kind == TYPE_I32 || dest->kind == TYPE_I64 || dest->kind == TYPE_ISIZE);

        if (src_signed != dest_signed) return false;

        // Size must be non-decreasing
        return dest->size >= src->size;
    }

    // Float widening
    if (src->kind == TYPE_F32 || src->kind == TYPE_F64) {
        if (dest->kind == TYPE_F32 || dest->kind == TYPE_F64) {
            return dest->size >= src->size;
        }
    }

    return false;
}

const char* C89Emitter::getZigTypeName(Type* type) const {
    if (!type) return "unknown";
    switch (type->kind) {
        case TYPE_VOID: return "void";
        case TYPE_BOOL: return "bool";
        case TYPE_I8:   return "i8";
        case TYPE_U8:   return "u8";
        case TYPE_I16:  return "i16";
        case TYPE_U16:  return "u16";
        case TYPE_I32:  return "i32";
        case TYPE_U32:  return "u32";
        case TYPE_I64:  return "i64";
        case TYPE_U64:  return "u64";
        case TYPE_F32:  return "f32";
        case TYPE_F64:  return "f64";
        case TYPE_ISIZE: return "isize";
        case TYPE_USIZE: return "usize";
        default: return "unknown";
    }
}

void C89Emitter::emitEscapedByte(unsigned char c, bool is_char_literal) {
    switch (c) {
        case '\a': write("\\a", 2); return;
        case '\b': write("\\b", 2); return;
        case '\f': write("\\f", 2); return;
        case '\n': write("\\n", 2); return;
        case '\r': write("\\r", 2); return;
        case '\t': write("\\t", 2); return;
        case '\v': write("\\v", 2); return;
        case '\\': write("\\\\", 2); return;
        case '\'':
            if (is_char_literal) write("\\'", 2);
            else write("'", 1);
            return;
        case '\"':
            if (!is_char_literal) write("\\\"", 2);
            else write("\"", 1);
            return;
        default:
            if (c >= 32 && c <= 126) {
                char ch = (char)c;
                write(&ch, 1);
            } else {
                char buf[8];
                // Use octal escape \ooo (three digits zero-padded)
                buf[0] = '\\';
                buf[1] = (char)((c >> 6) & 7) + '0';
                buf[2] = (char)((c >> 3) & 7) + '0';
                buf[3] = (char)(c & 7) + '0';
                buf[4] = '\0';
                writeString(buf);
            }
    }
}
