#ifndef PARSER_HPP
#define PARSER_HPP

#include "lexer.hpp"
#include "memory.hpp"
#include "ast.hpp"
#include <cstddef> // For size_t
#include <cassert> // For assert()

/**
 * @class Parser
 * @brief Consumes a stream of tokens and produces an Abstract Syntax Tree (AST).
 *
 * The Parser is responsible for syntactic analysis. It takes the flat sequence of
 * tokens generated by the Lexer and verifies that they conform to the language's
 * grammar rules. Upon successful validation, it constructs an AST, which is a
 * hierarchical representation of the source code's structure.
 *
 * The parser uses a recursive descent strategy and allocates all AST nodes from
 * a provided ArenaAllocator to ensure efficient memory management.
 */
class Parser {
public:
    /**
     * @brief Constructs a new Parser instance.
     * @param tokens A pointer to the array of tokens from the lexer.
     * @param count The total number of tokens in the stream.
     * @param arena A pointer to the ArenaAllocator for memory management.
     */
    Parser(Token* tokens, size_t count, ArenaAllocator* arena);

    /**
     * @brief Parses a type expression from the token stream (e.g., `i32`, `*u8`, `[]bool`).
     * @return A pointer to the root ASTNode of the parsed type. The node is allocated
     *         from the parser's ArenaAllocator.
     */
    ASTNode* parseType();

    /**
     * @brief Parses a top-level variable declaration (`var` or `const`).
     *        Grammar: `('var'|'const') IDENT ':' type_expr '=' expr ';'`
     * @return A pointer to the ASTNode representing the variable declaration.
     */
    ASTNode* parseVarDecl();

    /**
     * @brief Parses an expression.
     * @note For the initial implementation, this is a stub that only supports integer literals.
     * @return A pointer to the ASTNode representing the expression.
     */
    ASTNode* parseExpression();

    /**
     * @brief Parses a primary expression.
     *        Grammar: `literal | identifier | '(' expr ')'`
     * @return A pointer to the ASTNode representing the primary expression.
     */
    ASTNode* parsePrimaryExpr();

    /**
     * @brief Parses a postfix expression, which includes function calls and array accesses.
     *        Grammar: `primary_expr ( '(' arg_list ')' | '[' expr ']' )*`
     * @return A pointer to the ASTNode representing the postfix expression.
     */
    ASTNode* parsePostfixExpression();

    /**
     * @brief Parses a unary expression.
     *        Grammar: `( '-' | '!' | '~' | '&' )* postfix_expression`
     * @return A pointer to the ASTNode representing the unary expression.
     */
    ASTNode* parseUnaryExpr();

    /**
     * @brief Parses a top-level function declaration.
     *        Grammar: `fn IDENT '(' ')' '->' type_expr '{' '}'`
     * @return A pointer to the ASTNode representing the function declaration.
     */
    ASTNode* parseFnDecl();

    /**
     * @brief Parses a single statement.
     *
     * This function acts as a dispatcher. It looks at the current token and decides
     * which specific parsing function to call (e.g., `parseIfStatement`, `parseWhileStatement`).
     *
     * @return A pointer to the ASTNode representing the parsed statement.
     */
    ASTNode* parseStatement();

    /**
     * @brief Parses a block statement.
     *        Grammar: `'{' (statement)* '}'`
     * @return A pointer to the ASTNode representing the block statement.
     */
    ASTNode* parseBlockStatement();

    /**
     * @brief Parses an if statement.
     *        Grammar: `'if' '(' expr ')' block_statement ('else' block_statement)?`
     * @return A pointer to the ASTNode representing the if statement.
     */
    ASTNode* parseIfStatement();

    /**
     * @brief Parses a while statement.
     *        Grammar: `'while' '(' expr ')' block_statement`
     * @return A pointer to the ASTNode representing the while statement.
     */
    ASTNode* parseWhileStatement();

    /**
     * @brief Parses a defer statement.
     *        Grammar: `'defer' block_statement`
     * @return A pointer to the ASTNode representing the defer statement.
     */
    ASTNode* parseDeferStatement();

    /**
     * @brief Parses a return statement.
     *        Grammar: `'return' (expr)? ';'`
     * @return A pointer to the ASTNode representing the return statement.
     */
    ASTNode* parseReturnStatement();

    /**
     * @brief Consumes the current token and advances the stream position by one.
     * @return The token that was consumed.
     * @pre The parser is not at the end of the token stream (`!is_at_end()`).
     */
    Token advance();

    /**
     * @brief Returns the current token without consuming it.
     * @return A constant reference to the current token.
     * @pre The parser is not at the end of the token stream (`!is_at_end()`).
     */
    const Token& peek() const;

    /**
     * @brief Checks if the parser has consumed all tokens up to the final EOF token.
     * @return True if the current token is EOF, false otherwise.
     */
    bool is_at_end() const;

private:
    /**
     * @brief If the current token matches the expected type, consumes it and returns true.
     *        Otherwise, it returns false without advancing the stream.
     * @param type The expected token type.
     * @return True if the token matched and was consumed, false otherwise.
     */
    bool match(TokenType type);

    /**
     * @brief If the current token matches the expected type, consumes it and returns it.
     *        Otherwise, it reports a fatal syntax error and aborts the compilation.
     * @param type The expected token type.
     * @param msg The error message to display if the token does not match.
     * @return The consumed token.
     */
    Token expect(TokenType type, const char* msg);

    /**
     * @brief Reports a fatal syntax error and terminates the compilation process.
     *
     * In a Windows environment (`_WIN32`), this function prints the error message to
     * the debug console using `OutputDebugStringA`. On other platforms, it has no
     * output. In all cases, it calls `abort()` to halt execution, as parser errors
     * are considered unrecoverable in this compiler.
     *
     * @param msg The error message to display.
     */
    void error(const char* msg);

    /**
     * @brief Checks if a token represents a primitive type keyword (e.g., "i32", "bool").
     * @param token The token to check.
     * @return True if the token is an identifier corresponding to a primitive type, false otherwise.
     */
    bool isPrimitiveType(const Token& token);

    /** @brief Parses a primitive type (e.g., `i32`, `bool`). Helper for `parseType`. */
    ASTNode* parsePrimitiveType();

    /** @brief Parses a pointer type (e.g., `*u8`, `**i32`). Helper for `parseType`. */
    ASTNode* parsePointerType();

    /** @brief Parses an array or slice type (e.g., `[]bool`, `[8]u8`). Helper for `parseType`. */
    ASTNode* parseArrayType();

    Token* tokens_;
    size_t token_count_;
    size_t current_index_;
    ArenaAllocator* arena_;
};

#endif // PARSER_HPP
