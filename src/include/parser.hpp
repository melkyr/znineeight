#ifndef PARSER_HPP
#define PARSER_HPP

#include "lexer.hpp"
#include "memory.hpp"
#include "ast.hpp"
#include "symbol_table.hpp"
#include <cstddef> // For size_t
#include <cassert> // For assert()

// Define the maximum recursion depth for the parser to prevent stack overflows.
// A value of 255 is a reasonable limit for expressions.
#define MAX_PARSER_RECURSION_DEPTH 255

// Forward-declarations for core data structures
struct ASTNode;
struct Type;
class ErrorSetCatalogue;
class GenericCatalogue;
class TypeInterner;

/**
 * @class Parser
 * @brief Consumes a stream of tokens and produces an Abstract Syntax Tree (AST).
 *
 * The Parser is responsible for syntactic analysis. It takes the flat sequence of
 * tokens generated by the Lexer and verifies that they conform to the language's
 * grammar rules. Upon successful validation, it constructs an AST, which is a
 * hierarchical representation of the source code's structure.
 *
 * The parser uses a recursive descent strategy and allocates all AST nodes from
 * a provided ArenaAllocator to ensure efficient memory management.
 */
class Parser {
public:
    /**
     * @brief Constructs a new Parser instance.
     * @param tokens A pointer to the array of tokens from the lexer.
     * @param count The total number of tokens in the stream.
     * @param arena A pointer to the ArenaAllocator for memory management.
     * @param symbol_table A pointer to the SymbolTable for managing scopes.
     * @param catalogue A pointer to the ErrorSetCatalogue for tracking error sets.
     * @param generic_catalogue A pointer to the GenericCatalogue for tracking generic functions.
     * @param module_name The name of the module being parsed.
     */
    Parser(const Token* tokens, size_t count, ArenaAllocator* arena, SymbolTable* symbol_table, ErrorSetCatalogue* catalogue, GenericCatalogue* generic_catalogue, TypeInterner* type_interner, StringInterner* interner = NULL, const char* module_name = "main");

    /**
     * @brief Parses a type expression from the token stream (e.g., `i32`, `*u8`, `[]bool`).
     * @return A pointer to the root ASTNode of the parsed type. The node is allocated
     *         from the parser's ArenaAllocator.
     */
    ASTNode* parseType();

    /**
     * @brief Parses a variable declaration (`var` or `const`).
     *        Grammar: `('var'|'const') IDENT ':' type_expr '=' expr ';'`
     * @param is_pub True if the declaration is prefixed with 'pub'.
     * @param is_extern True if the declaration is prefixed with 'extern'.
     * @param is_export True if the declaration is prefixed with 'export'.
     * @return A pointer to the ASTNode representing the variable declaration.
     */
    ASTNode* parseVarDecl(bool is_pub = false, bool is_extern = false, bool is_export = false);

    /**
     * @brief Parses an assignment expression.
     *        Grammar: `orelse_catch_expr ( ASSIGN_OP assignment_expr )?`
     * @return A pointer to the ASTNode representing the assignment expression.
     */
    ASTNode* parseAssignmentExpression();

    /**
     * @brief Parses an expression, starting from the lowest precedence.
     * @return A pointer to the ASTNode representing the expression.
     */
    ASTNode* parseExpression();

    /**
     * @brief Parses an orelse or catch expression.
     * @return A pointer to the ASTNode representing the expression.
     */
    ASTNode* parseOrelseCatchExpression();

    /**
     * @brief Parses a primary expression.
     *        Grammar: `literal | identifier | '(' expr ')'`
     * @return A pointer to the ASTNode representing the primary expression.
     */
    ASTNode* parsePrimaryExpr();
    ASTNode* parseNumericCastExpr(NodeType type);
    ASTNode* parseBuiltinCall(const char* name, SourceLocation loc);

    /**
     * @brief Parses a postfix expression, which includes function calls and array accesses.
     *        Grammar: `primary_expr ( '(' arg_list ')' | '[' expr ']' )*`
     * @return A pointer to the ASTNode representing the postfix expression.
     */
    ASTNode* parsePostfixExpression();

    /**
     * @brief Parses a unary expression.
     *        Grammar: `( '-' | '!' | '~' | '&' )* postfix_expression`
     * @return A pointer to the ASTNode representing the unary expression.
     */
    ASTNode* parseUnaryExpr();

    /**
     * @brief Parses a binary expression using a Pratt parser to handle operator precedence.
     *
     * This function implements a Pratt parser, which is an elegant way to handle
     * operator precedence and associativity. It also includes a recursion depth
     * check to prevent stack overflows on deeply nested expressions.
     *
     * @param min_precedence The minimum precedence level to parse.
     * @return A pointer to the ASTNode representing the binary expression.
     */
    ASTNode* parsePrecedenceExpr(int min_precedence);

    /**
     * @brief Parses a function declaration.
     *        Grammar: `fn IDENT '(' ')' '->' type_expr '{' '}'`
     * @param is_pub True if the declaration is prefixed with 'pub'.
     * @param is_extern True if the declaration is prefixed with 'extern'.
     * @param is_export True if the declaration is prefixed with 'export'.
     * @return A pointer to the ASTNode representing the function declaration.
     */
    ASTNode* parseFnDecl(bool is_pub = false, bool is_extern = false, bool is_export = false);

    /**
     * @brief Parses the entire source file as a series of top-level declarations.
     * @return A pointer to the root ASTNode of the parsed program, which will be
     *         a block statement containing all top-level declarations.
     */
    ASTNode* parse();

    /**
     * @brief Parses a single statement.
     *
     * This function acts as a dispatcher. It looks at the current token and decides
     * which specific parsing function to call (e.g., `parseIfStatement`, `parseWhileStatement`).
     *
     * @return A pointer to the ASTNode representing the parsed statement.
     */
    ASTNode* parseStatement();

    /**
     * @brief Parses a block statement.
     *        Grammar: `'{' (statement)* '}'`
     * @return A pointer to the ASTNode representing the block statement.
     */
    ASTNode* parseBlockStatement();

    /**
     * @brief Parses an if statement.
     *        Grammar: `'if' '(' expr ')' block_statement ('else' block_statement)?`
     * @return A pointer to the ASTNode representing the if statement.
     */
    ASTNode* parseIfStatement();

    /** @brief Parses an if expression.
     *        Grammar: `'if' '(' expr ')' expr 'else' expr`
     * @return A pointer to the ASTNode representing the if expression.
     */
    ASTNode* parseIfExpression();

    /**
     * @brief Parses a while statement.
     *        Grammar: `(label ':')? 'while' '(' expr ')' block_statement`
     * @param label The optional loop label.
     * @return A pointer to the ASTNode representing the while statement.
     */
    ASTNode* parseWhileStatement(const char* label = NULL);

    /**
     * @brief Parses a break statement.
     *        Grammar: `'break' (':' label)? ';'`
     * @return A pointer to the ASTNode representing the break statement.
     */
    ASTNode* parseBreakStatement();

    /**
     * @brief Parses a continue statement.
     *        Grammar: `'continue' (':' label)? ';'`
     * @return A pointer to the ASTNode representing the continue statement.
     */
    ASTNode* parseContinueStatement();

    /**
     * @brief Parses a for statement.
     *        Grammar: `(label ':')? 'for' '(' expr ')' '|' IDENT (',' IDENT)? '|' block_statement`
     * @param label The optional loop label.
     * @return A pointer to the ASTNode representing the for statement.
     */
    ASTNode* parseForStatement(const char* label = NULL);

    /**
     * @brief Parses a defer statement.
     *        Grammar: `'defer' block_statement`
     * @return A pointer to the ASTNode representing the defer statement.
     */
    ASTNode* parseDeferStatement();

    /**
     * @brief Parses an errdefer statement.
     *        Grammar: `'errdefer' block_statement`
     * @return A pointer to the ASTNode representing the errdefer statement.
     */
    ASTNode* parseErrDeferStatement();

    /**
     * @brief Parses a return expression.
     *        Grammar: `'return' (expr)?`
     * @return A pointer to the ASTNode representing the return expression.
     */
    ASTNode* parseReturnExpr();

    /**
     * @brief Parses a break expression.
     *        Grammar: `'break' (':' label)?`
     * @return A pointer to the ASTNode representing the break expression.
     */
    ASTNode* parseBreakExpr();

    /**
     * @brief Parses a continue expression.
     *        Grammar: `'continue' (':' label)?`
     * @return A pointer to the ASTNode representing the continue expression.
     */
    ASTNode* parseContinueExpr();

    /**
     * @brief Parses a return statement.
     *        Grammar: `'return' (expr)? ';'`
     * @return A pointer to the ASTNode representing the return statement.
     */
    ASTNode* parseReturnStatement();

    /**
     * @brief Consumes the current token and advances the stream position by one.
     * @return The token that was consumed.
     * @pre The parser is not at the end of the token stream (`!is_at_end()`).
     */
    Token advance();

    /**
     * @brief Returns the current token without consuming it.
     * @return A constant reference to the current token. Can be called when at the
     *         end of the stream, in which case it will return the EOF token.
     */
    const Token& peek() const;

    /**
     * @brief Checks if the parser has consumed all tokens up to the final EOF token.
     * @return True if the current token is EOF, false otherwise.
     */
    bool is_at_end() const;

    /**
     * @brief Returns the token after the current one without consuming it.
     * @return A constant reference to the next token.
     * @pre The parser is not at the end of the token stream.
     */
    const Token& peekNext() const;

private:
    /**
     * @brief Resolves a type AST node into a `Type*` and reports an error if it fails.
     * @param type_node The AST node representing the type expression.
     * @return A pointer to the resolved `Type` object. Aborts on failure.
     */
    Type* resolveAndVerifyType(ASTNode* type_node);

    // A helper struct for iterative right-associative operator parsing.
    struct OperatorInfo {
        Token op;
        const char* catch_payload_name;
    };

    /**
     * @brief If the current token matches the expected type, consumes it and returns true.
     *        Otherwise, it returns false without advancing the stream.
     * @param type The expected token type.
     * @return True if the token matched and was consumed, false otherwise.
     */
    bool match(TokenType type);

    /**
     * @brief If the current token matches the expected type, consumes it and returns it.
     *        Otherwise, it reports a fatal syntax error and aborts the compilation.
     * @param type The expected token type.
     * @param msg The error message to display if the token does not match.
     * @return The consumed token.
     */
    Token expect(TokenType type, const char* msg);

    /**
     * @brief Reports a fatal syntax error and terminates the compilation process.
     *
     * This function prints a diagnostic message using the Platform Abstraction Layer's
     * `plat_print_debug` function and then calls `abort()` to halt execution, as
     * parser errors are considered unrecoverable in this compiler.
     *
     * @param msg The error message to display.
     */
    void error(const char* msg);

    /**
     * @brief Checks if a token represents a primitive type keyword (e.g., "i32", "bool").
     * @param token The token to check.
     * @return True if the token is an identifier corresponding to a primitive type, false otherwise.
     */
    bool isPrimitiveType(const Token& token);

    /** @brief Parses a primitive type (e.g., `i32`, `bool`). Helper for `parseType`. */
    ASTNode* parsePrimitiveType();

    /** @brief Parses a pointer type (e.g., `*u8`, `**i32`). Helper for `parseType`. */
    ASTNode* parsePointerType();

    /** @brief Parses a function type (e.g., `fn(i32) void`). Helper for `parseType`. */
    ASTNode* parseFunctionType();

    /** @brief Parses an array or slice type (e.g., `[]bool`, `[8]u8`). Helper for `parseType`. */
    ASTNode* parseArrayType();

    /** @brief Parses an error union type (e.g., `!i32`). Helper for `parseType`. */
    ASTNode* parseErrorUnionType();

    /** @brief Parses an optional type (e.g., `?i32`). Helper for `parseType`. */
    ASTNode* parseOptionalType();

    /** @brief Parses a struct declaration type expression. Helper for `parsePrimaryExpr`. */
    ASTNode* parseStructDeclaration();

    /** @brief Parses a switch expression. Helper for `parsePrimaryExpr`. */
    ASTNode* parseSwitchExpression();

    /** @brief Parses a union declaration type expression. Helper for `parsePrimaryExpr`. */
    ASTNode* parseUnionDeclaration();

    /** @brief Parses an enum declaration type expression. Helper for `parsePrimaryExpr`. */
    ASTNode* parseEnumDeclaration();

    /** @brief Parses a struct initializer (e.g., `Point { .x = 10 }`). Helper for `parsePostfixExpression`. */
    ASTNode* parseStructInitializer(ASTNode* type_expr);

    /** @brief Parses an anonymous literal (e.g., `.{ .x = 1 }` or `.{ 1, 2 }`). Helper for `parsePrimaryExpr`. */
    ASTNode* parseAnonymousLiteral();

    /** @brief Parses a comptime block. Helper for `parseStatement`. */
    ASTNode* parseComptimeBlock();

    /** @brief Parses an error set definition (e.g., `error { A, B }`). */
    ASTNode* parseErrorSetDefinition();

    /** @brief Parses an @import statement. */
    ASTNode* parseImportStmt();

    /** @brief Parses a @ptrCast expression. */
    ASTNode* parsePtrCastExpr();

    /** @brief Parses an @offsetOf expression. */
    ASTNode* parseOffsetOfExpr();

    /** @brief Parses a top-level item. Helper for `parse`. */
    ASTNode* parseTopLevelItem();

    /**
     * @brief Allocates and initializes a new ASTNode.
     * @param type The NodeType for the new node.
     * @return A pointer to the newly created node.
     */
    ASTNode* createNode(NodeType type);

    /**
     * @brief Allocates and initializes a new ASTNode at a specific location.
     * @param type The NodeType for the new node.
     * @param loc The source location for the new node.
     * @return A pointer to the newly created node.
     */
    ASTNode* createNodeAt(NodeType type, SourceLocation loc);

    // Forward declarations for node types used in the parser
    struct ASTExpressionStmtNode;

    const Token* tokens_;
    size_t token_count_;
    size_t current_index_;
    ArenaAllocator* arena_;
    SymbolTable* symbol_table_;
    ErrorSetCatalogue* catalogue_;
    GenericCatalogue* generic_catalogue_;
    TypeInterner* type_interner_;
    StringInterner* interner_;
    const char* module_name_;
    int recursion_depth_; ///< Tracks the current recursion depth for expression parsing.
    Token eof_token_; ///< A cached EOF token to return from peekNext()

public:
    /**
     * @brief Resets the parser's state to the beginning of the token stream.
     */
    void reset() {
        current_index_ = 0;
        recursion_depth_ = 0;
    }

private:
    // The copy constructor and assignment operator are declared as private to
    // prevent shallow copies of the Parser. Shallow copies would lead to memory
    // corruption, as multiple Parser instances would share the same pointers to
    // the arena and symbol table without a clear ownership model. Making the
    // class non-copyable enforces a safer usage pattern.
    Parser(const Parser& other);
    Parser& operator=(const Parser& other);
};

#endif // PARSER_HPP
