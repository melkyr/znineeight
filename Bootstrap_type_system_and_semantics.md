# Bootstrap Type System & Semantic Analysis

This document provides a detailed specification for the initial type system of the RetroZig bootstrap compiler. Its primary goal is to support a subset of Zig's type system that is directly translatable to C89, adhering to the project's strict technical and historical constraints.

## 1. Core Philosophy

The bootstrap type system is intentionally minimal. It is not designed to handle the full complexity of Zig's advanced type features (e.g., comptime types, error unions, slices). Instead, it focuses on a core set of primitive and pointer types that have direct equivalents in C89. This ensures that the code generated by the bootstrap compiler is simple, predictable, and compatible with legacy C compilers.

Semantic analysis at this stage will be limited to what is necessary to support this C89-compatible subset, including:
-   **Type checking:** Verifying that operations are performed on compatible types.
-   **Symbol resolution:** Looking up variables and functions in the symbol table.
-   **Scope management:** Handling global and function-level scopes.

## 2. Type Representation

The fundamental building block of the type system is the `Type` struct. It is designed to be a lightweight descriptor for any type recognized by the bootstrap compiler.

### `TypeKind` Enum

This enum defines all the primitive and composite types supported in the bootstrap phase. Each `TypeKind` corresponds to a C89-compatible data type.

```cpp
/**
 * @enum TypeKind
 * @brief Defines the kind of each type in the bootstrap type system.
 */
enum TypeKind {
    TYPE_VOID,
    TYPE_BOOL,
    // Integer Types
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    // Platform-dependent Integer Types
    TYPE_ISIZE, // Maps to i32 on a 32-bit target
    TYPE_USIZE, // Maps to u32 on a 32-bit target
    // Floating-Point Types
    TYPE_F32,
    TYPE_F64,
    // Complex Types
    TYPE_POINTER
};
```

### `Type` Struct

The `Type` struct contains the `TypeKind` discriminator, information about the type's size and alignment, and a `union` to hold data for composite types (like pointers).

```cpp
// Forward-declare Type for the pointer union member
struct Type;

/**
 * @struct Type
 * @brief Represents a type within the bootstrap compiler's type system.
 */
struct Type {
    TypeKind kind;
    size_t size;
    size_t alignment;

    union {
        /**
         * @struct PointerDetails
         * @brief Details specific to pointer types.
         */
        struct PointerDetails {
            Type* base; // The type that the pointer points to.
        } pointer;
    } as;
};
```

**Memory Management:** Like AST nodes, all `Type` structs are allocated from the `ArenaAllocator` to ensure fast allocation and simple, collective deallocation.

## 3. Type Compatibility and Coercion

The bootstrap type checker enforces a set of strict rules for type compatibility to prevent errors and ensure that the generated C89 code is valid.

### Implicit Coercion (Widening)

Implicit type coercion is only allowed for "safe" conversions where no data loss can occur. This is primarily limited to widening integer types.

-   A signed integer can be implicitly converted to a signed integer of a larger size (e.g., `i8` -> `i16`, `i16` -> `i32`).
-   An unsigned integer can be implicitly converted to an unsigned integer of a larger size (e.g., `u8` -> `u16`, `u16` -> `u32`).
-   A floating-point number can be implicitly widened (`f32` -> `f64`).

### Explicit Coercion (Casting)

All other conversions must be explicit. This includes:
-   Conversions between integer types that may result in data loss (e.g., `i32` -> `i16`).
-   Conversions between signed and unsigned integers.
-   Conversions between integer and floating-point types.
-   Conversions between pointer types (e.g., `*i32` to `*u8`).

### Type Compatibility Matrix

The following table summarizes the allowed implicit and explicit conversions:

| From Type | To Type       | Implicit | Explicit | Notes                               |
|-----------|---------------|----------|----------|-------------------------------------|
| `i8`      | `i16`, `i32`, `i64` | ✓        | -        | Safe widening conversion.           |
| `u8`      | `u16`, `u32`, `u64` | ✓        | -        | Safe widening conversion.           |
| `i32`     | `f32`, `f64`    | -        | ✓        | Requires an explicit cast.          |
| `f32`     | `f64`         | ✓        | -        | Safe widening conversion.           |
| `*T`      | `*U`          | -        | ✓        | Requires an explicit cast.          |

## 4. Semantic Analysis

The semantic analyzer will traverse the AST generated by the parser and use the type system to perform the following checks.

### Symbol Table

-   A `SymbolTable` will be used to store information about declared variables, functions, and types.
-   It will support nested scopes (global and function-level).
-   When looking up a symbol, it will search from the innermost scope outwards.

### Variable Declarations

-   The analyzer will check that the type of the initializer expression is compatible with the declared type of the variable.
-   It will ensure that a variable is not redefined within the same scope.

### Function Calls

-   The analyzer will verify that the number of arguments in a function call matches the number of parameters in the function's declaration.
-   It will check that the type of each argument is compatible with the type of the corresponding parameter.

### Operators

-   **Arithmetic Operators:** The analyzer will ensure that arithmetic operators (`+`, `-`, `*`, `/`) are only used with numeric types (integers and floats).
-   **Logical Operators:** Logical operators (`&&`, `||`, `!`) must be used with boolean types.
-   **Pointer Arithmetic:** Pointer arithmetic will be restricted to ensure it is C89-compatible.
