# Bootstrap Type System & Semantic Analysis

This document provides a detailed specification for the initial type system of the RetroZig bootstrap compiler. Its primary goal is to support a subset of Zig's type system that is directly translatable to C89, adhering to the project's strict technical and historical constraints.

## 1. Core Philosophy

The bootstrap type system is intentionally minimal. It is not designed to handle the full complexity of Zig's advanced type features (e.g., comptime types, error unions, slices). Instead, it focuses on a core set of primitive and pointer types that have direct equivalents in C89. This ensures that the code generated by the bootstrap compiler is simple, predictable, and compatible with legacy C compilers.

Semantic analysis at this stage will be limited to what is necessary to support this C89-compatible subset, including:
-   **Type checking:** Verifying that operations are performed on compatible types.
-   **Symbol resolution:** Looking up variables and functions in the symbol table.
-   **Scope management:** Handling global and function-level scopes.

## 2. Type Representation

The fundamental building block of the type system is the `Type` struct. It is designed to be a lightweight descriptor for any type recognized by the bootstrap compiler.

### `TypeKind` Enum

This enum defines all the primitive and composite types supported in the bootstrap phase. Each `TypeKind` corresponds to a C89-compatible data type.

```cpp
/**
 * @enum TypeKind
 * @brief Defines the kind of each type in the bootstrap type system.
 */
enum TypeKind {
    TYPE_VOID,
    TYPE_BOOL,
    // Integer Types
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    // Platform-dependent Integer Types
    TYPE_ISIZE, // Maps to i32 on a 32-bit target
    TYPE_USIZE, // Maps to u32 on a 32-bit target
    // Floating-Point Types
    TYPE_F32,
    TYPE_F64,
    // Complex Types
    TYPE_POINTER,
    TYPE_FUNCTION
};
```

### `Type` Struct

The `Type` struct contains the `TypeKind` discriminator, information about the type's size and alignment, and a `union` to hold data for composite types (like pointers).

```cpp
// Forward-declare Type for the pointer union member
struct Type;

/**
 * @struct Type
 * @brief Represents a type within the bootstrap compiler's type system.
 */
struct Type {
    TypeKind kind;
    size_t size;
    size_t alignment;

    union {
        /**
         * @struct PointerDetails
         * @brief Details specific to pointer types.
         */
        struct PointerDetails {
            Type* base; // The type that the pointer points to.
            bool is_const;
        } pointer;

        /**
         * @struct FunctionDetails
         * @brief Details specific to function types.
         */
        struct FunctionDetails {
            DynamicArray<Type*>* params;
            Type* return_type;
        } function;
    } as;
};
```

**Memory Management:** Like AST nodes, all `Type` structs are allocated from the `ArenaAllocator` to ensure fast allocation and simple, collective deallocation.

## 3. Type Compatibility and Coercion

The bootstrap type checker enforces a set of strict rules for type compatibility to prevent errors and ensure that the generated C89 code is valid.

### `areTypesCompatible` Function

The core of type compatibility is the `areTypesCompatible(Type* expected, Type* actual)` method in the `TypeChecker`. It returns `true` if a value of the `actual` type can be used where a value of the `expected` type is required.

### Implicit Coercion (Widening)

The compatibility function allows for "safe" implicit conversions where no data loss can occur. This is primarily limited to widening numeric types.

-   **Integer Widening:** A signed integer can be implicitly converted to a signed integer of a larger or equal size (e.g., `i8` -> `i16`, `i16` -> `i32`). The same applies to unsigned integers.
-   **Float Widening:** A single-precision float (`f32`) can be implicitly converted to a double-precision float (`f64`).

### Explicit Coercion (Casting)

All other conversions must be explicit and are not currently supported by the `areTypesCompatible` function. This includes:
-   Conversions that may result in data loss (e.g., `i32` -> `i16`).
-   Conversions between signed and unsigned integers.
-   Conversions between integer and floating-point types.
-   Conversions between pointer types (e.g., `*i32` to `*u8`).

### Type Compatibility Matrix

The following table summarizes the allowed implicit conversions:

| From Type (`actual`) | To Type (`expected`) | Implicitly Compatible? | Notes                                            |
|----------------------|----------------------|------------------------|--------------------------------------------------|
| `i(N)`               | `i(M)` where M >= N  | ✓                      | Safe integer widening conversion.                |
| `u(N)`               | `u(M)` where M >= N  | ✓                      | Safe unsigned integer widening conversion.       |
| `f32`                | `f64`                | ✓                      | Safe float widening conversion.                  |
| `*T`                 | `*const T`           | ✓                      | Adding const is a safe conversion.               |
| `T`                  | `T`                  | ✓                      | Types are identical.                             |
| `*const T`           | `*T`                 | ✗                      | Removing const is not allowed implicitly.        |
| `*T`                 | `*U`                 | ✗                      | Pointers to different types are incompatible.    |
| Any other combination| -                    | ✗                      | All other conversions require an explicit cast.  |


## 4. Semantic Analysis

The semantic analyzer will traverse the AST generated by the parser and use the type system to perform the following checks.

### Symbol Table

A `SymbolTable` is a critical component for semantic analysis, responsible for tracking all named entities (variables, functions, types) within a given scope. The bootstrap compiler's symbol table is designed for simplicity and efficiency, using an arena-allocated `DynamicArray` as its backing store.

#### `Symbol` Struct

Each entry in the symbol table is a `Symbol` struct, which contains all the necessary information about a named entity.

```cpp
/**
 * @struct Symbol
 * @brief Represents a named entity (variable, function, or type) in the symbol table.
 */
struct Symbol {
    /**
     * @enum Kind
     * @brief Discriminator for the type of symbol.
     */
    enum Kind { VARIABLE, FUNCTION, TYPE } kind;
    const char* name;       // Interned string for the symbol's name.
    Type* type;             // Pointer to the Type struct for this symbol.
    u32 address_offset;     // Stack or data offset for code generation.
    ASTNode* definition;    // Pointer to the AST node where this symbol was defined.
};
```

#### `SymbolTable` Class

The `SymbolTable` class manages a collection of symbols. For the initial bootstrap phase, it will only manage a single, global scope. Support for nested scopes will be added in a future task.

```cpp
/**
 * @class SymbolTable
 * @brief Manages a collection of symbols for a given scope.
 */
class SymbolTable {
    DynamicArray<Symbol>* symbols;
    ArenaAllocator* arena;
public:
    SymbolTable(ArenaAllocator* allocator);
    Symbol* lookup(const char* name);
    void insert(Symbol& sym);
};
```

-   **`lookup(const char* name)`:** Searches the table for a symbol with a matching (interned) name. Returns a pointer to the `Symbol` if found, or `NULL` otherwise.
-   **`insert(Symbol& sym)`:** Adds a new `Symbol` to the table. It does not check for duplicates; this responsibility is left to the semantic analyzer.

### Variable Declarations

When visiting a variable declaration (`ASTVarDeclNode`), the `TypeChecker` performs the following validation:
-   It determines the declared type of the variable by visiting the type expression node.
-   It determines the type of the initializer by visiting the initializer expression node.
-   It then calls `areTypesCompatible()` to verify that the initializer's type can be safely assigned to the variable's declared type. This check allows for safe, implicit widening conversions (e.g., assigning an `i32` literal to an `i64` variable).
-   If the types are not compatible, it reports a detailed `ERR_TYPE_MISMATCH` error, specifying both the variable's type and the initializer's type (e.g., "cannot assign type '*const u8' to variable of type 'i32'").
-   The check for redefinition is handled by the `Parser` when it inserts the variable's symbol into the `SymbolTable`, ensuring that duplicate symbols are caught early.

### Function Declarations and Signatures

When visiting a function declaration (`ASTFnDeclNode`), the `TypeChecker` performs a comprehensive validation of the entire function signature:

1.  **Parameter Type Resolution:** It iterates through each parameter in the function's declaration. For each parameter, it visits the corresponding type node (e.g., `ASTTypeNameNode`, `ASTPointerTypeNode`).
    -   If a parameter's type name cannot be resolved to a known type (e.g., `fn my_func(a: NotARealType)`), it reports an `ERR_UNDECLARED_TYPE` error.
    -   This validation prevents further errors that would arise from using an invalid type within the function body.

2.  **Return Type Resolution:** It resolves the function's return type by visiting its type node. If the return type is invalid, it also reports an `ERR_UNDECLARED_TYPE` error.

3.  **Function Type Creation:** If all parameter and return types are valid, it constructs a new `Type` object with the kind `TYPE_FUNCTION`. This `Type` object stores a `DynamicArray` of the parameter types and a pointer to the return type.

4.  **Symbol Update:** The `TypeChecker` then updates the function's `Symbol` in the `SymbolTable` to point to this newly created function type. This makes the full signature available for future use, such as in type-checking function calls.

5.  **Return Statement Validation:** After processing the signature, it proceeds to visit the function's body. When it encounters a `return` statement, it compares the type of the returned expression against the `current_fn_return_type` it recorded while visiting the signature, ensuring that the return value is compatible with the function's declared return type.

### Literals

#### Integer Literals
The type of an integer literal is determined by its value to be C89-compliant.
- If the value fits within a 32-bit signed integer (`-2147483648` to `2147483647`), its type is `i32`.
- Otherwise, its type is `i64`.

#### String Literals
A string literal is given the type "pointer to `u8`", which is represented as `*u8`. This is a simplification for the bootstrap phase; a more advanced compiler would use a slice type like `[]const u8`.

### Function Calls

-   The analyzer will verify that the number of arguments in a function call matches the number of parameters in the function's declaration.
-   It will check that the type of each argument is compatible with the type of the corresponding parameter.

#### C89 Compatibility Restrictions

To ensure that the output of the bootstrap compiler is compatible with C89, several restrictions are enforced during semantic analysis. These limitations are designed to prevent the use of modern language features that do not have a direct and simple equivalent in C89.

Function calls are subject to the following strict limitations:

1.  **Maximum Number of Arguments:** A function call cannot have more than four arguments. This is a conservative limit to ensure compatibility with various C89-era calling conventions and stack limitations. Any call with five or more arguments will trigger a fatal compilation error.

2.  **No Function Pointers:** The bootstrap compiler does not support calling functions via pointers. Any attempt to call a variable that holds a function (i.e., a function pointer) will be rejected with a fatal error.

    *Note on testing:* The current parser does not support type inference for variable declarations (e.g., `var func_ptr = my_func;`). As a result, tests for this specific feature currently fail during the parsing phase, preventing the `TypeChecker` from running. The check remains in the `TypeChecker` for correctness and future-proofing.

3.  **No Variadic Functions:** The parser does not support the syntax for declaring or calling variadic functions (e.g., `printf`-style functions with `...`).

### Operators

-   **Arithmetic Operators:** The analyzer will ensure that arithmetic operators (`+`, `-`, `*`, `/`) are only used with numeric types (integers and floats).
-   **Logical Operators:** Logical operators (`&&`, `||`, `!`) must be used with boolean types.
-   **Pointer Arithmetic:** Pointer arithmetic will be restricted to ensure it is C89-compatible.

### Function Calls

When visiting a function call (`ASTFunctionCallNode`), the `TypeChecker` performs a series of critical validations to ensure the call is well-formed and adheres to the bootstrap compiler's constraints.

1.  **Callee Type Verification:** The checker first resolves the type of the expression being called. It ensures that the callee is a symbol of kind `FUNCTION` and has a `TYPE_FUNCTION` type. This check is crucial as it prevents attempts to call variables or other non-function entities, which is how calls to function pointers are rejected.

2.  **Argument Count Check:** It verifies that the number of arguments provided in the call exactly matches the number of parameters specified in the function's signature. If the counts mismatch, it reports a fatal error with a message like "wrong number of arguments to function call, expected 2, got 1".

3.  **Argument Type Compatibility:** It iterates through each argument and compares its type to the corresponding parameter's type using the `areTypesCompatible` function. This allows for safe, implicit widening conversions (e.g., passing an `i16` to an `i32` parameter) but rejects incompatible types. A mismatch results in a fatal error detailing the expected and actual types.

4.  **C89 Argument Limit:** To maintain compatibility with legacy C89 compilers and calling conventions, the type checker enforces a hard limit of a maximum of 4 arguments per function call. Any call with five or more arguments will result in a fatal error.

### Expression Type Checking

When visiting expressions, the `TypeChecker` determines the resulting type of the expression.

-   **Literals:**
    -   `true`, `false`: `bool`
    -   Integer literals: `i32` if they fit, otherwise `i64`.
    -   Character literals: `u8`
    -   String literals: `*const u8`

-   **Identifiers:** The type of an identifier is determined by looking up its symbol in the `SymbolTable`. If the symbol is not found, an `ERR_UNDEFINED_VARIABLE` error is reported.

-   **Binary Operations:**
    -   **Arithmetic (`+`, `-`, `*`, `/`, `%`):** Both operands must be of the same numeric type. The resulting type is the same as the operand types. Operations between different numeric types (e.g., `i32` and `f64`) are not allowed.
    -   **Comparisons (`==`, `!=`, `<`, `>`, `<=`, `>=`):** Both operands must be of the same numeric type. The resulting type is always `bool`.

### Control Flow Statements

-   **`if` and `while` Statements:** The condition of an `if` or `while` statement is expected to be a type that can be evaluated in a boolean context. To align with C89-style behavior, the `TypeChecker` accepts conditions of the following types:
    -   `bool`
    -   Any integer type (`i8` through `u64`, `isize`, `usize`)
    -   Any pointer type (`*T`)
    If the condition is of any other type (e.g., `void`, `f32`, a struct), a non-fatal `ERR_TYPE_MISMATCH` error is reported.

## 5. Symbol Table and Memory Usage

The `SymbolTable` is a core component of the semantic analysis phase. It is owned by the `CompilationUnit` and provides hierarchical scope management for all identifiers.

## 9. Type Checker

The `TypeChecker` is a new component responsible for traversing the AST and verifying that the program adheres to the language's type rules. It is the primary consumer of the `Type` and `Symbol` information described in the previous sections.

### Traversal Strategy

The `TypeChecker` uses the visitor pattern to traverse the AST. It has a `visit` method for each `NodeType`, which allows for modular and extensible type-checking logic. The traversal is a recursive process that walks the tree, checking each node and its children.

### Integration in the Pipeline

The `TypeChecker` is integrated into the main compilation pipeline as a distinct stage that runs immediately after the parser. The process is as follows:
1. The `Parser` generates the full `AST`.
2. The `TypeChecker` is initialized with the `CompilationUnit`.
3. The `check` method of the `TypeChecker` is called with the root of the `AST`.
4. The `TypeChecker` traverses the tree, and if it finds any type errors, it reports them using the `ErrorHandler` in the `CompilationUnit`.

### Error Handling

The `TypeChecker` uses the existing `ErrorHandler` to report type-related errors. This ensures that type errors are reported in the same format as parsing errors, providing a consistent user experience.

### Memory Impact of the Refactored Symbol Table

The foundational refactoring of the `SymbolTable` introduced a more robust, scope-aware architecture. A key consequence of this change is an increase in the baseline memory usage for each `CompilationUnit`.

**Cause of Increased Memory Usage:**
The `SymbolTable` constructor now immediately performs allocations to set up its foundational data structures:
1.  It allocates a `DynamicArray` to hold the stack of `Scope` pointers.
2.  Upon construction, it immediately calls `enterScope()` to create the global scope. This involves allocating a `Scope` object and the `DynamicArray` for symbols within that scope.

This upfront memory cost was not present in the previous, simpler implementation.

**Impact on Performance and Unit Tests:**
This increased baseline memory usage, combined with the new symbol allocations during parsing, caused several unit tests with small, hardcoded `ArenaAllocator` sizes (e.g., 1024 or 2048 bytes) to fail with "Out of memory" errors. These tests were not provisioned for the additional memory overhead of a fully active symbol table.

The solution was to perform a comprehensive update of the test suite, increasing the arena sizes in all parser-related tests from 4096 to 8192 bytes. This proactive measure ensures that the test environment is stable and has sufficient capacity for the new functionality, preventing spurious memory-related failures.

**Performance Concerns:**
The increase in baseline memory usage is not considered a significant performance concern for the following reasons:
- **Necessary Trade-off:** The memory is used to provide essential scoping functionality, which is a core requirement for the compiler.
- **Fixed Cost:** The initial allocation is a small, fixed cost per compilation unit. It does not grow with the size of the source file being compiled.
- **Efficient Allocation:** All allocations are still managed by the `ArenaAllocator`, which is extremely fast. The performance impact of the initial allocations is negligible in the context of a full compilation.

In summary, while the new `SymbolTable` has a slightly larger memory footprint, it is a deliberate and necessary architectural improvement. The impact is well-contained and does not compromise the overall performance goals of the compiler.

## 6. Type Resolution

To bridge the gap between the parser, which sees types as identifiers (e.g., `"i32"`), and the semantic analysis phase, which requires structured `Type` objects, a simple type resolution system has been implemented.

### `resolvePrimitiveTypeName`

A new function, `resolvePrimitiveTypeName(const char* name)`, has been introduced. Its responsibilities are:
-   It takes a string (an interned identifier name) as input.
-   It compares this string against a list of known primitive type names (e.g., "void", "bool", "i8", etc.).
-   If a match is found, it returns a pointer to a pre-defined, static, global `Type` object for that primitive.
-   If the name does not correspond to a known primitive type, it returns `NULL`.

This mechanism allows the parser to easily obtain a valid `Type*` for a symbol by looking up the type name found in the source code.

### `createPointerType`
A helper function, `createPointerType(ArenaAllocator& arena, Type* base_type, bool is_const)`, has been added to facilitate the creation of pointer types. It allocates a new `Type` object from the arena, sets its kind to `TYPE_POINTER`, and links it to the provided base type, respecting the `const` qualifier.

### `createFunctionType`
A new helper function, `createFunctionType(ArenaAllocator& arena, DynamicArray<Type*>* params, Type* return_type)`, has been added to create `TYPE_FUNCTION` objects. It allocates a new `Type` and populates it with the list of parameter types and the return type.

## 7. Parser Integration

To make the symbol table functional, it is integrated directly into the parsing process. This allows the parser to manage scopes and register symbols as it traverses the source code.

### Connection and Scope Management

-   **Constructor Injection:** The `CompilationUnit`, which owns the `SymbolTable`, passes a pointer to it into the `Parser`'s constructor.
-   **Scope Handling:** The parser is responsible for signaling the `SymbolTable` to create and destroy scopes.
    -   `parseFnDecl()` calls `enterScope()` before parsing the function body and `exitScope()` after, creating a dedicated scope for the function's contents.
    -   `parseBlockStatement()` does the same upon encountering `{` and `}` respectively, allowing for correct nested block scoping.

### Expression Statements
The parser now supports "expression statements", which are statements that consist of a single expression followed by a semicolon (e.g., `my_function();` or `"a string";`). This is handled by a new `NODE_EXPRESSION_STMT` in the AST.

### Symbol Registration During Parsing

-   **`parseVarDecl()`:** When a variable declaration is parsed, this method:
    1.  Extracts the type name identifier from the `ASTNode` for the type.
    2.  Calls `resolvePrimitiveTypeName` to get a `Type*` for the variable. If this fails, it's a fatal error.
    3.  Constructs a `Symbol` for the variable using the `SymbolBuilder`.
    4.  Calls `symbol_table_->insert()` to register the symbol in the current scope.

-   **`parseFnDecl()`:** When a function is parsed, this method:
    1.  Constructs a `Symbol` for the function itself.
    2.  Inserts this `Symbol` into the *current* scope (e.g., the global scope for a top-level function). This happens *before* a new scope is entered for the function's body.

### Error Handling

-   **Duplicate Symbols:** If `symbol_table_->insert()` returns `false`, it indicates that a symbol with the same name already exists in the current scope. The parser treats this as a fatal semantic error and immediately calls its `error()` method to abort compilation. This provides simple and effective duplicate detection for both variables and functions.

## 8. Memory Profile Analysis (Milestone 4)

A memory profiling analysis was conducted to investigate the test suite's memory consumption and verify the soundness of the arena allocation strategy, particularly after the integration of the Symbol Table and other memory-intensive parser features.

### Methodology

The analysis employed a two-pronged approach:

1.  **Internal Instrumentation:** A temporary test case was added to run a representative piece of source code through the compilation pipeline. Using the `ArenaAllocator`'s existing `getOffset()` method, the test measured and reported the amount of memory consumed by each major stage (Lexer vs. Parser/Symbol Table). This temporary test code was removed after the analysis was complete.
2.  **External Profiling:** The entire test suite was compiled with debug symbols and run under the Valgrind/Massif heap profiling tool. This provided an external, objective view of the `test_runner` executable's complete memory lifecycle, allowing for the detection of any potential leaks or unexpected allocation patterns.

### Findings

The results from both methods were consistent and conclusive:

-   **No Memory Leaks Detected:** The Massif report showed a healthy, cyclical memory usage pattern. The heap size peaked during test execution and returned to a stable baseline after each test, confirming that the `ArenaAllocator`'s memory is being correctly allocated and subsequently released. There was no evidence of unbounded memory growth across the test suite.
-   **Memory Growth is Feature-Driven:** The internal instrumentation revealed the following breakdown for the sample code:
    -   **Lexer (Tokens & Interned Strings):** ~1.7 KB
    -   **Parser (AST Nodes & Symbols):** ~1.7 KB
    -   **Total Arena Usage:** ~3.5 KB
    This demonstrates that the addition of complex components like the AST and Symbol Table are responsible for the increased memory usage. The need to increase arena sizes in tests is a direct and expected consequence of this added complexity, not a bug.
-   **Low Overall Footprint:** The external profile showed a peak heap usage of approximately 86 KB. The majority of this (~74 KB) was attributable to C++ standard library runtime overhead (e.g., for I/O buffers). The memory directly allocated by the compiler's `ArenaAllocator` was consistently in the 4 KB range, aligning with the sizes specified in the tests.

### Conclusion

The memory allocation strategy is sound. The compiler components have a minimal and controlled memory footprint, and the an arena-based approach is effectively preventing memory leaks. The observed increases in memory usage are a natural result of the project's evolution and do not indicate an underlying issue.
