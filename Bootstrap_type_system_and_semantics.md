# Bootstrap Type System & Semantic Analysis

This document provides a detailed specification for the initial type system of the RetroZig bootstrap compiler. Its primary goal is to support a subset of Zig's type system that is directly translatable to C89, adhering to the project's strict technical and historical constraints.

## 1. Core Philosophy

The bootstrap type system is intentionally minimal. It is not designed to handle the full complexity of Zig's advanced type features (e.g., comptime types, error unions, slices). Instead, it focuses on a core set of primitive and pointer types that have direct equivalents in C89. This ensures that the code generated by the bootstrap compiler is simple, predictable, and compatible with legacy C compilers.

Semantic analysis at this stage will be limited to what is necessary to support this C89-compatible subset, including:
-   **Type checking:** Verifying that operations are performed on compatible types.
-   **Symbol resolution:** Looking up variables and functions in the symbol table.
-   **Scope management:** Handling global and function-level scopes.

## 2. Type Representation

The fundamental building block of the type system is the `Type` struct. It is designed to be a lightweight descriptor for any type recognized by the bootstrap compiler.

### `TypeKind` Enum

This enum defines all the primitive and composite types supported in the bootstrap phase. Each `TypeKind` corresponds to a C89-compatible data type.

```cpp
/**
 * @enum TypeKind
 * @brief Defines the kind of each type in the bootstrap type system.
 */
enum TypeKind {
    TYPE_VOID,
    TYPE_BOOL,
    // Integer Types
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    // Platform-dependent Integer Types
    TYPE_ISIZE, // Maps to i32 on a 32-bit target
    TYPE_USIZE, // Maps to u32 on a 32-bit target
    // Floating-Point Types
    TYPE_F32,
    TYPE_F64,
    // Complex Types
    TYPE_POINTER
};
```

### `Type` Struct

The `Type` struct contains the `TypeKind` discriminator, information about the type's size and alignment, and a `union` to hold data for composite types (like pointers).

```cpp
// Forward-declare Type for the pointer union member
struct Type;

/**
 * @struct Type
 * @brief Represents a type within the bootstrap compiler's type system.
 */
struct Type {
    TypeKind kind;
    size_t size;
    size_t alignment;

    union {
        /**
         * @struct PointerDetails
         * @brief Details specific to pointer types.
         */
        struct PointerDetails {
            Type* base; // The type that the pointer points to.
        } pointer;
    } as;
};
```

**Memory Management:** Like AST nodes, all `Type` structs are allocated from the `ArenaAllocator` to ensure fast allocation and simple, collective deallocation.

## 3. Type Compatibility and Coercion

The bootstrap type checker enforces a set of strict rules for type compatibility to prevent errors and ensure that the generated C89 code is valid.

### Implicit Coercion (Widening)

Implicit type coercion is only allowed for "safe" conversions where no data loss can occur. This is primarily limited to widening integer types.

-   A signed integer can be implicitly converted to a signed integer of a larger size (e.g., `i8` -> `i16`, `i16` -> `i32`).
-   An unsigned integer can be implicitly converted to an unsigned integer of a larger size (e.g., `u8` -> `u16`, `u16` -> `u32`).
-   A floating-point number can be implicitly widened (`f32` -> `f64`).

### Explicit Coercion (Casting)

All other conversions must be explicit. This includes:
-   Conversions between integer types that may result in data loss (e.g., `i32` -> `i16`).
-   Conversions between signed and unsigned integers.
-   Conversions between integer and floating-point types.
-   Conversions between pointer types (e.g., `*i32` to `*u8`).

### Type Compatibility Matrix

The following table summarizes the allowed implicit and explicit conversions:

| From Type | To Type       | Implicit | Explicit | Notes                               |
|-----------|---------------|----------|----------|-------------------------------------|
| `i8`      | `i16`, `i32`, `i64` | ✓        | -        | Safe widening conversion.           |
| `u8`      | `u16`, `u32`, `u64` | ✓        | -        | Safe widening conversion.           |
| `i32`     | `f32`, `f64`    | -        | ✓        | Requires an explicit cast.          |
| `f32`     | `f64`         | ✓        | -        | Safe widening conversion.           |
| `*T`      | `*U`          | -        | ✓        | Requires an explicit cast.          |

## 4. Semantic Analysis

The semantic analyzer will traverse the AST generated by the parser and use the type system to perform the following checks.

### Symbol Table

A `SymbolTable` is a critical component for semantic analysis, responsible for tracking all named entities (variables, functions, types) within a given scope. The bootstrap compiler's symbol table is designed for simplicity and efficiency, using an arena-allocated `DynamicArray` as its backing store.

#### `Symbol` Struct

Each entry in the symbol table is a `Symbol` struct, which contains all the necessary information about a named entity.

```cpp
/**
 * @struct Symbol
 * @brief Represents a named entity (variable, function, or type) in the symbol table.
 */
struct Symbol {
    /**
     * @enum Kind
     * @brief Discriminator for the type of symbol.
     */
    enum Kind { VARIABLE, FUNCTION, TYPE } kind;
    const char* name;       // Interned string for the symbol's name.
    Type* type;             // Pointer to the Type struct for this symbol.
    u32 address_offset;     // Stack or data offset for code generation.
    ASTNode* definition;    // Pointer to the AST node where this symbol was defined.
};
```

#### `SymbolTable` Class

The `SymbolTable` class manages a collection of symbols. For the initial bootstrap phase, it will only manage a single, global scope. Support for nested scopes will be added in a future task.

```cpp
/**
 * @class SymbolTable
 * @brief Manages a collection of symbols for a given scope.
 */
class SymbolTable {
    DynamicArray<Symbol>* symbols;
    ArenaAllocator* arena;
public:
    SymbolTable(ArenaAllocator* allocator);
    Symbol* lookup(const char* name);
    void insert(Symbol& sym);
};
```

-   **`lookup(const char* name)`:** Searches the table for a symbol with a matching (interned) name. Returns a pointer to the `Symbol` if found, or `NULL` otherwise.
-   **`insert(Symbol& sym)`:** Adds a new `Symbol` to the table. It does not check for duplicates; this responsibility is left to the semantic analyzer.

### Variable Declarations

-   The analyzer will check that the type of the initializer expression is compatible with the declared type of the variable.
-   It will ensure that a variable is not redefined within the same scope.

### Function Calls

-   The analyzer will verify that the number of arguments in a function call matches the number of parameters in the function's declaration.
-   It will check that the type of each argument is compatible with the type of the corresponding parameter.

### Operators

-   **Arithmetic Operators:** The analyzer will ensure that arithmetic operators (`+`, `-`, `*`, `/`) are only used with numeric types (integers and floats).
-   **Logical Operators:** Logical operators (`&&`, `||`, `!`) must be used with boolean types.
-   **Pointer Arithmetic:** Pointer arithmetic will be restricted to ensure it is C89-compatible.

## 5. Symbol Table and Memory Usage

The `SymbolTable` is a core component of the semantic analysis phase. It is owned by the `CompilationUnit` and provides hierarchical scope management for all identifiers.

## 9. Type Checker

The `TypeChecker` is a new component responsible for traversing the AST and verifying that the program adheres to the language's type rules. It is the primary consumer of the `Type` and `Symbol` information described in the previous sections.

### Traversal Strategy

The `TypeChecker` uses the visitor pattern to traverse the AST. It has a `visit` method for each `NodeType`, which allows for modular and extensible type-checking logic. The traversal is a recursive process that walks the tree, checking each node and its children.

### Integration in the Pipeline

The `TypeChecker` is integrated into the main compilation pipeline as a distinct stage that runs immediately after the parser. The process is as follows:
1. The `Parser` generates the full `AST`.
2. The `TypeChecker` is initialized with the `CompilationUnit`.
3. The `check` method of the `TypeChecker` is called with the root of the `AST`.
4. The `TypeChecker` traverses the tree, and if it finds any type errors, it reports them using the `ErrorHandler` in the `CompilationUnit`.

### Error Handling

The `TypeChecker` uses the existing `ErrorHandler` to report type-related errors. This ensures that type errors are reported in the same format as parsing errors, providing a consistent user experience.

### Memory Impact of the Refactored Symbol Table

The foundational refactoring of the `SymbolTable` introduced a more robust, scope-aware architecture. A key consequence of this change is an increase in the baseline memory usage for each `CompilationUnit`.

**Cause of Increased Memory Usage:**
The `SymbolTable` constructor now immediately performs allocations to set up its foundational data structures:
1.  It allocates a `DynamicArray` to hold the stack of `Scope` pointers.
2.  Upon construction, it immediately calls `enterScope()` to create the global scope. This involves allocating a `Scope` object and the `DynamicArray` for symbols within that scope.

This upfront memory cost was not present in the previous, simpler implementation.

**Impact on Performance and Unit Tests:**
This increased baseline memory usage, combined with the new symbol allocations during parsing, caused several unit tests with small, hardcoded `ArenaAllocator` sizes (e.g., 1024 or 2048 bytes) to fail with "Out of memory" errors. These tests were not provisioned for the additional memory overhead of a fully active symbol table.

The solution was to perform a comprehensive update of the test suite, increasing the arena sizes in all parser-related tests to 4096 bytes. This proactive measure ensures that the test environment is stable and has sufficient capacity for the new functionality, preventing spurious memory-related failures.

**Performance Concerns:**
The increase in baseline memory usage is not considered a significant performance concern for the following reasons:
- **Necessary Trade-off:** The memory is used to provide essential scoping functionality, which is a core requirement for the compiler.
- **Fixed Cost:** The initial allocation is a small, fixed cost per compilation unit. It does not grow with the size of the source file being compiled.
- **Efficient Allocation:** All allocations are still managed by the `ArenaAllocator`, which is extremely fast. The performance impact of the initial allocations is negligible in the context of a full compilation.

In summary, while the new `SymbolTable` has a slightly larger memory footprint, it is a deliberate and necessary architectural improvement. The impact is well-contained and does not compromise the overall performance goals of the compiler.

## 6. Type Resolution

To bridge the gap between the parser, which sees types as identifiers (e.g., `"i32"`), and the semantic analysis phase, which requires structured `Type` objects, a simple type resolution system has been implemented.

### `resolvePrimitiveTypeName`

A new function, `resolvePrimitiveTypeName(const char* name)`, has been introduced. Its responsibilities are:
-   It takes a string (an interned identifier name) as input.
-   It compares this string against a list of known primitive type names (e.g., "void", "bool", "i8", etc.).
-   If a match is found, it returns a pointer to a pre-defined, static, global `Type` object for that primitive.
-   If the name does not correspond to a known primitive type, it returns `NULL`.

This mechanism allows the parser to easily obtain a valid `Type*` for a symbol by looking up the type name found in the source code.

## 7. Parser Integration

To make the symbol table functional, it is integrated directly into the parsing process. This allows the parser to manage scopes and register symbols as it traverses the source code.

### Connection and Scope Management

-   **Constructor Injection:** The `CompilationUnit`, which owns the `SymbolTable`, passes a pointer to it into the `Parser`'s constructor.
-   **Scope Handling:** The parser is responsible for signaling the `SymbolTable` to create and destroy scopes.
    -   `parseFnDecl()` calls `enterScope()` before parsing the function body and `exitScope()` after, creating a dedicated scope for the function's contents.
    -   `parseBlockStatement()` does the same upon encountering `{` and `}` respectively, allowing for correct nested block scoping.

### Symbol Registration During Parsing

-   **`parseVarDecl()`:** When a variable declaration is parsed, this method:
    1.  Extracts the type name identifier from the `ASTNode` for the type.
    2.  Calls `resolvePrimitiveTypeName` to get a `Type*` for the variable. If this fails, it's a fatal error.
    3.  Constructs a `Symbol` for the variable using the `SymbolBuilder`.
    4.  Calls `symbol_table_->insert()` to register the symbol in the current scope.

-   **`parseFnDecl()`:** When a function is parsed, this method:
    1.  Constructs a `Symbol` for the function itself.
    2.  Inserts this `Symbol` into the *current* scope (e.g., the global scope for a top-level function). This happens *before* a new scope is entered for the function's body.

### Error Handling

-   **Duplicate Symbols:** If `symbol_table_->insert()` returns `false`, it indicates that a symbol with the same name already exists in the current scope. The parser treats this as a fatal semantic error and immediately calls its `error()` method to abort compilation. This provides simple and effective duplicate detection for both variables and functions.

## 8. Memory Profile Analysis (Milestone 4)

A memory profiling analysis was conducted to investigate the test suite's memory consumption and verify the soundness of the arena allocation strategy, particularly after the integration of the Symbol Table and other memory-intensive parser features.

### Methodology

The analysis employed a two-pronged approach:

1.  **Internal Instrumentation:** A temporary test case was added to run a representative piece of source code through the compilation pipeline. Using the `ArenaAllocator`'s existing `getOffset()` method, the test measured and reported the amount of memory consumed by each major stage (Lexer vs. Parser/Symbol Table). This temporary test code was removed after the analysis was complete.
2.  **External Profiling:** The entire test suite was compiled with debug symbols and run under the Valgrind/Massif heap profiling tool. This provided an external, objective view of the `test_runner` executable's complete memory lifecycle, allowing for the detection of any potential leaks or unexpected allocation patterns.

### Findings

The results from both methods were consistent and conclusive:

-   **No Memory Leaks Detected:** The Massif report showed a healthy, cyclical memory usage pattern. The heap size peaked during test execution and returned to a stable baseline after each test, confirming that the `ArenaAllocator`'s memory is being correctly allocated and subsequently released. There was no evidence of unbounded memory growth across the test suite.
-   **Memory Growth is Feature-Driven:** The internal instrumentation revealed the following breakdown for the sample code:
    -   **Lexer (Tokens & Interned Strings):** ~1.7 KB
    -   **Parser (AST Nodes & Symbols):** ~1.7 KB
    -   **Total Arena Usage:** ~3.5 KB
    This demonstrates that the addition of complex components like the AST and Symbol Table are responsible for the increased memory usage. The need to increase arena sizes in tests is a direct and expected consequence of this added complexity, not a bug.
-   **Low Overall Footprint:** The external profile showed a peak heap usage of approximately 86 KB. The majority of this (~74 KB) was attributable to C++ standard library runtime overhead (e.g., for I/O buffers). The memory directly allocated by the compiler's `ArenaAllocator` was consistently in the 4 KB range, aligning with the sizes specified in the tests.

### Conclusion

The memory allocation strategy is sound. The compiler components have a minimal and controlled memory footprint, and the arena-based approach is effectively preventing memory leaks. The observed increases in memory usage are a natural result of the project's evolution and do not indicate an underlying issue.
