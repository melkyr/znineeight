# Bootstrap Type System & Semantic Analysis

This document provides a detailed specification for the initial type system of the RetroZig bootstrap compiler. Its primary goal is to support a subset of Zig's type system that is directly translatable to C89, adhering to the project's strict technical and historical constraints.

## 1. Core Philosophy

The bootstrap type system is intentionally minimal. It is not designed to handle the full complexity of Zig's advanced type features (e.g., comptime types, error unions, slices). Instead, it focuses on a core set of primitive and pointer types that have direct equivalents in C89. This ensures that the code generated by the bootstrap compiler is simple, predictable, and compatible with legacy C compilers.

Semantic analysis at this stage will be limited to what is necessary to support this C89-compatible subset, including:
-   **Type checking:** Verifying that operations are performed on compatible types.
-   **Symbol resolution:** Looking up variables and functions in the symbol table.
-   **Scope management:** Handling global and function-level scopes.

## 2. Type Representation

The fundamental building block of the type system is the `Type` struct. It is designed to be a lightweight descriptor for any type recognized by the bootstrap compiler.

### `TypeKind` Enum

This enum defines all the primitive and composite types supported in the bootstrap phase. Each `TypeKind` corresponds to a C89-compatible data type.

```cpp
/**
 * @enum TypeKind
 * @brief Defines the kind of each type in the bootstrap type system.
 */
enum TypeKind {
    TYPE_VOID,
    TYPE_BOOL,
    // Integer Types
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    // Platform-dependent Integer Types
    TYPE_ISIZE, // Maps to i32 on a 32-bit target
    TYPE_USIZE, // Maps to u32 on a 32-bit target
    // Floating-Point Types
    TYPE_F32,
    TYPE_F64,
    // Complex Types
    TYPE_POINTER
};
```

### `Type` Struct

The `Type` struct contains the `TypeKind` discriminator, information about the type's size and alignment, and a `union` to hold data for composite types (like pointers).

```cpp
// Forward-declare Type for the pointer union member
struct Type;

/**
 * @struct Type
 * @brief Represents a type within the bootstrap compiler's type system.
 */
struct Type {
    TypeKind kind;
    size_t size;
    size_t alignment;

    union {
        /**
         * @struct PointerDetails
         * @brief Details specific to pointer types.
         */
        struct PointerDetails {
            Type* base; // The type that the pointer points to.
        } pointer;
    } as;
};
```

**Memory Management:** Like AST nodes, all `Type` structs are allocated from the `ArenaAllocator` to ensure fast allocation and simple, collective deallocation.

## 3. Type Compatibility and Coercion

The bootstrap type checker enforces a set of strict rules for type compatibility to prevent errors and ensure that the generated C89 code is valid.

### Implicit Coercion (Widening)

Implicit type coercion is only allowed for "safe" conversions where no data loss can occur. This is primarily limited to widening integer types.

-   A signed integer can be implicitly converted to a signed integer of a larger size (e.g., `i8` -> `i16`, `i16` -> `i32`).
-   An unsigned integer can be implicitly converted to an unsigned integer of a larger size (e.g., `u8` -> `u16`, `u16` -> `u32`).
-   A floating-point number can be implicitly widened (`f32` -> `f64`).

### Explicit Coercion (Casting)

All other conversions must be explicit. This includes:
-   Conversions between integer types that may result in data loss (e.g., `i32` -> `i16`).
-   Conversions between signed and unsigned integers.
-   Conversions between integer and floating-point types.
-   Conversions between pointer types (e.g., `*i32` to `*u8`).

### Type Compatibility Matrix

The following table summarizes the allowed implicit and explicit conversions:

| From Type | To Type       | Implicit | Explicit | Notes                               |
|-----------|---------------|----------|----------|-------------------------------------|
| `i8`      | `i16`, `i32`, `i64` | ✓        | -        | Safe widening conversion.           |
| `u8`      | `u16`, `u32`, `u64` | ✓        | -        | Safe widening conversion.           |
| `i32`     | `f32`, `f64`    | -        | ✓        | Requires an explicit cast.          |
| `f32`     | `f64`         | ✓        | -        | Safe widening conversion.           |
| `*T`      | `*U`          | -        | ✓        | Requires an explicit cast.          |

## 4. Semantic Analysis

The semantic analyzer will traverse the AST generated by the parser and use the type system to perform the following checks.

### Symbol Table

A `SymbolTable` is a critical component for semantic analysis, responsible for tracking all named entities (variables, functions, types) within a given scope. The bootstrap compiler's symbol table is designed for simplicity and efficiency, using an arena-allocated `DynamicArray` as its backing store.

#### `Symbol` Struct

Each entry in the symbol table is a `Symbol` struct, which contains all the necessary information about a named entity.

```cpp
/**
 * @struct Symbol
 * @brief Represents a named entity (variable, function, or type) in the symbol table.
 */
struct Symbol {
    /**
     * @enum Kind
     * @brief Discriminator for the type of symbol.
     */
    enum Kind { VARIABLE, FUNCTION, TYPE } kind;
    const char* name;       // Interned string for the symbol's name.
    Type* type;             // Pointer to the Type struct for this symbol.
    u32 address_offset;     // Stack or data offset for code generation.
    ASTNode* definition;    // Pointer to the AST node where this symbol was defined.
};
```

#### `SymbolTable` Class

The `SymbolTable` class manages a collection of symbols. For the initial bootstrap phase, it will only manage a single, global scope. Support for nested scopes will be added in a future task.

```cpp
/**
 * @class SymbolTable
 * @brief Manages a collection of symbols for a given scope.
 */
class SymbolTable {
    DynamicArray<Symbol>* symbols;
    ArenaAllocator* arena;
public:
    SymbolTable(ArenaAllocator* allocator);
    Symbol* lookup(const char* name);
    void insert(Symbol& sym);
};
```

-   **`lookup(const char* name)`:** Searches the table for a symbol with a matching (interned) name. Returns a pointer to the `Symbol` if found, or `NULL` otherwise.
-   **`insert(Symbol& sym)`:** Adds a new `Symbol` to the table. It does not check for duplicates; this responsibility is left to the semantic analyzer.

### Variable Declarations

-   The analyzer will check that the type of the initializer expression is compatible with the declared type of the variable.
-   It will ensure that a variable is not redefined within the same scope.

### Function Calls

-   The analyzer will verify that the number of arguments in a function call matches the number of parameters in the function's declaration.
-   It will check that the type of each argument is compatible with the type of the corresponding parameter.

### Operators

-   **Arithmetic Operators:** The analyzer will ensure that arithmetic operators (`+`, `-`, `*`, `/`) are only used with numeric types (integers and floats).
-   **Logical Operators:** Logical operators (`&&`, `||`, `!`) must be used with boolean types.
-   **Pointer Arithmetic:** Pointer arithmetic will be restricted to ensure it is C89-compatible.

## 5. Symbol Table and Memory Usage

The `SymbolTable` is a core component of the semantic analysis phase. It is owned by the `CompilationUnit` and provides hierarchical scope management for all identifiers.

### Memory Impact of the Refactored Symbol Table

The foundational refactoring of the `SymbolTable` introduced a more robust, scope-aware architecture. A key consequence of this change is an increase in the baseline memory usage for each `CompilationUnit`.

**Cause of Increased Memory Usage:**
The `SymbolTable` constructor now immediately performs allocations to set up its foundational data structures:
1.  It allocates a `DynamicArray` to hold the stack of `Scope` pointers.
2.  Upon construction, it immediately calls `enterScope()` to create the global scope. This involves allocating a `Scope` object and the `DynamicArray` for symbols within that scope.

This upfront memory cost was not present in the previous, simpler implementation.

**Impact on Performance and Unit Tests:**
This increased baseline memory usage caused several unit tests with small, hardcoded `ArenaAllocator` sizes (e.g., 1024 bytes) to fail with "Out of memory" errors. These tests were written with the assumption of a very low initial memory footprint and were not prepared for the additional allocations required by the new `SymbolTable`.

The solution was to increase the arena sizes in the affected tests (e.g., to 2048 bytes). This is an acceptable and necessary change.

**Performance Concerns:**
The increase in baseline memory usage is not considered a significant performance concern for the following reasons:
- **Necessary Trade-off:** The memory is used to provide essential scoping functionality, which is a core requirement for the compiler.
- **Fixed Cost:** The initial allocation is a small, fixed cost per compilation unit. It does not grow with the size of the source file being compiled.
- **Efficient Allocation:** All allocations are still managed by the `ArenaAllocator`, which is extremely fast. The performance impact of the initial allocations is negligible in the context of a full compilation.

In summary, while the new `SymbolTable` has a slightly larger memory footprint, it is a deliberate and necessary architectural improvement. The impact is well-contained and does not compromise the overall performance goals of the compiler.
