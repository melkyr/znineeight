# Bootstrap Type System & Semantic Analysis

This document provides a detailed specification for the initial type system of the RetroZig bootstrap compiler. Its primary goal is to support a subset of Zig's type system that is directly translatable to C89, adhering to the project's strict technical and historical constraints.

## 1. Core Philosophy

The bootstrap type system is intentionally minimal. It is not designed to handle the full complexity of Zig's advanced type features (e.g., comptime types, error unions, slices). Instead, it focuses on a core set of primitive and pointer types that have direct equivalents in C89. This ensures that the code generated by the bootstrap compiler is simple, predictable, and compatible with legacy C compilers.

Semantic analysis at this stage will be limited to what is necessary to support this C89-compatible subset, including:
-   **Type checking:** Verifying that operations are performed on compatible types.
-   **Symbol resolution:** Looking up variables and functions in the symbol table.
-   **Scope management:** Handling global and function-level scopes.

## 2. Type Representation

The fundamental building block of the type system is the `Type` struct. It is designed to be a lightweight descriptor for any type recognized by the bootstrap compiler.

### `TypeKind` Enum

This enum defines all the primitive and composite types supported in the bootstrap phase. Each `TypeKind` corresponds to a C89-compatible data type.

```cpp
/**
 * @enum TypeKind
 * @brief Defines the kind of each type in the bootstrap type system.
 */
enum TypeKind {
    TYPE_VOID,
    TYPE_BOOL,
    // Integer Types
    TYPE_I8, TYPE_I16, TYPE_I32, TYPE_I64,
    TYPE_U8, TYPE_U16, TYPE_U32, TYPE_U64,
    // Platform-dependent Integer Types
    TYPE_ISIZE, // Maps to i32 on a 32-bit target
    TYPE_USIZE, // Maps to u32 on a 32-bit target
    // Floating-Point Types
    TYPE_F32,
    TYPE_F64,
    // Complex Types
    TYPE_POINTER,
    TYPE_ARRAY,
    TYPE_FUNCTION,
    TYPE_ENUM
};
```

### `Type` Struct

The `Type` struct contains the `TypeKind` discriminator, information about the type's size and alignment, and a `union` to hold data for composite types (like pointers).

```cpp
// Forward-declare Type for the pointer union member
struct Type;

/**
 * @struct Type
 * @brief Represents a type within the bootstrap compiler's type system.
 */
struct Type {
    TypeKind kind;
    size_t size;
    size_t alignment;

    union {
        /**
         * @struct PointerDetails
         * @brief Details specific to pointer types.
         */
        struct PointerDetails {
            Type* base; // The type that the pointer points to.
            bool is_const;
        } pointer;

        /**
         * @struct FunctionDetails
         * @brief Details specific to function types.
         */
        struct FunctionDetails {
            DynamicArray<Type*>* params;
            Type* return_type;
        } function;

        /**
         * @struct ArrayDetails
         * @brief Details specific to array types.
         */
        struct ArrayDetails {
            Type* element_type; // The type of the elements in the array.
            u64 size;           // The number of elements in the array.
        } array;

        /**
         * @struct EnumDetails
         * @brief Details specific to enum types.
         */
        struct EnumDetails {
            Type* backing_type;
            DynamicArray<EnumMember>* members;
        } enum_details;
    } as;
};
```

**Memory Management:** Like AST nodes, all `Type` structs are allocated from the `ArenaAllocator` to ensure fast allocation and simple, collective deallocation.

## 3. Assignment Compatibility (C89 Rules)

To ensure the bootstrap compiler generates valid and predictable C89 code, the type checker enforces a strict set of rules for assignment, compound assignment, and variable initialization. These rules are generally stricter than the simple type compatibility used for function arguments. The core logic is encapsulated in the `IsTypeAssignableTo` method.

### The Default Rule: Strict Type Equality

For most operations, C89 requires that the types of the left-hand side (l-value) and right-hand side (r-value) be **identical**. The type checker enforces this as the default rule.

-   **Numeric Types:** An assignment is only valid if the source and target types are exactly the same. Implicit widening is **not** allowed in assignment contexts.
    -   `var x: i32 = my_i32;` // ✓ OK
    -   `var x: i64 = my_i32;` // ✗ **Error:** `i32` is not identical to `i64`.

### Exception 1: The Integer Literal Rule

A critical exception to the strict equality rule, inherited from C89, applies to **integer literals**. An integer literal (e.g., `42`, `-100`) can be assigned to a variable of any numeric type (integer or float) as long as the literal's value fits within the valid range of the target type.

-   `var x: i16 = 128;`      // ✓ OK: `128` fits in an `i16`.
-   `var x: u8 = 255;`       // ✓ OK: `255` fits in a `u8`.
-   `var x: i64 = 42;`       // ✓ OK: `42` (inferred as `i32` literal) fits in an `i64`.
-   `var x: u8 = -1;`        // ✗ **Error:** `-1` is out of range for `u8`.
-   `var x: i8 = 128;`       // ✗ **Error:** `128` overflows `i8`.

This logic is primarily handled in the `visitVarDecl` method, which uses the `canLiteralFitInType` helper to perform the value range check.

### Exception 2: Pointer Assignment Rules

Pointer assignments follow a specific set of C89-compatible rules:

1.  **Null Assignment:** The `null` literal can be assigned to a variable of any pointer type.
    -   `var p: *i32 = null;` // ✓ OK

2.  **Implicit Cast to `void*`:** Any typed pointer (`*T`) can be implicitly assigned to a `void` pointer (`*void`).
    -   `var p_void: *void = my_i32_ptr;` // ✓ OK

3.  **No Implicit Cast from `void*`:** A `void` pointer cannot be implicitly assigned to a typed pointer. This would require an explicit cast, which is not supported in the bootstrap compiler.
    -   `var p_i32: *i32 = my_void_ptr;` // ✗ **Error**

4.  **Const Correctness:**
    -   A mutable pointer (`*T`) can be assigned to a constant pointer (`*const T`). This is a safe, "const-adding" conversion.
        - `var p_const: *const i32 = my_i32_ptr;` // ✓ OK
    -   A constant pointer (`*const T`) cannot be assigned to a mutable pointer (`*T`). This would unsafely remove the `const` qualification.
        - `var p_mut: *i32 = my_const_i32_ptr;` // ✗ **Error**

### Summary of Assignment Rules

| From Type (`source`)    | To Type (`target`)     | Assignable? | Notes                                                              |
|-------------------------|------------------------|-------------|--------------------------------------------------------------------|
| `numeric`               | `numeric`              | ✗ (if different) | Must be identical types.                                           |
| `integer_literal`       | `any_numeric`          | ✓ (if value fits) | C89 exception for literals.                                        |
| `null`                  | `*T` (any pointer)     | ✓           | `null` is compatible with all pointers.                            |
| `*T`                    | `*void`                | ✓           | Implicit "up-cast" to void pointer.                                |
| `*void`                 | `*T`                   | ✗           | Requires an explicit cast.                                         |
| `*T`                    | `*const T`             | ✓           | Safe to add `const`.                                               |
| `*const T`              | `*T`                   | ✗           | Unsafe to remove `const`.                                          |
| `*T`                    | `*U` (different types) | ✗           | Incompatible pointer base types.                                   |


## 4. Semantic Analysis

The semantic analyzer will traverse the AST generated by the parser and use the type system to perform the following checks.

### Symbol Table

A `SymbolTable` is a critical component for semantic analysis, responsible for tracking all named entities (variables, functions, types) across different scopes. The bootstrap compiler's symbol table is designed for performance and efficiency, using a hash table for symbol storage within each scope.

#### Implementation Details

-   **Hierarchical Scopes:** The `SymbolTable` class manages a stack of `Scope` objects, allowing it to correctly model nested scopes (e.g., function bodies, block statements). `enterScope()` pushes a new scope onto the stack, and `exitScope()` pops it.
-   **Hash Table:** Each `Scope` object contains a hash table to store its symbols. This provides an average time complexity of O(1) for symbol insertion and lookup operations, a significant improvement over the previous O(n) linear scan approach.
-   **Collision Resolution:** Collisions in the hash table are resolved using separate chaining. Each bucket in the hash table is a linked list of `SymbolEntry` structs.
-   **Hashing Algorithm:** The hash table uses the 32-bit FNV-1a algorithm to hash symbol names, which provides good distribution for identifiers.
-   **Dynamic Resizing:** To maintain O(1) performance, the hash table automatically resizes itself when its load factor exceeds 75% (0.75). When a resize is triggered, the number of buckets is doubled, and all existing symbols are re-hashed into the new, larger table.

#### `Symbol` Struct

Each entry in the symbol table is a `Symbol` struct, which contains all the necessary information about a named entity.

```cpp
// from symbol_table.hpp
struct Symbol {
    const char* name;
    SymbolType kind;
    Type* symbol_type;
    SourceLocation location;
    void* details;
    unsigned int scope_level;
    unsigned int flags;
};
```

#### `SymbolTable` and `Scope` Classes

The `SymbolTable` class orchestrates scope management, while the `Scope` struct handles the actual storage of symbols.

```cpp
// from symbol_table.hpp
class SymbolTable {
    // ...
public:
    void enterScope();
    void exitScope();
    bool insert(const Symbol& symbol);
    Symbol* lookup(const char* name);
    Symbol* lookupInCurrentScope(const char* name);
    // ...
};
```

-   **`lookup(const char* name)`:** Searches for a symbol starting from the current (innermost) scope and proceeding outwards to the global scope. Returns the first match found.
-   **`insert(const Symbol& symbol)`:** Inserts a symbol into the current scope's hash table. It first checks for redefinitions within the current scope and returns `false` if a symbol with the same name already exists.

### Variable Declarations

When visiting a variable declaration (`ASTVarDeclNode`), the `TypeChecker` performs the following validation:
-   It resolves the declared type of the variable.
-   It then checks the initializer. If the initializer is an integer literal, it uses the special C89 literal assignment rule (`canLiteralFitInType`).
-   For all other initializer types, it uses the strict `IsTypeAssignableTo` function to validate the assignment.
-   If the types are not compatible, a detailed `ERR_TYPE_MISMATCH` is reported.
-   Redefinition checks are handled by the `Parser` when it inserts the variable's symbol into the `SymbolTable`.

### Array Type Declarations

When visiting an array type declaration (`ASTArrayTypeNode`), the `TypeChecker` enforces strict C89 compatibility rules:

1.  **Slice Rejection:** Slices (e.g., `[]u8`) are not supported in C89. The `TypeChecker` identifies a slice by checking if the `size` expression in the `ASTArrayTypeNode` is `NULL`. If it is, compilation is aborted with a fatal error: "Slices are not supported in C89 mode".

2.  **Constant Size Enforcement:** C89 requires that array sizes be compile-time constants. The bootstrap compiler enforces a strict version of this rule: the size expression must be a single integer literal (e.g., `[8]i32`). If the size expression is any other kind of node (e.g., an identifier, a binary operation), compilation is aborted with a fatal error: "Array size must be a constant integer literal".

If both checks pass, a new `Type` of kind `TYPE_ARRAY` is created. Its `size` field is calculated from the element type's size and the array's length, and its `as.array` details are populated accordingly.

### Struct and Union Field Validation

When visiting a struct or union declaration (`ASTStructDeclNode` or `ASTUnionDeclNode`), the `TypeChecker` iterates through all of the container's fields to ensure they are C89-compatible.

1.  **Field Type Resolution:** For each field, the `TypeChecker` first visits the field's type node to resolve it into a `Type*`.

2.  **C89 Compatibility Check:** It then calls the `is_c89_compatible()` function on the resolved field type.

3.  **Fatal Error on Incompatible Field:** If `is_c89_compatible()` returns `false`, it signifies that the field's type is not supported in the C89 subset (e.g., a slice `[]u8`, a multi-level pointer `**i32`, or an `isize`). This is treated as a fatal error, and the `TypeChecker` immediately calls its `fatalError` method to abort compilation. This strict approach prevents any non-C89 types from being included in struct or union definitions.

### Enum Type Declarations

When visiting an enum declaration (`ASTEnumDeclNode`), the `TypeChecker` creates a new `TYPE_ENUM` and enforces several C89-centric validation rules:

1.  **Backing Type Resolution:** It resolves the enum's backing type. If no explicit backing type is provided (e.g., `enum { A, B }`), it defaults to `i32` to ensure compatibility with standard C enums.

2.  **Integer Backing Type:** The backing type must be a C89-compatible integer. Any other type (e.g., `f32`, a pointer, or a struct) will result in a fatal error.

3.  **Constant Initializers:** Any explicit value assigned to an enum member (e.g., `A = 10`, `B = -1`) must be a constant integer literal. The `TypeChecker` correctly handles both positive and negative integer literals by accounting for the `NODE_UNARY_OP` (with `TOKEN_MINUS`) that represents a negative number in the AST. The use of variables or complex expressions as initializers is a fatal error.

4.  **Auto-increment Logic:** The `TypeChecker` correctly implements Zig-style auto-incrementing. If a member has no explicit initializer, its value is automatically assigned as `previous_member_value + 1`. The first member defaults to `0`. This logic correctly follows from both explicit and other auto-incremented values.

5.  **Value Range Validation:** The final value of every enum member (whether explicit or auto-incremented) is rigorously checked to ensure it fits within the valid range of the enum's backing type. For example, a value of `256` in an `enum(u8)` will trigger a fatal overflow error.

This set of rules ensures that every enum processed by the bootstrap compiler is a distinct type that can be safely and correctly represented as a C89 `enum`.

### Function Declarations and Signatures

When visiting a function declaration (`ASTFnDeclNode`), the `TypeChecker` performs a comprehensive validation of the entire function signature:

1.  **Parameter Type Resolution:** It iterates through each parameter in the function's declaration. For each parameter, it visits the corresponding type node (e.g., `ASTTypeNameNode`, `ASTPointerTypeNode`).
    -   If a parameter's type name cannot be resolved to a known type (e.g., `fn my_func(a: NotARealType)`), it reports an `ERR_UNDECLARED_TYPE` error.
    -   This validation prevents further errors that would arise from using an invalid type within the function body.

2.  **Return Type Resolution:** It resolves the function's return type by visiting its type node. If the return type is invalid, it also reports an `ERR_UNDECLARED_TYPE` error.

3.  **Function Type Creation:** If all parameter and return types are valid, it constructs a new `Type` object with the kind `TYPE_FUNCTION`. This `Type` object stores a `DynamicArray` of the parameter types and a pointer to the return type.

4.  **Symbol Update:** The `TypeChecker` then updates the function's `Symbol` in the `SymbolTable` to point to this newly created function type. This makes the full signature available for future use, such as in type-checking function calls.

5.  **Return Statement Validation:** After processing the signature, it proceeds to visit the function's body. When it encounters a `return` statement, it compares the type of the returned expression against the `current_fn_return_type` it recorded while visiting the signature, ensuring that the return value is compatible with the function's declared return type.

### Function Calls

-   The analyzer will verify that the number of arguments in a function call matches the number of parameters in the function's declaration.
-   It will check that the type of each argument is compatible with the type of the corresponding parameter.

#### C89 Compatibility Restrictions

To ensure that the output of the bootstrap compiler is compatible with C89, several restrictions are enforced during semantic analysis. These limitations are designed to prevent the use of modern language features that do not have a direct and simple equivalent in C89.

Function calls are subject to the following strict limitations:

1.  **Maximum Number of Arguments:** A function call cannot have more than four arguments. This is a conservative limit to ensure compatibility with various C89-era calling conventions and stack limitations. Any call with five or more arguments will trigger a fatal compilation error.

2.  **No Function Pointers:** The bootstrap compiler does not support calling functions via pointers. Any attempt to call a variable that holds a function (i.e., a function pointer) will be rejected with a fatal error.

    *Note on testing:* The current parser does not support type inference for variable declarations (e.g., `var func_ptr = my_func;`). As a result, tests for this specific feature currently fail during the parsing phase, preventing the `TypeChecker` from running. The check remains in the `TypeChecker` for correctness and future-proofing.

3.  **No Variadic Functions:** The parser does not support the syntax for declaring or calling variadic functions (e.g., `printf`-style functions with `...`).

### Operators

-   **Arithmetic Operators:** The analyzer will ensure that arithmetic operators (`+`, `-`, `*`, `/`) are only used with numeric types (integers and floats). The unary negation operator (`-`) is also restricted to numeric types; applying it to any other type is a fatal C89 compatibility error.
-   **Logical Operators:** Logical operators (`and`, `or`, `!`) must be used with boolean types. However, to align with C-style contexts, the unary logical NOT (`!`) can be applied to booleans, integers, and pointers, and its result is always `bool`. Applying `!` to any other type is a fatal error.
-   **Bitwise NOT (`~`):** The bitwise NOT operator can only be applied to integer types. Applying it to any other type (e.g., a float or a boolean) is a fatal C89 compatibility error.
-   **Pointer Operations:**
    -   **Address-of (`&`):** This operator can only be applied to l-values. An l-value is a memory location that can be assigned to. In the bootstrap compiler, the following are considered l-values:
        -   Variables (e.g., `&my_var`).
        -   Array accesses (e.g., `&my_array[i]`).
        -   Pointer dereferences (e.g., `&*my_ptr`).
        Applying `&` to an r-value (e.g., a literal `&42`, or the result of an arithmetic operation `&(a + b)`) will result in an `ERR_LVALUE_EXPECTED`. The resulting type of `&x` where `x` has type `T` is `*T`.
    -   **Dereference (`*`):** This operator can only be applied to an expression of a pointer type. The following rules are enforced:
        -   Applying `*` to a non-pointer type will result in a non-fatal `ERR_TYPE_MISMATCH`.
        -   Applying `*` to the `null` literal will result in a non-fatal `ERR_TYPE_MISMATCH`.
        -   Applying `*` to a `void` pointer (`*void`) will result in a fatal error, as this is a violation of C89 rules.
        -   The resulting type of `*p` where `p` has type `*T` or `*const T` is `T`.
        -   *Note on `const`*: While the type system correctly resolves the type of a dereferenced `*const T` to `T`, the enforcement of immutability (i.e., preventing assignments like `*p = 10`) is handled during the semantic analysis of assignment expressions (Task 107), not by the dereference operator itself.
    -   **Pointer Arithmetic:** To ensure C89 compatibility, the type checker enforces the following rules for pointer arithmetic:
        -   `pointer + integer` -> `pointer`: The result is a pointer of the same type.
        -   `integer + pointer` -> `pointer`: The result is a pointer of the same type.
        -   `pointer - integer` -> `pointer`: The result is a pointer of the same type.
        -   `pointer - pointer` -> `isize`: The result is a signed integer of type `isize`. This is only valid if both pointers are of the same type (e.g., `*i32` and `*i32`).
        -   Any other arithmetic operations involving pointers (e.g., `pointer + pointer`, `pointer * integer`) are considered a type error.

### Control Flow Statements

-   **`if` and `while` Statements:** The condition of an `if` or `while` statement is expected to be a type that can be evaluated in a boolean context. To align with C89-style behavior, the `TypeChecker` accepts conditions of the following types:
    -   `bool`
    -   Any integer type (`i8` through `u64`, `isize`, `usize`)
    -   Any pointer type (`*T`)
    If the condition is of any other type (e.g., `void`, `f32`, a struct), a non-fatal `ERR_TYPE_MISMATCH` error is reported.

### Function Calls

When visiting a function call (`ASTFunctionCallNode`), the `TypeChecker` performs a series of critical validations to ensure the call is well-formed and adheres to the bootstrap compiler's constraints.

1.  **Callee Type Verification:** The checker first resolves the type of the expression being called. It ensures that the callee is a symbol of kind `FUNCTION` and has a `TYPE_FUNCTION` type. This check is crucial as it prevents attempts to call variables or other non-function entities, which is how calls to function pointers are rejected.

2.  **Argument Count Check:** It verifies that the number of arguments provided in the call exactly matches the number of parameters specified in the function's signature. If the counts mismatch, it reports a fatal error with a message like "wrong number of arguments to function call, expected 2, got 1".

3.  **Argument Type Compatibility:** It iterates through each argument and compares its type to the corresponding parameter's type using the `areTypesCompatible` function. This allows for safe, implicit widening conversions (e.g., passing an `i16` to an `i32` parameter) but rejects incompatible types. A mismatch results in a fatal error detailing the expected and actual types.

4.  **C89 Argument Limit:** To maintain compatibility with legacy C89 compilers and calling conventions, the type checker enforces a hard limit of a maximum of 4 arguments per function call. Any call with five or more arguments will result in a fatal error.

### Expression Type Checking

When visiting expressions, the `TypeChecker` determines the resulting type of the expression.

-   **Identifiers:** The type of an identifier is determined by looking up its symbol in the `SymbolTable`. If the symbol is not found, an `ERR_UNDEFINED_VARIABLE` error is reported.

-   **Binary Operations:**
    -   **Arithmetic (`+`, `-`, `*`, `/`, `%`):** Both operands must be of the same numeric type. The resulting type is the same as the operand types. Operations between different numeric types (e.g., `i32` and `f64`) are not allowed.
    -   **Comparisons (`==`, `!=`, `<`, `>`, `<=`, `>=`):** Both operands must be of the same numeric type. The resulting type is always `bool`.

#### Binary Operator Implementation Status

To clarify the current capabilities of the type checker and guide future development, the following table outlines the implementation status of all binary operators within the `visitBinaryOp` method.

| Operator | Category      | Implemented? | Notes                                                              |
|----------|---------------|--------------|--------------------------------------------------------------------|
| `+`      | Arithmetic    | **Yes**      | Supports numeric types and pointer/integer addition.               |
| `-`      | Arithmetic    | **Yes**      | Supports numeric types and pointer/integer/pointer subtraction.    |
| `*`      | Arithmetic    | **Yes**      | Supports numeric types only.                                       |
| `/`      | Arithmetic    | **Yes**      | Supports numeric types only.                                       |
| `%`      | Arithmetic    | **Yes**      | Supports numeric types only.                                       |
| `==`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `!=`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `<`      | Comparison    | **Yes**      | Supports numeric types.                                            |
| `<=`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `>`      | Comparison    | **Yes**      | Supports numeric types.                                            |
| `>=`     | Comparison    | **Yes**      | Supports numeric types.                                            |
| `&`      | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `|`      | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `^`      | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `<<`     | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `>>`     | Bitwise       | No           | Generates a specific "not implemented yet" error.                  |
| `and`    | Logical       | Yes          | Correctly parsed and handled.                                      |
| `or`     | Logical       | Yes          | Correctly parsed and handled.                                      |

-   **Pointer Operations:**
    -   **Address-of (`&`):** This operator can only be applied to l-values. An l-value is a memory location that can be assigned to. In the bootstrap compiler, the following are considered l-values:
        -   Variables (e.g., `&my_var`).
        -   Array accesses (e.g., `&my_array[i]`).
        -   Pointer dereferences (e.g., `&*my_ptr`).
        Applying `&` to an r-value (e.g., a literal `&42`, or the result of an arithmetic operation `&(a + b)`) will result in an `ERR_TYPE_MISMATCH`. The resulting type of `&x` where `x` has type `T` is `*T`.
    -   **Dereference (`*`):** This operator can only be applied to an expression of a pointer type. Applying `*` to a non-pointer type will result in an `ERR_TYPE_MISMATCH`. The resulting type of `*p` where `p` has type `*T` or `*const T` is `T`.
        -   *Note on `const`*: While the type system correctly resolves the type of a dereferenced `*const T` to `T`, the enforcement of immutability (i.e., preventing assignments like `*p = 10`) is handled during the semantic analysis of assignment expressions (Task 107), not by the dereference operator itself.
    -   **Pointer Arithmetic:** To ensure C89 compatibility, the type checker enforces the following rules for pointer arithmetic:
        -   `pointer + integer` -> `pointer`: The result is a pointer of the same type.
        -   `integer + pointer` -> `pointer`: The result is a pointer of the same type.
        -   `pointer - integer` -> `pointer`: The result is a pointer of the same type.
        -   `pointer - pointer` -> `isize`: The result is a signed integer of type `isize`. This is only valid if both pointers are of the same type (e.g., `*i32` and `*i32`).
        -   Any other arithmetic operations involving pointers (e.g., `pointer + pointer`, `pointer * integer`) are considered a type error.

-   **Literals:**
    -   **`true`, `false`:** Inferred as type `bool`.
    -   **Integer Literals:** The type is determined by the literal's value and suffix to be the smallest possible C89-compatible type that can hold the value.
        -   **Unsigned Literals (e.g., `123u`):**
            -   `0` to `255`: `u8`
            -   `256` to `65535`: `u16`
            -   `65536` to `4294967295`: `u32`
            -   Larger values: `u64`
        -   **Signed Literals (e.g., `123`, `-45`):**
            -   `-128` to `127`: `i8`
            -   `-32768` to `32767`: `i16`
            -   `-2147483648` to `2147483647`: `i32`
            -   Larger values: `i64`
        -   The `L` suffix is parsed by the lexer for C89 compatibility but does not currently affect the type inference logic, as the system already selects the smallest possible type.
    -   **Floating-Point Literals:** All floating-point literals (e.g., `3.14`) are inferred as type `f64`.
    -   **Character Literals:** A character literal (e.g., `'a'`) is inferred as type `u8`.
    -   **String Literals:** A string literal (e.g., `"hello"`) is inferred as type `*const u8` (a pointer to constant `u8` characters).
    -   **Memory Overhead:** The validation of literal types is a stateless process within the `TypeChecker`. It is based on the value and syntax of the literal itself and does not require the creation of any new, persistent data structures or heap allocations, thus adhering to the project's strict memory constraints.

### Control Flow Statements

-   **`if` and `while` Statements:** The condition of an `if` or `while` statement is expected to be a type that can be evaluated in a boolean context. To align with C89-style behavior, the `TypeChecker` accepts conditions of the following types:
    -   `bool`
    -   Any integer type (`i8` through `u64`, `isize`, `usize`)
    -   Any pointer type (`*T`)
    If the condition is of any other type (e.g., `void`, `f32`, a struct), a non-fatal `ERR_TYPE_MISMATCH` error is reported.

### `void` Type Validation

To ensure C89 compatibility, the `TypeChecker` enforces several strict rules regarding the use of the `void` type:

-   **Variable Declarations:** Variables cannot be declared with the type `void`. An attempt to do so (e.g., `var x: void;`) will result in an `ERR_VARIABLE_CANNOT_BE_VOID` error.

-   **Function Returns:**
    -   A function declared with a `void` return type can have an empty `return;` statement or no `return` statement at all (an implicit return).
    -   Attempting to return a value from a `void` function (e.g., `return 123;`) will result in an `ERR_INVALID_RETURN_VALUE_IN_VOID_FUNCTION` error.
    -   A non-`void` function must have a `return` statement with a value of a compatible type. A `return;` statement without a value, or an implicit return by falling off the end of the function, will result in an `ERR_MISSING_RETURN_VALUE` error.

-   **Pointer Arithmetic:** Pointer arithmetic is not permitted on pointers of type `*void`. Attempting to perform addition or subtraction on a `void*` will result in an `ERR_INVALID_VOID_POINTER_ARITHMETIC` error.

## 5. C89 Compatibility Enforcement

To ensure the bootstrap compiler produces valid C89 code, a multi-layered approach is used to reject non-C89 features.

### AST Pre-Scan for Incompatible Syntax

The first layer of enforcement is the **AST Pre-Scan**. Immediately after parsing is complete, a dedicated visitor class, the `C89FeatureValidator`, traverses the AST. It looks for syntactic constructs that are fundamentally incompatible with C89, such as slices (`[]u8`) and error-handling expressions (`try`, `catch`, `orelse`).

If any of these features are found, the validator immediately aborts compilation with a fatal error. This "fail-fast" approach is detailed in the `C89_rejection_framework.md` document.

### Type System Validation

The second layer of enforcement occurs within the `TypeChecker` and the type system itself. This is handled by a formal system for mapping and validating types, which is defined in the `src/include/c89_type_mapping.hpp` header.

### C89 Primitive Type Mapping Table

A static mapping table, `c89_type_map`, defines the direct correspondence between the RetroZig compiler's primitive `TypeKind`s and their C89 string equivalents. This table is the single source of truth for C89 type compatibility.

| RetroZig TypeKind | C89 Equivalent         | Notes                          |
|-------------------|------------------------|--------------------------------|
| `TYPE_VOID`       | `"void"`               | Size: 0, Align: 0              |
| `TYPE_BOOL`       | `"int"`                | Size: 4, Align: 4. C89 has no native `_Bool`. |
| `TYPE_I8`         | `"signed char"`        | Size: 1, Align: 1              |
| `TYPE_I16`        | `"short"`              | Size: 2, Align: 2              |
| `TYPE_I32`        | `"int"`                | Size: 4, Align: 4              |
| `TYPE_I64`        | `"__int64"`            | Size: 8, Align: 8. For MSVC 6.0 compatibility. |
| `TYPE_U8`         | `"unsigned char"`      | Size: 1, Align: 1              |
| `TYPE_U16`        | `"unsigned short"`     | Size: 2, Align: 2              |
| `TYPE_U32`        | `"unsigned int"`       | Size: 4, Align: 4              |
| `TYPE_U64`        | `"unsigned __int64"`   | Size: 8, Align: 8. For MSVC 6.0 compatibility. |
| `TYPE_F32`        | `"float"`              | Size: 4, Align: 4              |
| `TYPE_F64`        | `"double"`             | Size: 8, Align: 8              |

*Note: `isize` and `usize` are intentionally excluded from this mapping as they do not have a direct, platform-independent equivalent in C89.*

### The `is_c89_compatible` Function

A static inline function, `is_c89_compatible(Type* type)`, provides the mechanism for enforcing the C89 type subset. Its behavior is as follows:

-   **Returns `true`** for any primitive type whose `TypeKind` is present in the `c89_type_map` table.
-   **Returns `true`** for a single-level pointer (e.g., `*i32`) whose base type is a C89-compatible primitive.
-   **Returns `true`** for an array type (e.g., `[8]u8`, `[4][4]f32`) if its final base element type is a C89-compatible primitive.
-   **Returns `true`** for a function type, but only if it meets the following strict criteria:
    -   The function must not have more than 4 parameters.
    -   The return type must be C89-compatible.
    -   All parameter types must be C89-compatible.
    -   Neither the return type nor any parameter type can be a function type itself (i.e., no function pointers).
-   **Returns `false`** for `NULL` types.
-   **Returns `false`** for any type not in the mapping table (e.g., `isize`, `usize`).
-   **Returns `false`** for multi-level pointers (e.g., `**i32`, `*const *u8`).

This function is a cornerstone of the semantic analysis phase, allowing the `TypeChecker` to reject unsupported Zig features early in the compilation process.

## 6. Symbol Table and Memory Usage

The `SymbolTable` is a core component of the semantic analysis phase. It is owned by the `CompilationUnit` and provides hierarchical scope management for all identifiers.

## 9. Type Checker

The `TypeChecker` is a new component responsible for traversing the AST and verifying that the program adheres to the language's type rules. It is the primary consumer of the `Type` and `Symbol` information described in the previous sections.

### Traversal Strategy

The `TypeChecker` uses the visitor pattern to traverse the AST. It has a `visit` method for each `NodeType`, which allows for modular and extensible type-checking logic. The traversal is a recursive process that walks the tree, checking each node and its children.

### Integration in the Pipeline

The `TypeChecker` is integrated into the main compilation pipeline as a distinct stage that runs immediately after the parser. The process is as follows:
1. The `Parser` generates the full `AST`.
2. The `TypeChecker` is initialized with the `CompilationUnit`.
3. The `check` method of the `TypeChecker` is called with the root of the `AST`.
4. The `TypeChecker` traverses the tree, and if it finds any type errors, it reports them using the `ErrorHandler` in the `CompilationUnit`.

### Error Handling

The `TypeChecker` uses the existing `ErrorHandler` to report type-related errors. This ensures that type errors are reported in the same format as parsing errors, providing a consistent user experience.

### Memory Impact of the Refactored Symbol Table

The foundational refactoring of the `SymbolTable` introduced a more robust, scope-aware architecture. A key consequence of this change is an increase in the baseline memory usage for each `CompilationUnit`.

**Cause of Increased Memory Usage:**
The `SymbolTable` constructor now immediately performs allocations to set up its foundational data structures:
1.  It allocates a `DynamicArray` to hold the stack of `Scope` pointers.
2.  Upon construction, it immediately calls `enterScope()` to create the global scope. This involves allocating a `Scope` object and the `DynamicArray` for symbols within that scope.

This upfront memory cost was not present in the previous, simpler implementation.

**Impact on Performance and Unit Tests:**
This increased baseline memory usage, combined with the new symbol allocations during parsing, caused several unit tests with small, hardcoded `ArenaAllocator` sizes (e.g., 1024 or 2048 bytes) to fail with "Out of memory" errors. These tests were not provisioned for the additional memory overhead of a fully active symbol table.

The solution was to perform a comprehensive update of the test suite, increasing the arena sizes in all parser-related tests from 4096 to 8192 bytes. This proactive measure ensures that the test environment is stable and has sufficient capacity for the new functionality, preventing spurious memory-related failures.

**Performance Concerns:**
The increase in baseline memory usage is not considered a significant performance concern for the following reasons:
- **Necessary Trade-off:** The memory is used to provide essential scoping functionality, which is a core requirement for the compiler.
- **Fixed Cost:** The initial allocation is a small, fixed cost per compilation unit. It does not grow with the size of the source file being compiled.
- **Efficient Allocation:** All allocations are still managed by the `ArenaAllocator`, which is extremely fast. The performance impact of the initial allocations is negligible in the context of a full compilation.

In summary, while the new `SymbolTable` has a slightly larger memory footprint, it is a deliberate and necessary architectural improvement. The impact is well-contained and does not compromise the overall performance goals of the compiler.

## 6. Type Resolution

To bridge the gap between the parser, which sees types as identifiers (e.g., `"i32"`), and the semantic analysis phase, which requires structured `Type` objects, a simple type resolution system has been implemented.

### `resolvePrimitiveTypeName`

A new function, `resolvePrimitiveTypeName(const char* name)`, has been introduced. Its responsibilities are:
-   It takes a string (an interned identifier name) as input.
-   It compares this string against a list of known primitive type names (e.g., "void", "bool", "i8", etc.).
-   If a match is found, it returns a pointer to a pre-defined, static, global `Type` object for that primitive.
-   If the name does not correspond to a known primitive type, it returns `NULL`.

This mechanism allows the parser to easily obtain a valid `Type*` for a symbol by looking up the type name found in the source code.

### `createPointerType`
A helper function, `createPointerType(ArenaAllocator& arena, Type* base_type, bool is_const)`, has been added to facilitate the creation of pointer types. It allocates a new `Type` object from the arena, sets its kind to `TYPE_POINTER`, and links it to the provided base type, respecting the `const` qualifier.

### `createFunctionType`
A new helper function, `createFunctionType(ArenaAllocator& arena, DynamicArray<Type*>* params, Type* return_type)`, has been added to create `TYPE_FUNCTION` objects. It allocates a new `Type` and populates it with the list of parameter types and the return type.

## 7. Parser Integration

To make the symbol table functional, it is integrated directly into the parsing process. This allows the parser to manage scopes and register symbols as it traverses the source code.

### Connection and Scope Management

-   **Constructor Injection:** The `CompilationUnit`, which owns the `SymbolTable`, passes a pointer to it into the `Parser`'s constructor.
-   **Scope Handling:** The parser is responsible for signaling the `SymbolTable` to create and destroy scopes.
    -   `parseFnDecl()` calls `enterScope()` before parsing the function body and `exitScope()` after, creating a dedicated scope for the function's contents.
    -   `parseBlockStatement()` does the same upon encountering `{` and `}` respectively, allowing for correct nested block scoping.

### Expression Statements
The parser now supports "expression statements", which are statements that consist of a single expression followed by a semicolon (e.g., `my_function();` or `"a string";`). This is handled by a new `NODE_EXPRESSION_STMT` in the AST.

### Symbol Registration During Parsing

-   **`parseVarDecl()`:** When a variable declaration is parsed, this method:
    1.  Extracts the type name identifier from the `ASTNode` for the type.
    2.  Calls `resolvePrimitiveTypeName` to get a `Type*` for the variable. If this fails, it's a fatal error.
    3.  Constructs a `Symbol` for the variable using the `SymbolBuilder`.
    4.  Calls `symbol_table_->insert()` to register the symbol in the current scope.

-   **`parseFnDecl()`:** When a function is parsed, this method:
    1.  Constructs a `Symbol` for the function itself.
    2.  Inserts this `Symbol` into the *current* scope (e.g., the global scope for a top-level function). This happens *before* a new scope is entered for the function's body.

### Error Handling

-   **Duplicate Symbols:** If `symbol_table_->insert()` returns `false`, it indicates that a symbol with the same name already exists in the current scope. The parser treats this as a fatal semantic error and immediately calls its `error()` method to abort compilation. This provides simple and effective duplicate detection for both variables and functions.

## 8. Memory Profile Analysis (Milestone 4)

A memory profiling analysis was conducted to investigate the test suite's memory consumption and verify the soundness of the arena allocation strategy, particularly after the integration of the Symbol Table and other memory-intensive parser features.

### Methodology

The analysis employed a two-pronged approach:

1.  **Internal Instrumentation:** A temporary test case was added to run a representative piece of source code through the compilation pipeline. Using the `ArenaAllocator`'s existing `getOffset()` method, the test measured and reported the amount of memory consumed by each major stage (Lexer vs. Parser/Symbol Table). This temporary test code was removed after the analysis was complete.
2.  **External Profiling:** The entire test suite was compiled with debug symbols and run under the Valgrind/Massif heap profiling tool. This provided an external, objective view of the `test_runner` executable's complete memory lifecycle, allowing for the detection of any potential leaks or unexpected allocation patterns.

### Findings

The results from both methods were consistent and conclusive:

-   **No Memory Leaks Detected:** The Massif report showed a healthy, cyclical memory usage pattern. The heap size peaked during test execution and returned to a stable baseline after each test, confirming that the `ArenaAllocator`'s memory is being correctly allocated and subsequently released. There was no evidence of unbounded memory growth across the test suite.
-   **Memory Growth is Feature-Driven:** The internal instrumentation revealed the following breakdown for the sample code:
    -   **Lexer (Tokens & Interned Strings):** ~1.7 KB
    -   **Parser (AST Nodes & Symbols):** ~1.7 KB
    -   **Total Arena Usage:** ~3.5 KB
    This demonstrates that the addition of complex components like the AST and Symbol Table are responsible for the increased memory usage. The need to increase arena sizes in tests is a direct and expected consequence of this added complexity, not a bug.
-   **Low Overall Footprint:** The external profile showed a peak heap usage of approximately 86 KB. The majority of this (~74 KB) was attributable to C++ standard library runtime overhead (e.g., for I/O buffers). The memory directly allocated by the compiler's `ArenaAllocator` was consistently in the 4 KB range, aligning with the sizes specified in the tests.

### Conclusion

The memory allocation strategy is sound. The compiler components have a minimal and controlled memory footprint, and the an arena-based approach is effectively preventing memory leaks. The observed increases in memory usage are a natural result of the project's evolution and do not indicate an underlying issue.
